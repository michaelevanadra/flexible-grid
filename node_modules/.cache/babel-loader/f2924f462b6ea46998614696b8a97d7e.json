{"ast":null,"code":"import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nfunction unwrapExports(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar jsoneditorMinimalist = createCommonjsModule(function (module, exports) {\n  /*!\n   * jsoneditor.js\n   *\n   * @brief\n   * JSONEditor is a web-based tool to view, edit, format, and validate JSON.\n   * It has various modes such as a tree editor, a code editor, and a plain text\n   * editor.\n   *\n   * Supported browsers: Chrome, Firefox, Safari, Opera, Internet Explorer 8+\n   *\n   * @license\n   * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n   * use this file except in compliance with the License. You may obtain a copy\n   * of the License at\n   *\n   * http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n   * License for the specific language governing permissions and limitations under\n   * the License.\n   *\n   * Copyright (c) 2011-2019 Jos de Jong, http://jsoneditoronline.org\n   *\n   * @author  Jos de Jong, <wjosdejong@gmail.com>\n   * @version 7.1.0\n   * @date    2019-10-13\n   */\n  (function webpackUniversalModuleDefinition(root, factory) {\n    module.exports = factory();\n  })(window, function () {\n    return (\n      /******/\n      function (modules) {\n        // webpackBootstrap\n\n        /******/\n        // The module cache\n\n        /******/\n        var installedModules = {};\n        /******/\n\n        /******/\n        // The require function\n\n        /******/\n\n        function __webpack_require__(moduleId) {\n          /******/\n\n          /******/\n          // Check if module is in cache\n\n          /******/\n          if (installedModules[moduleId]) {\n            /******/\n            return installedModules[moduleId].exports;\n            /******/\n          }\n          /******/\n          // Create a new module (and put it into the cache)\n\n          /******/\n\n\n          var module = installedModules[moduleId] = {\n            /******/\n            i: moduleId,\n\n            /******/\n            l: false,\n\n            /******/\n            exports: {}\n            /******/\n\n          };\n          /******/\n\n          /******/\n          // Execute the module function\n\n          /******/\n\n          modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n          /******/\n\n          /******/\n          // Flag the module as loaded\n\n          /******/\n\n          module.l = true;\n          /******/\n\n          /******/\n          // Return the exports of the module\n\n          /******/\n\n          return module.exports;\n          /******/\n        }\n        /******/\n\n        /******/\n\n        /******/\n        // expose the modules object (__webpack_modules__)\n\n        /******/\n\n\n        __webpack_require__.m = modules;\n        /******/\n\n        /******/\n        // expose the module cache\n\n        /******/\n\n        __webpack_require__.c = installedModules;\n        /******/\n\n        /******/\n        // define getter function for harmony exports\n\n        /******/\n\n        __webpack_require__.d = function (exports, name, getter) {\n          /******/\n          if (!__webpack_require__.o(exports, name)) {\n            /******/\n            Object.defineProperty(exports, name, {\n              enumerable: true,\n              get: getter\n            });\n            /******/\n          }\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // define __esModule on exports\n\n        /******/\n\n\n        __webpack_require__.r = function (exports) {\n          /******/\n          if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n            /******/\n            Object.defineProperty(exports, Symbol.toStringTag, {\n              value: 'Module'\n            });\n            /******/\n          }\n          /******/\n\n\n          Object.defineProperty(exports, '__esModule', {\n            value: true\n          });\n          /******/\n        };\n        /******/\n\n        /******/\n        // create a fake namespace object\n\n        /******/\n        // mode & 1: value is a module id, require it\n\n        /******/\n        // mode & 2: merge all properties of value into the ns\n\n        /******/\n        // mode & 4: return value when already ns object\n\n        /******/\n        // mode & 8|1: behave like require\n\n        /******/\n\n\n        __webpack_require__.t = function (value, mode) {\n          /******/\n          if (mode & 1) value = __webpack_require__(value);\n          /******/\n\n          if (mode & 8) return value;\n          /******/\n\n          if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;\n          /******/\n\n          var ns = Object.create(null);\n          /******/\n\n          __webpack_require__.r(ns);\n          /******/\n\n\n          Object.defineProperty(ns, 'default', {\n            enumerable: true,\n            value: value\n          });\n          /******/\n\n          if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) {\n            return value[key];\n          }.bind(null, key));\n          /******/\n\n          return ns;\n          /******/\n        };\n        /******/\n\n        /******/\n        // getDefaultExport function for compatibility with non-harmony modules\n\n        /******/\n\n\n        __webpack_require__.n = function (module) {\n          /******/\n          var getter = module && module.__esModule ?\n          /******/\n          function getDefault() {\n            return module['default'];\n          } :\n          /******/\n          function getModuleExports() {\n            return module;\n          };\n          /******/\n\n          __webpack_require__.d(getter, 'a', getter);\n          /******/\n\n\n          return getter;\n          /******/\n        };\n        /******/\n\n        /******/\n        // Object.prototype.hasOwnProperty.call\n\n        /******/\n\n\n        __webpack_require__.o = function (object, property) {\n          return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/\n\n        /******/\n        // __webpack_public_path__\n\n        /******/\n\n\n        __webpack_require__.p = \"\";\n        /******/\n\n        /******/\n\n        /******/\n        // Load entry module and return exports\n\n        /******/\n\n        return __webpack_require__(__webpack_require__.s = 20);\n        /******/\n      }(\n      /************************************************************************/\n\n      /******/\n      [\n      /* 0 */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        __webpack_require__.r(__webpack_exports__);\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"parse\", function () {\n          return parse;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"repair\", function () {\n          return repair;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"escapeUnicodeChars\", function () {\n          return escapeUnicodeChars;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"validate\", function () {\n          return validate;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"extend\", function () {\n          return extend;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"clear\", function () {\n          return clear;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"getType\", function () {\n          return getType;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"isUrl\", function () {\n          return isUrl;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"isArray\", function () {\n          return isArray;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"getAbsoluteLeft\", function () {\n          return getAbsoluteLeft;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"getAbsoluteTop\", function () {\n          return getAbsoluteTop;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"addClassName\", function () {\n          return addClassName;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"removeAllClassNames\", function () {\n          return removeAllClassNames;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"removeClassName\", function () {\n          return removeClassName;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"stripFormatting\", function () {\n          return stripFormatting;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"setEndOfContentEditable\", function () {\n          return setEndOfContentEditable;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"selectContentEditable\", function () {\n          return selectContentEditable;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"getSelection\", function () {\n          return getSelection;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"setSelection\", function () {\n          return setSelection;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"getSelectionOffset\", function () {\n          return getSelectionOffset;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"setSelectionOffset\", function () {\n          return setSelectionOffset;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"getInnerText\", function () {\n          return getInnerText;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"hasParentNode\", function () {\n          return hasParentNode;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"getInternetExplorerVersion\", function () {\n          return getInternetExplorerVersion;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"isFirefox\", function () {\n          return isFirefox;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"addEventListener\", function () {\n          return addEventListener;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"removeEventListener\", function () {\n          return removeEventListener;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"isChildOf\", function () {\n          return isChildOf;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"parsePath\", function () {\n          return parsePath;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"stringifyPath\", function () {\n          return stringifyPath;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"improveSchemaError\", function () {\n          return improveSchemaError;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"isPromise\", function () {\n          return isPromise;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"isValidValidationError\", function () {\n          return isValidValidationError;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"insideRect\", function () {\n          return insideRect;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"debounce\", function () {\n          return debounce;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"textDiff\", function () {\n          return textDiff;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"getInputSelection\", function () {\n          return getInputSelection;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"getIndexForPosition\", function () {\n          return getIndexForPosition;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"getPositionForPath\", function () {\n          return getPositionForPath;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"compileJSONPointer\", function () {\n          return compileJSONPointer;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"getColorCSS\", function () {\n          return getColorCSS;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"isValidColor\", function () {\n          return isValidColor;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"makeFieldTooltip\", function () {\n          return makeFieldTooltip;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"get\", function () {\n          return get;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"findUniqueName\", function () {\n          return findUniqueName;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"getChildPaths\", function () {\n          return getChildPaths;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"sort\", function () {\n          return sort;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"sortObjectKeys\", function () {\n          return sortObjectKeys;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"parseString\", function () {\n          return parseString;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"formatSize\", function () {\n          return formatSize;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"limitCharacters\", function () {\n          return limitCharacters;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"isObject\", function () {\n          return isObject;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"contains\", function () {\n          return contains;\n        });\n        /* harmony import */\n\n\n        var _polyfills__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);\n        /* harmony import */\n\n\n        var _polyfills__WEBPACK_IMPORTED_MODULE_0___default =\n        /*#__PURE__*/\n        __webpack_require__.n(_polyfills__WEBPACK_IMPORTED_MODULE_0__);\n        /* harmony import */\n\n\n        var javascript_natural_sort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);\n        /* harmony import */\n\n\n        var javascript_natural_sort__WEBPACK_IMPORTED_MODULE_1___default =\n        /*#__PURE__*/\n        __webpack_require__.n(javascript_natural_sort__WEBPACK_IMPORTED_MODULE_1__);\n        /* harmony import */\n\n\n        var _assets_jsonlint_jsonlint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(16);\n        /* harmony import */\n\n\n        var _assets_jsonlint_jsonlint__WEBPACK_IMPORTED_MODULE_2___default =\n        /*#__PURE__*/\n        __webpack_require__.n(_assets_jsonlint_jsonlint__WEBPACK_IMPORTED_MODULE_2__);\n        /* harmony import */\n\n\n        var json_source_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18);\n        /* harmony import */\n\n\n        var json_source_map__WEBPACK_IMPORTED_MODULE_3___default =\n        /*#__PURE__*/\n        __webpack_require__.n(json_source_map__WEBPACK_IMPORTED_MODULE_3__);\n        /* harmony import */\n\n\n        var _i18n__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1);\n\n        function _typeof(obj) {\n          if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n              return typeof obj;\n            };\n          } else {\n            _typeof = function _typeof(obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n          }\n\n          return _typeof(obj);\n        }\n\n        var MAX_ITEMS_FIELDS_COLLECTION = 10000;\n        /**\n         * Parse JSON using the parser built-in in the browser.\n         * On exception, the jsonString is validated and a detailed error is thrown.\n         * @param {String} jsonString\n         * @return {JSON} json\n         */\n\n        function parse(jsonString) {\n          try {\n            return JSON.parse(jsonString);\n          } catch (err) {\n            // try to throw a more detailed error message using validate\n            validate(jsonString); // rethrow the original error\n\n            throw err;\n          }\n        }\n        /**\n         * Repair a JSON-like string containing. For example changes JavaScript\n         * notation into JSON notation.\n         * This function for example changes a string like \"{a: 2, 'b': {c: 'd'}\"\n         * into '{\"a\": 2, \"b\": {\"c\": \"d\"}'\n         * @param {string} jsString\n         * @returns {string} json\n         */\n\n\n        function repair(jsString) {\n          // TODO: refactor this function, it's too large and complicated now\n          // escape all single and double quotes inside strings\n          var chars = [];\n          var i = 0; // If JSON starts with a function (characters/digits/\"_-\"), remove this function.\n          // This is useful for \"stripping\" JSONP objects to become JSON\n          // For example: /* some comment */ function_12321321 ( [{\"a\":\"b\"}] ); => [{\"a\":\"b\"}]\n\n          var match = jsString.match(/^\\s*(\\/\\*(.|[\\r\\n])*?\\*\\/)?\\s*[\\da-zA-Z_$]+\\s*\\(([\\s\\S]*)\\)\\s*;?\\s*$/);\n\n          if (match) {\n            jsString = match[3];\n          }\n\n          var controlChars = {\n            '\\b': '\\\\b',\n            '\\f': '\\\\f',\n            '\\n': '\\\\n',\n            '\\r': '\\\\r',\n            '\\t': '\\\\t'\n          };\n          var quote = '\\'';\n          var quoteDbl = '\"';\n          var quoteLeft = \"\\u2018\";\n          var quoteRight = \"\\u2019\";\n          var quoteDblLeft = \"\\u201C\";\n          var quoteDblRight = \"\\u201D\";\n          var graveAccent = \"`\";\n          var acuteAccent = \"\\xB4\"; // helper functions to get the current/prev/next character\n\n          function curr() {\n            return jsString.charAt(i);\n          }\n\n          function next() {\n            return jsString.charAt(i + 1);\n          }\n\n          function prev() {\n            return jsString.charAt(i - 1);\n          }\n\n          function isWhiteSpace(c) {\n            return c === ' ' || c === '\\n' || c === '\\r' || c === '\\t';\n          } // get the last parsed non-whitespace character\n\n\n          function lastNonWhitespace() {\n            var p = chars.length - 1;\n\n            while (p >= 0) {\n              var pp = chars[p];\n\n              if (!isWhiteSpace(pp)) {\n                return pp;\n              }\n\n              p--;\n            }\n\n            return '';\n          } // get at the first next non-white space character\n\n\n          function nextNonWhiteSpace() {\n            var iNext = i + 1;\n\n            while (iNext < jsString.length && isWhiteSpace(jsString[iNext])) {\n              iNext++;\n            }\n\n            return jsString[iNext];\n          } // skip a block comment '/* ... */'\n\n\n          function skipBlockComment() {\n            i += 2;\n\n            while (i < jsString.length && (curr() !== '*' || next() !== '/')) {\n              i++;\n            }\n\n            i += 2;\n          } // skip a comment '// ...'\n\n\n          function skipComment() {\n            i += 2;\n\n            while (i < jsString.length && curr() !== '\\n') {\n              i++;\n            }\n          }\n          /**\n           * parse single or double quoted string. Returns the parsed string\n           * @param {string} endQuote\n           * @return {string}\n           */\n\n\n          function parseString(endQuote) {\n            var string = '';\n            string += '\"';\n            i++;\n            var c = curr();\n\n            while (i < jsString.length && c !== endQuote) {\n              if (c === '\"' && prev() !== '\\\\') {\n                // unescaped double quote, escape it\n                string += '\\\\\"';\n              } else if (c in controlChars) {\n                // replace unescaped control characters with escaped ones\n                string += controlChars[c];\n              } else if (c === '\\\\') {\n                // remove the escape character when followed by a single quote ', not needed\n                i++;\n                c = curr();\n\n                if (c !== '\\'') {\n                  string += '\\\\';\n                }\n\n                string += c;\n              } else {\n                // regular character\n                string += c;\n              }\n\n              i++;\n              c = curr();\n            }\n\n            if (c === endQuote) {\n              string += '\"';\n              i++;\n            }\n\n            return string;\n          } // parse an unquoted key\n\n\n          function parseKey() {\n            var specialValues = ['null', 'true', 'false'];\n            var key = '';\n            var c = curr();\n            var regexp = /[a-zA-Z_$\\d]/; // letter, number, underscore, dollar character\n\n            while (regexp.test(c)) {\n              key += c;\n              i++;\n              c = curr();\n            }\n\n            if (specialValues.indexOf(key) === -1) {\n              return '\"' + key + '\"';\n            } else {\n              return key;\n            }\n          }\n\n          function parseMongoDataType() {\n            var c = curr();\n            var value;\n            var dataType = '';\n\n            while (/[a-zA-Z_$]/.test(c)) {\n              dataType += c;\n              i++;\n              c = curr();\n            }\n\n            if (dataType.length > 0 && c === '(') {\n              // This is an MongoDB data type like {\"_id\": ObjectId(\"123\")}\n              i++;\n              c = curr();\n\n              if (c === '\"') {\n                // a data type containing a string, like ISODate(\"2012-12-19T06:01:17.171Z\")\n                value = parseString(c);\n                c = curr();\n              } else {\n                // a data type containing a value, like 'NumberLong(2)'\n                value = '';\n\n                while (c !== ')' && c !== '') {\n                  value += c;\n                  i++;\n                  c = curr();\n                }\n              }\n\n              if (c === ')') {\n                // skip the closing bracket at the end\n                i++; // return the value (strip the data type object)\n\n                return value;\n              } else {\n                // huh? that's unexpected. don't touch it\n                return dataType + '(' + value + c;\n              }\n            } else {\n              // hm, no Mongo data type after all\n              return dataType;\n            }\n          }\n\n          function isSpecialWhiteSpace(c) {\n            return c === \"\\xA0\" || c >= \"\\u2000\" && c <= \"\\u200A\" || c === \"\\u202F\" || c === \"\\u205F\" || c === \"\\u3000\";\n          }\n\n          while (i < jsString.length) {\n            var c = curr();\n\n            if (c === '/' && next() === '*') {\n              skipBlockComment();\n            } else if (c === '/' && next() === '/') {\n              skipComment();\n            } else if (isSpecialWhiteSpace(c)) {\n              // special white spaces (like non breaking space)\n              chars.push(' ');\n              i++;\n            } else if (c === quote) {\n              chars.push(parseString(c));\n            } else if (c === quoteDbl) {\n              chars.push(parseString(quoteDbl));\n            } else if (c === graveAccent) {\n              chars.push(parseString(acuteAccent));\n            } else if (c === quoteLeft) {\n              chars.push(parseString(quoteRight));\n            } else if (c === quoteDblLeft) {\n              chars.push(parseString(quoteDblRight));\n            } else if (c === ',' && [']', '}'].indexOf(nextNonWhiteSpace()) !== -1) {\n              // skip trailing commas\n              i++;\n            } else if (/[a-zA-Z_$]/.test(c) && ['{', ','].indexOf(lastNonWhitespace()) !== -1) {\n              // an unquoted object key (like a in '{a:2}')\n              chars.push(parseKey());\n            } else {\n              if (/[a-zA-Z_$]/.test(c)) {\n                chars.push(parseMongoDataType());\n              } else {\n                chars.push(c);\n                i++;\n              }\n            }\n          }\n\n          return chars.join('');\n        }\n        /**\n         * Escape unicode characters.\n         * For example input '\\u2661' (length 1) will output '\\\\u2661' (length 5).\n         * @param {string} text\n         * @return {string}\n         */\n\n\n        function escapeUnicodeChars( // see https://www.wikiwand.com/en/UTF-16\n        text) {\n          return (// note: we leave surrogate pairs as two individual chars,\n            // as JSON doesn't interpret them as a single unicode char.\n            text.replace(/[\\u007F-\\uFFFF]/g, function (c) {\n              return \"\\\\u\" + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);\n            })\n          );\n        }\n        /**\n         * Validate a string containing a JSON object\n         * This method uses JSONLint to validate the String. If JSONLint is not\n         * available, the built-in JSON parser of the browser is used.\n         * @param {String} jsonString   String with an (invalid) JSON object\n         * @throws Error\n         */\n\n\n        function validate(jsonString) {\n          if (typeof _assets_jsonlint_jsonlint__WEBPACK_IMPORTED_MODULE_2___default.a !== 'undefined') {\n            _assets_jsonlint_jsonlint__WEBPACK_IMPORTED_MODULE_2___default.a.parse(jsonString);\n          } else {\n            JSON.parse(jsonString);\n          }\n        }\n        /**\n         * Extend object a with the properties of object b\n         * @param {Object} a\n         * @param {Object} b\n         * @return {Object} a\n         */\n\n\n        function extend(a, b) {\n          for (var prop in b) {\n            if (hasOwnProperty(b, prop)) {\n              a[prop] = b[prop];\n            }\n          }\n\n          return a;\n        }\n        /**\n         * Remove all properties from object a\n         * @param {Object} a\n         * @return {Object} a\n         */\n\n\n        function clear(a) {\n          for (var prop in a) {\n            if (hasOwnProperty(a, prop)) {\n              delete a[prop];\n            }\n          }\n\n          return a;\n        }\n        /**\n         * Get the type of an object\n         * @param {*} object\n         * @return {String} type\n         */\n\n\n        function getType(object) {\n          if (object === null) {\n            return 'null';\n          }\n\n          if (object === undefined) {\n            return 'undefined';\n          }\n\n          if (object instanceof Number || typeof object === 'number') {\n            return 'number';\n          }\n\n          if (object instanceof String || typeof object === 'string') {\n            return 'string';\n          }\n\n          if (object instanceof Boolean || typeof object === 'boolean') {\n            return 'boolean';\n          }\n\n          if (object instanceof RegExp) {\n            return 'regexp';\n          }\n\n          if (isArray(object)) {\n            return 'array';\n          }\n\n          return 'object';\n        }\n        /**\n         * Test whether a text contains a url (matches when a string starts\n         * with 'http://*' or 'https://*' and has no whitespace characters)\n         * @param {String} text\n         */\n\n\n        var isUrlRegex = /^https?:\\/\\/\\S+$/;\n\n        function isUrl(text) {\n          return (typeof text === 'string' || text instanceof String) && isUrlRegex.test(text);\n        }\n        /**\n         * Tes whether given object is an Array\n         * @param {*} obj\n         * @returns {boolean} returns true when obj is an array\n         */\n\n\n        function isArray(obj) {\n          return Object.prototype.toString.call(obj) === '[object Array]';\n        }\n        /**\n         * Retrieve the absolute left value of a DOM element\n         * @param {Element} elem    A dom element, for example a div\n         * @return {Number} left    The absolute left position of this element\n         *                          in the browser page.\n         */\n\n\n        function getAbsoluteLeft(elem) {\n          var rect = elem.getBoundingClientRect();\n          return rect.left + window.pageXOffset || document.scrollLeft || 0;\n        }\n        /**\n         * Retrieve the absolute top value of a DOM element\n         * @param {Element} elem    A dom element, for example a div\n         * @return {Number} top     The absolute top position of this element\n         *                          in the browser page.\n         */\n\n\n        function getAbsoluteTop(elem) {\n          var rect = elem.getBoundingClientRect();\n          return rect.top + window.pageYOffset || document.scrollTop || 0;\n        }\n        /**\n         * add a className to the given elements style\n         * @param {Element} elem\n         * @param {String} className\n         */\n\n\n        function addClassName(elem, className) {\n          var classes = elem.className.split(' ');\n\n          if (classes.indexOf(className) === -1) {\n            classes.push(className); // add the class to the array\n\n            elem.className = classes.join(' ');\n          }\n        }\n        /**\n         * remove all classes from the given elements style\n         * @param {Element} elem\n         */\n\n\n        function removeAllClassNames(elem) {\n          elem.className = '';\n        }\n        /**\n         * add a className to the given elements style\n         * @param {Element} elem\n         * @param {String} className\n         */\n\n\n        function removeClassName(elem, className) {\n          var classes = elem.className.split(' ');\n          var index = classes.indexOf(className);\n\n          if (index !== -1) {\n            classes.splice(index, 1); // remove the class from the array\n\n            elem.className = classes.join(' ');\n          }\n        }\n        /**\n         * Strip the formatting from the contents of a div\n         * the formatting from the div itself is not stripped, only from its childs.\n         * @param {Element} divElement\n         */\n\n\n        function stripFormatting(divElement) {\n          var childs = divElement.childNodes;\n\n          for (var i = 0, iMax = childs.length; i < iMax; i++) {\n            var child = childs[i]; // remove the style\n\n            if (child.style) {\n              // TODO: test if child.attributes does contain style\n              child.removeAttribute('style');\n            } // remove all attributes\n\n\n            var attributes = child.attributes;\n\n            if (attributes) {\n              for (var j = attributes.length - 1; j >= 0; j--) {\n                var attribute = attributes[j];\n\n                if (attribute.specified === true) {\n                  child.removeAttribute(attribute.name);\n                }\n              }\n            } // recursively strip childs\n\n\n            stripFormatting(child);\n          }\n        }\n        /**\n         * Set focus to the end of an editable div\n         * code from Nico Burns\n         * http://stackoverflow.com/users/140293/nico-burns\n         * http://stackoverflow.com/questions/1125292/how-to-move-cursor-to-end-of-contenteditable-entity\n         * @param {Element} contentEditableElement   A content editable div\n         */\n\n\n        function setEndOfContentEditable(contentEditableElement) {\n          var range, selection;\n\n          if (document.createRange) {\n            range = document.createRange(); // Create a range (a range is a like the selection but invisible)\n\n            range.selectNodeContents(contentEditableElement); // Select the entire contents of the element with the range\n\n            range.collapse(false); // collapse the range to the end point. false means collapse to end rather than the start\n\n            selection = window.getSelection(); // get the selection object (allows you to change selection)\n\n            selection.removeAllRanges(); // remove any selections already made\n\n            selection.addRange(range); // make the range you have just created the visible selection\n          }\n        }\n        /**\n         * Select all text of a content editable div.\n         * http://stackoverflow.com/a/3806004/1262753\n         * @param {Element} contentEditableElement   A content editable div\n         */\n\n\n        function selectContentEditable(contentEditableElement) {\n          if (!contentEditableElement || contentEditableElement.nodeName !== 'DIV') {\n            return;\n          }\n\n          var sel, range;\n\n          if (window.getSelection && document.createRange) {\n            range = document.createRange();\n            range.selectNodeContents(contentEditableElement);\n            sel = window.getSelection();\n            sel.removeAllRanges();\n            sel.addRange(range);\n          }\n        }\n        /**\n         * Get text selection\n         * http://stackoverflow.com/questions/4687808/contenteditable-selected-text-save-and-restore\n         * @return {Range | TextRange | null} range\n         */\n\n\n        function getSelection() {\n          if (window.getSelection) {\n            var sel = window.getSelection();\n\n            if (sel.getRangeAt && sel.rangeCount) {\n              return sel.getRangeAt(0);\n            }\n          }\n\n          return null;\n        }\n        /**\n         * Set text selection\n         * http://stackoverflow.com/questions/4687808/contenteditable-selected-text-save-and-restore\n         * @param {Range | TextRange | null} range\n         */\n\n\n        function setSelection(range) {\n          if (range) {\n            if (window.getSelection) {\n              var sel = window.getSelection();\n              sel.removeAllRanges();\n              sel.addRange(range);\n            }\n          }\n        }\n        /**\n         * Get selected text range\n         * @return {Object} params  object containing parameters:\n         *                              {Number}  startOffset\n         *                              {Number}  endOffset\n         *                              {Element} container  HTML element holding the\n         *                                                   selected text element\n         *                          Returns null if no text selection is found\n         */\n\n\n        function getSelectionOffset() {\n          var range = getSelection();\n\n          if (range && 'startOffset' in range && 'endOffset' in range && range.startContainer && range.startContainer === range.endContainer) {\n            return {\n              startOffset: range.startOffset,\n              endOffset: range.endOffset,\n              container: range.startContainer.parentNode\n            };\n          }\n\n          return null;\n        }\n        /**\n         * Set selected text range in given element\n         * @param {Object} params   An object containing:\n         *                              {Element} container\n         *                              {Number} startOffset\n         *                              {Number} endOffset\n         */\n\n\n        function setSelectionOffset(params) {\n          if (document.createRange && window.getSelection) {\n            var selection = window.getSelection();\n\n            if (selection) {\n              var range = document.createRange();\n\n              if (!params.container.firstChild) {\n                params.container.appendChild(document.createTextNode(''));\n              } // TODO: do not suppose that the first child of the container is a textnode,\n              //       but recursively find the textnodes\n\n\n              range.setStart(params.container.firstChild, params.startOffset);\n              range.setEnd(params.container.firstChild, params.endOffset);\n              setSelection(range);\n            }\n          }\n        }\n        /**\n         * Get the inner text of an HTML element (for example a div element)\n         * @param {Element} element\n         * @param {Object} [buffer]\n         * @return {String} innerText\n         */\n\n\n        function getInnerText(element, buffer) {\n          var first = buffer === undefined;\n\n          if (first) {\n            buffer = {\n              text: '',\n              flush: function flush() {\n                var text = this.text;\n                this.text = '';\n                return text;\n              },\n              set: function set(text) {\n                this.text = text;\n              }\n            };\n          } // text node\n\n\n          if (element.nodeValue) {\n            return buffer.flush() + element.nodeValue;\n          } // divs or other HTML elements\n\n\n          if (element.hasChildNodes()) {\n            var childNodes = element.childNodes;\n            var innerText = '';\n\n            for (var i = 0, iMax = childNodes.length; i < iMax; i++) {\n              var child = childNodes[i];\n\n              if (child.nodeName === 'DIV' || child.nodeName === 'P') {\n                var prevChild = childNodes[i - 1];\n                var prevName = prevChild ? prevChild.nodeName : undefined;\n\n                if (prevName && prevName !== 'DIV' && prevName !== 'P' && prevName !== 'BR') {\n                  innerText += '\\n';\n                  buffer.flush();\n                }\n\n                innerText += getInnerText(child, buffer);\n                buffer.set('\\n');\n              } else if (child.nodeName === 'BR') {\n                innerText += buffer.flush();\n                buffer.set('\\n');\n              } else {\n                innerText += getInnerText(child, buffer);\n              }\n            }\n\n            return innerText;\n          } else {\n            if (element.nodeName === 'P' && getInternetExplorerVersion() !== -1) {\n              // On Internet Explorer, a <p> with hasChildNodes()==false is\n              // rendered with a new line. Note that a <p> with\n              // hasChildNodes()==true is rendered without a new line\n              // Other browsers always ensure there is a <br> inside the <p>,\n              // and if not, the <p> does not render a new line\n              return buffer.flush();\n            }\n          } // br or unknown\n\n\n          return '';\n        }\n        /**\n         * Test whether an element has the provided parent node somewhere up the node tree.\n         * @param {Element} elem\n         * @param {Element} parent\n         * @return {boolean}\n         */\n\n\n        function hasParentNode(elem, parent) {\n          var e = elem ? elem.parentNode : undefined;\n\n          while (e) {\n            if (e === parent) {\n              return true;\n            }\n\n            e = e.parentNode;\n          }\n\n          return false;\n        }\n        /**\n         * Returns the version of Internet Explorer or a -1\n         * (indicating the use of another browser).\n         * Source: http://msdn.microsoft.com/en-us/library/ms537509(v=vs.85).aspx\n         * @return {Number} Internet Explorer version, or -1 in case of an other browser\n         */\n\n\n        function getInternetExplorerVersion() {\n          if (_ieVersion === -1) {\n            var rv = -1; // Return value assumes failure.\n\n            if (typeof navigator !== 'undefined' && navigator.appName === 'Microsoft Internet Explorer') {\n              var ua = navigator.userAgent;\n              var re = new RegExp('MSIE ([0-9]+[.0-9]+)');\n\n              if (re.exec(ua) != null) {\n                rv = parseFloat(RegExp.$1);\n              }\n            }\n\n            _ieVersion = rv;\n          }\n\n          return _ieVersion;\n        }\n        /**\n         * Test whether the current browser is Firefox\n         * @returns {boolean} isFirefox\n         */\n\n\n        function isFirefox() {\n          return typeof navigator !== 'undefined' && navigator.userAgent.indexOf('Firefox') !== -1;\n        }\n        /**\n         * cached internet explorer version\n         * @type {Number}\n         * @private\n         */\n\n\n        var _ieVersion = -1;\n        /**\n         * Add and event listener. Works for all browsers\n         * @param {Element}     element    An html element\n         * @param {string}      action     The action, for example \"click\",\n         *                                 without the prefix \"on\"\n         * @param {function}    listener   The callback function to be executed\n         * @param {boolean}     [useCapture] false by default\n         * @return {function}   the created event listener\n         */\n\n\n        function addEventListener(element, action, listener, useCapture) {\n          if (element.addEventListener) {\n            if (useCapture === undefined) {\n              useCapture = false;\n            }\n\n            if (action === 'mousewheel' && isFirefox()) {\n              action = 'DOMMouseScroll'; // For Firefox\n            }\n\n            element.addEventListener(action, listener, useCapture);\n            return listener;\n          } else if (element.attachEvent) {\n            // Old IE browsers\n            var f = function f() {\n              return listener.call(element, window.event);\n            };\n\n            element.attachEvent('on' + action, f);\n            return f;\n          }\n        }\n        /**\n         * Remove an event listener from an element\n         * @param {Element}  element   An html dom element\n         * @param {string}   action    The name of the event, for example \"mousedown\"\n         * @param {function} listener  The listener function\n         * @param {boolean}  [useCapture]   false by default\n         */\n\n\n        function removeEventListener(element, action, listener, useCapture) {\n          if (element.removeEventListener) {\n            if (useCapture === undefined) {\n              useCapture = false;\n            }\n\n            if (action === 'mousewheel' && isFirefox()) {\n              action = 'DOMMouseScroll'; // For Firefox\n            }\n\n            element.removeEventListener(action, listener, useCapture);\n          } else if (element.detachEvent) {\n            // Old IE browsers\n            element.detachEvent('on' + action, listener);\n          }\n        }\n        /**\n         * Test if an element is a child of a parent element.\n         * @param {Element} elem\n         * @param {Element} parent\n         * @return {boolean} returns true if elem is a child of the parent\n         */\n\n\n        function isChildOf(elem, parent) {\n          var e = elem.parentNode;\n\n          while (e) {\n            if (e === parent) {\n              return true;\n            }\n\n            e = e.parentNode;\n          }\n\n          return false;\n        }\n        /**\n         * Parse a JSON path like '.items[3].name' into an array\n         * @param {string} jsonPath\n         * @return {Array}\n         */\n\n\n        function parsePath(jsonPath) {\n          var path = [];\n          var i = 0;\n\n          function parseProperty() {\n            var prop = '';\n\n            while (jsonPath[i] !== undefined && /[\\w$]/.test(jsonPath[i])) {\n              prop += jsonPath[i];\n              i++;\n            }\n\n            if (prop === '') {\n              throw new Error('Invalid JSON path: property name expected at index ' + i);\n            }\n\n            return prop;\n          }\n\n          function parseIndex(end) {\n            var name = '';\n\n            while (jsonPath[i] !== undefined && jsonPath[i] !== end) {\n              name += jsonPath[i];\n              i++;\n            }\n\n            if (jsonPath[i] !== end) {\n              throw new Error('Invalid JSON path: unexpected end, character ' + end + ' expected');\n            }\n\n            return name;\n          }\n\n          while (jsonPath[i] !== undefined) {\n            if (jsonPath[i] === '.') {\n              i++;\n              path.push(parseProperty());\n            } else if (jsonPath[i] === '[') {\n              i++;\n\n              if (jsonPath[i] === '\\'' || jsonPath[i] === '\"') {\n                var end = jsonPath[i];\n                i++;\n                path.push(parseIndex(end));\n\n                if (jsonPath[i] !== end) {\n                  throw new Error('Invalid JSON path: closing quote \\' expected at index ' + i);\n                }\n\n                i++;\n              } else {\n                var index = parseIndex(']').trim();\n\n                if (index.length === 0) {\n                  throw new Error('Invalid JSON path: array value expected at index ' + i);\n                } // Coerce numeric indices to numbers, but ignore star\n\n\n                index = index === '*' ? index : JSON.parse(index);\n                path.push(index);\n              }\n\n              if (jsonPath[i] !== ']') {\n                throw new Error('Invalid JSON path: closing bracket ] expected at index ' + i);\n              }\n\n              i++;\n            } else {\n              throw new Error('Invalid JSON path: unexpected character \"' + jsonPath[i] + '\" at index ' + i);\n            }\n          }\n\n          return path;\n        }\n        /**\n         * Stringify an array with a path in a JSON path like '.items[3].name'\n         * @param {Array.<string | number>} path\n         * @returns {string}\n         */\n\n\n        function stringifyPath(path) {\n          return path.map(function (p) {\n            if (typeof p === 'number') {\n              return '[' + p + ']';\n            } else if (typeof p === 'string' && p.match(/^[A-Za-z0-9_$]+$/)) {\n              return '.' + p;\n            } else {\n              return '[\"' + p + '\"]';\n            }\n          }).join('');\n        }\n        /**\n         * Improve the error message of a JSON schema error\n         * @param {Object} error\n         * @return {Object} The error\n         */\n\n\n        function improveSchemaError(error) {\n          if (error.keyword === 'enum' && Array.isArray(error.schema)) {\n            var enums = error.schema;\n\n            if (enums) {\n              enums = enums.map(function (value) {\n                return JSON.stringify(value);\n              });\n\n              if (enums.length > 5) {\n                var more = ['(' + (enums.length - 5) + ' more...)'];\n                enums = enums.slice(0, 5);\n                enums.push(more);\n              }\n\n              error.message = 'should be equal to one of: ' + enums.join(', ');\n            }\n          }\n\n          if (error.keyword === 'additionalProperties') {\n            error.message = 'should NOT have additional property: ' + error.params.additionalProperty;\n          }\n\n          return error;\n        }\n        /**\n         * Test whether something is a Promise\n         * @param {*} object\n         * @returns {boolean} Returns true when object is a promise, false otherwise\n         */\n\n\n        function isPromise(object) {\n          return object && typeof object.then === 'function' && typeof object[\"catch\"] === 'function';\n        }\n        /**\n         * Test whether a custom validation error has the correct structure\n         * @param {*} validationError The error to be checked.\n         * @returns {boolean} Returns true if the structure is ok, false otherwise\n         */\n\n\n        function isValidValidationError(validationError) {\n          return _typeof(validationError) === 'object' && Array.isArray(validationError.path) && typeof validationError.message === 'string';\n        }\n        /**\n         * Test whether the child rect fits completely inside the parent rect.\n         * @param {ClientRect} parent\n         * @param {ClientRect} child\n         * @param {number} margin\n         */\n\n\n        function insideRect(parent, child, margin) {\n          var _margin = margin !== undefined ? margin : 0;\n\n          return child.left - _margin >= parent.left && child.right + _margin <= parent.right && child.top - _margin >= parent.top && child.bottom + _margin <= parent.bottom;\n        }\n        /**\n         * Returns a function, that, as long as it continues to be invoked, will not\n         * be triggered. The function will be called after it stops being called for\n         * N milliseconds.\n         *\n         * Source: https://davidwalsh.name/javascript-debounce-function\n         *\n         * @param {function} func\n         * @param {number} wait                 Number in milliseconds\n         * @param {boolean} [immediate=false]   If `immediate` is passed, trigger the\n         *                                      function on the leading edge, instead\n         *                                      of the trailing.\n         * @return {function} Return the debounced function\n         */\n\n\n        function debounce(func, wait, immediate) {\n          var timeout;\n          return function () {\n            var context = this;\n            var args = arguments;\n\n            var later = function later() {\n              timeout = null;\n              if (!immediate) func.apply(context, args);\n            };\n\n            var callNow = immediate && !timeout;\n            clearTimeout(timeout);\n            timeout = setTimeout(later, wait);\n            if (callNow) func.apply(context, args);\n          };\n        }\n        /**\n         * Determines the difference between two texts.\n         * Can only detect one removed or inserted block of characters.\n         * @param {string} oldText\n         * @param {string} newText\n         * @return {{start: number, end: number}} Returns the start and end\n         *                                        of the changed part in newText.\n         */\n\n\n        function textDiff(oldText, newText) {\n          var len = newText.length;\n          var start = 0;\n          var oldEnd = oldText.length;\n          var newEnd = newText.length;\n\n          while (newText.charAt(start) === oldText.charAt(start) && start < len) {\n            start++;\n          }\n\n          while (newText.charAt(newEnd - 1) === oldText.charAt(oldEnd - 1) && newEnd > start && oldEnd > 0) {\n            newEnd--;\n            oldEnd--;\n          }\n\n          return {\n            start: start,\n            end: newEnd\n          };\n        }\n        /**\n         * Return an object with the selection range or cursor position (if both have the same value)\n         * Support also old browsers (IE8-)\n         * Source: http://ourcodeworld.com/articles/read/282/how-to-get-the-current-cursor-position-and-selection-within-a-text-input-or-textarea-in-javascript\n         * @param {DOMElement} el A dom element of a textarea or input text.\n         * @return {Object} reference Object with 2 properties (start and end) with the identifier of the location of the cursor and selected text.\n         **/\n\n\n        function getInputSelection(el) {\n          var startIndex = 0;\n          var endIndex = 0;\n          var normalizedValue;\n          var range;\n          var textInputRange;\n          var len;\n          var endRange;\n\n          if (typeof el.selectionStart === 'number' && typeof el.selectionEnd === 'number') {\n            startIndex = el.selectionStart;\n            endIndex = el.selectionEnd;\n          } else {\n            range = document.selection.createRange();\n\n            if (range && range.parentElement() === el) {\n              len = el.value.length;\n              normalizedValue = el.value.replace(/\\r\\n/g, '\\n'); // Create a working TextRange that lives only in the input\n\n              textInputRange = el.createTextRange();\n              textInputRange.moveToBookmark(range.getBookmark()); // Check if the startIndex and endIndex of the selection are at the very end\n              // of the input, since moveStart/moveEnd doesn't return what we want\n              // in those cases\n\n              endRange = el.createTextRange();\n              endRange.collapse(false);\n\n              if (textInputRange.compareEndPoints('StartToEnd', endRange) > -1) {\n                startIndex = endIndex = len;\n              } else {\n                startIndex = -textInputRange.moveStart('character', -len);\n                startIndex += normalizedValue.slice(0, startIndex).split('\\n').length - 1;\n\n                if (textInputRange.compareEndPoints('EndToEnd', endRange) > -1) {\n                  endIndex = len;\n                } else {\n                  endIndex = -textInputRange.moveEnd('character', -len);\n                  endIndex += normalizedValue.slice(0, endIndex).split('\\n').length - 1;\n                }\n              }\n            }\n          }\n\n          return {\n            startIndex: startIndex,\n            endIndex: endIndex,\n            start: _positionForIndex(startIndex),\n            end: _positionForIndex(endIndex)\n          };\n          /**\n           * Returns textarea row and column position for certain index\n           * @param {Number} index text index\n           * @returns {{row: Number, column: Number}}\n           */\n\n          function _positionForIndex(index) {\n            var textTillIndex = el.value.substring(0, index);\n            var row = (textTillIndex.match(/\\n/g) || []).length + 1;\n            var col = textTillIndex.length - textTillIndex.lastIndexOf('\\n');\n            return {\n              row: row,\n              column: col\n            };\n          }\n        }\n        /**\n         * Returns the index for certaion position in text element\n         * @param {DOMElement} el A dom element of a textarea or input text.\n         * @param {Number} row row value, > 0, if exceeds rows number - last row will be returned\n         * @param {Number} column column value, > 0, if exceeds column length - end of column will be returned\n         * @returns {Number} index of position in text, -1 if not found\n         */\n\n\n        function getIndexForPosition(el, row, column) {\n          var text = el.value || '';\n\n          if (row > 0 && column > 0) {\n            var rows = text.split('\\n', row);\n            row = Math.min(rows.length, row);\n            column = Math.min(rows[row - 1].length, column - 1);\n            var columnCount = row === 1 ? column : column + 1; // count new line on multiple rows\n\n            return rows.slice(0, row - 1).join('\\n').length + columnCount;\n          }\n\n          return -1;\n        }\n        /**\n         * Returns location of json paths in certain json string\n         * @param {String} text json string\n         * @param {Array<String>} paths array of json paths\n         * @returns {Array<{path: String, line: Number, row: Number}>}\n         */\n\n\n        function getPositionForPath(text, paths) {\n          var result = [];\n          var jsmap;\n\n          if (!paths || !paths.length) {\n            return result;\n          }\n\n          try {\n            jsmap = json_source_map__WEBPACK_IMPORTED_MODULE_3___default.a.parse(text);\n          } catch (err) {\n            return result;\n          }\n\n          paths.forEach(function (path) {\n            var pathArr = parsePath(path);\n            var pointerName = compileJSONPointer(pathArr);\n            var pointer = jsmap.pointers[pointerName];\n\n            if (pointer) {\n              result.push({\n                path: path,\n                line: pointer.key ? pointer.key.line : pointer.value ? pointer.value.line : 0,\n                column: pointer.key ? pointer.key.column : pointer.value ? pointer.value.column : 0\n              });\n            }\n          });\n          return result;\n        }\n        /**\n         * Compile a JSON Pointer\n         * WARNING: this is an incomplete implementation\n         * @param {Array.<string | number>} path\n         * @return {string}\n         */\n\n\n        function compileJSONPointer(path) {\n          return path.map(function (p) {\n            return '/' + String(p).replace(/~/g, '~0').replace(/\\//g, '~1');\n          }).join('');\n        }\n        /**\n         * Get the applied color given a color name or code\n         * Source: https://stackoverflow.com/questions/6386090/validating-css-color-names/33184805\n         * @param {string} color\n         * @returns {string | null} returns the color if the input is a valid\n         *                   color, and returns null otherwise. Example output:\n         *                   'rgba(255,0,0,0.7)' or 'rgb(255,0,0)'\n         */\n\n\n        function getColorCSS(color) {\n          var ele = document.createElement('div');\n          ele.style.color = color;\n          return ele.style.color.split(/\\s+/).join('').toLowerCase() || null;\n        }\n        /**\n         * Test if a string contains a valid color name or code.\n         * @param {string} color\n         * @returns {boolean} returns true if a valid color, false otherwise\n         */\n\n\n        function isValidColor(color) {\n          return !!getColorCSS(color);\n        }\n        /**\n         * Make a tooltip for a field based on the field's schema.\n         * @param {object} schema JSON schema\n         * @param {string} [locale] Locale code (for example, zh-CN)\n         * @returns {string} Field tooltip, may be empty string if all relevant schema properties are missing\n         */\n\n\n        function makeFieldTooltip(schema, locale) {\n          if (!schema) {\n            return '';\n          }\n\n          var tooltip = '';\n\n          if (schema.title) {\n            tooltip += schema.title;\n          }\n\n          if (schema.description) {\n            if (tooltip.length > 0) {\n              tooltip += '\\n';\n            }\n\n            tooltip += schema.description;\n          }\n\n          if (schema[\"default\"]) {\n            if (tooltip.length > 0) {\n              tooltip += '\\n\\n';\n            }\n\n            tooltip += Object(_i18n__WEBPACK_IMPORTED_MODULE_4__[\n            /* translate */\n            \"c\"])('default', undefined, locale) + '\\n';\n            tooltip += JSON.stringify(schema[\"default\"], null, 2);\n          }\n\n          if (Array.isArray(schema.examples) && schema.examples.length > 0) {\n            if (tooltip.length > 0) {\n              tooltip += '\\n\\n';\n            }\n\n            tooltip += Object(_i18n__WEBPACK_IMPORTED_MODULE_4__[\n            /* translate */\n            \"c\"])('examples', undefined, locale) + '\\n';\n            schema.examples.forEach(function (example, index) {\n              tooltip += JSON.stringify(example, null, 2);\n\n              if (index !== schema.examples.length - 1) {\n                tooltip += '\\n';\n              }\n            });\n          }\n\n          return tooltip;\n        }\n        /**\n         * Get a nested property from an object.\n         * Returns undefined when the property does not exist.\n         * @param {Object} object\n         * @param {string[]} path\n         * @return {*}\n         */\n\n\n        function get(object, path) {\n          var value = object;\n\n          for (var i = 0; i < path.length && value !== undefined && value !== null; i++) {\n            value = value[path[i]];\n          }\n\n          return value;\n        }\n        /**\n         * Find a unique name. Suffix the name with ' (copy)', '(copy 2)', etc\n         * until a unique name is found\n         * @param {string} name\n         * @param {Array} existingPropNames    Array with existing prop names\n         */\n\n\n        function findUniqueName(name, existingPropNames) {\n          var strippedName = name.replace(/ \\(copy( \\d+)?\\)$/, '');\n          var validName = strippedName;\n          var i = 1;\n\n          while (existingPropNames.indexOf(validName) !== -1) {\n            var copy = 'copy' + (i > 1 ? ' ' + i : '');\n            validName = strippedName + ' (' + copy + ')';\n            i++;\n          }\n\n          return validName;\n        }\n        /**\n         * Get the child paths of an array\n         * @param {JSON} json\n         * @param {boolean} [includeObjects=false] If true, object and array paths are returned as well\n         * @return {string[]}\n         */\n\n\n        function getChildPaths(json, includeObjects) {\n          var pathsMap = {};\n\n          function getObjectChildPaths(json, pathsMap, rootPath, includeObjects) {\n            var isValue = !Array.isArray(json) && !isObject(json);\n\n            if (isValue || includeObjects) {\n              pathsMap[rootPath || ''] = true;\n            }\n\n            if (isObject(json)) {\n              Object.keys(json).forEach(function (field) {\n                getObjectChildPaths(json[field], pathsMap, rootPath + '.' + field, includeObjects);\n              });\n            }\n          }\n\n          if (Array.isArray(json)) {\n            var max = Math.min(json.length, MAX_ITEMS_FIELDS_COLLECTION);\n\n            for (var i = 0; i < max; i++) {\n              var item = json[i];\n              getObjectChildPaths(item, pathsMap, '', includeObjects);\n            }\n          } else {\n            pathsMap[''] = true;\n          }\n\n          return Object.keys(pathsMap).sort();\n        }\n        /**\n         * Sort object keys using natural sort\n         * @param {Array} array\n         * @param {String} [path] JSON pointer\n         * @param {'asc' | 'desc'} [direction]\n         */\n\n\n        function sort(array, path, direction) {\n          var parsedPath = path && path !== '.' ? parsePath(path) : [];\n          var sign = direction === 'desc' ? -1 : 1;\n          var sortedArray = array.slice();\n          sortedArray.sort(function (a, b) {\n            var aValue = get(a, parsedPath);\n            var bValue = get(b, parsedPath);\n            return sign * (aValue > bValue ? 1 : aValue < bValue ? -1 : 0);\n          });\n          return sortedArray;\n        }\n        /**\n         * Sort object keys using natural sort\n         * @param {Object} object\n         * @param {'asc' | 'desc'} [direction]\n         */\n\n\n        function sortObjectKeys(object, direction) {\n          var sign = direction === 'desc' ? -1 : 1;\n          var sortedFields = Object.keys(object).sort(function (a, b) {\n            return sign * javascript_natural_sort__WEBPACK_IMPORTED_MODULE_1___default()(a, b);\n          });\n          var sortedObject = {};\n          sortedFields.forEach(function (field) {\n            sortedObject[field] = object[field];\n          });\n          return sortedObject;\n        }\n        /**\n         * Cast contents of a string to the correct type.\n         * This can be a string, a number, a boolean, etc\n         * @param {String} str\n         * @return {*} castedStr\n         * @private\n         */\n\n\n        function parseString(str) {\n          if (str === '') {\n            return '';\n          }\n\n          var lower = str.toLowerCase();\n\n          if (lower === 'null') {\n            return null;\n          }\n\n          if (lower === 'true') {\n            return true;\n          }\n\n          if (lower === 'false') {\n            return false;\n          }\n\n          var num = Number(str); // will nicely fail with '123ab'\n\n          var numFloat = parseFloat(str); // will nicely fail with '  '\n\n          if (!isNaN(num) && !isNaN(numFloat)) {\n            return num;\n          }\n\n          return str;\n        }\n        /**\n         * Return a human readable document size\n         * For example formatSize(7570718) outputs '7.2 MiB'\n         * @param {number} size\n         * @return {string} Returns a human readable size\n         */\n\n\n        function formatSize(size) {\n          if (size < 900) {\n            return size.toFixed() + ' B';\n          }\n\n          var KiB = size / 1024;\n\n          if (KiB < 900) {\n            return KiB.toFixed(1) + ' KiB';\n          }\n\n          var MiB = KiB / 1024;\n\n          if (MiB < 900) {\n            return MiB.toFixed(1) + ' MiB';\n          }\n\n          var GiB = MiB / 1024;\n\n          if (GiB < 900) {\n            return GiB.toFixed(1) + ' GiB';\n          }\n\n          var TiB = GiB / 1024;\n          return TiB.toFixed(1) + ' TiB';\n        }\n        /**\n         * Limit text to a maximum number of characters\n         * @param {string} text\n         * @param {number} maxCharacterCount\n         * @return {string} Returns the limited text,\n         *                  ending with '...' if the max was exceeded\n         */\n\n\n        function limitCharacters(text, maxCharacterCount) {\n          if (text.length <= maxCharacterCount) {\n            return text;\n          }\n\n          return text.slice(0, maxCharacterCount) + '...';\n        }\n        /**\n         * Test whether a value is an Object\n         * @param {*} value\n         * @return {boolean}\n         */\n\n\n        function isObject(value) {\n          return _typeof(value) === 'object' && value !== null && !Array.isArray(value);\n        }\n        /**\n         * Helper function to test whether an array contains an item\n         * @param {Array} array\n         * @param {*} item\n         * @return {boolean} Returns true if `item` is in `array`, returns false otherwise.\n         */\n\n\n        function contains(array, item) {\n          return array.indexOf(item) !== -1;\n        }\n\n        function hasOwnProperty(object, key) {\n          return Object.prototype.hasOwnProperty.call(object, key);\n        }\n        /***/\n\n      },\n      /* 1 */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        /* harmony export (binding) */\n        __webpack_require__.d(__webpack_exports__, \"a\", function () {\n          return setLanguage;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"b\", function () {\n          return setLanguages;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"c\", function () {\n          return translate;\n        });\n        /* harmony import */\n\n\n        var _polyfills__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);\n        /* harmony import */\n\n\n        var _polyfills__WEBPACK_IMPORTED_MODULE_0___default =\n        /*#__PURE__*/\n        __webpack_require__.n(_polyfills__WEBPACK_IMPORTED_MODULE_0__);\n        /* eslint-disable no-template-curly-in-string */\n\n\n        var _locales = ['en', 'pt-BR', 'zh-CN', 'tr'];\n        var _defs = {\n          en: {\n            array: 'Array',\n            auto: 'Auto',\n            appendText: 'Append',\n            appendTitle: 'Append a new field with type \\'auto\\' after this field (Ctrl+Shift+Ins)',\n            appendSubmenuTitle: 'Select the type of the field to be appended',\n            appendTitleAuto: 'Append a new field with type \\'auto\\' (Ctrl+Shift+Ins)',\n            ascending: 'Ascending',\n            ascendingTitle: 'Sort the childs of this ${type} in ascending order',\n            actionsMenu: 'Click to open the actions menu (Ctrl+M)',\n            collapseAll: 'Collapse all fields',\n            descending: 'Descending',\n            descendingTitle: 'Sort the childs of this ${type} in descending order',\n            drag: 'Drag to move this field (Alt+Shift+Arrows)',\n            duplicateKey: 'duplicate key',\n            duplicateText: 'Duplicate',\n            duplicateTitle: 'Duplicate selected fields (Ctrl+D)',\n            duplicateField: 'Duplicate this field (Ctrl+D)',\n            duplicateFieldError: 'Duplicate field name',\n            cannotParseFieldError: 'Cannot parse field into JSON',\n            cannotParseValueError: 'Cannot parse value into JSON',\n            empty: 'empty',\n            expandAll: 'Expand all fields',\n            expandTitle: 'Click to expand/collapse this field (Ctrl+E). \\n' + 'Ctrl+Click to expand/collapse including all childs.',\n            insert: 'Insert',\n            insertTitle: 'Insert a new field with type \\'auto\\' before this field (Ctrl+Ins)',\n            insertSub: 'Select the type of the field to be inserted',\n            object: 'Object',\n            ok: 'Ok',\n            redo: 'Redo (Ctrl+Shift+Z)',\n            removeText: 'Remove',\n            removeTitle: 'Remove selected fields (Ctrl+Del)',\n            removeField: 'Remove this field (Ctrl+Del)',\n            selectNode: 'Select a node...',\n            showAll: 'show all',\n            showMore: 'show more',\n            showMoreStatus: 'displaying ${visibleChilds} of ${totalChilds} items.',\n            sort: 'Sort',\n            sortTitle: 'Sort the childs of this ${type}',\n            sortTitleShort: 'Sort contents',\n            sortFieldLabel: 'Field:',\n            sortDirectionLabel: 'Direction:',\n            sortFieldTitle: 'Select the nested field by which to sort the array or object',\n            sortAscending: 'Ascending',\n            sortAscendingTitle: 'Sort the selected field in ascending order',\n            sortDescending: 'Descending',\n            sortDescendingTitle: 'Sort the selected field in descending order',\n            string: 'String',\n            transform: 'Transform',\n            transformTitle: 'Filter, sort, or transform the childs of this ${type}',\n            transformTitleShort: 'Filter, sort, or transform contents',\n            extract: 'Extract',\n            extractTitle: 'Extract this ${type}',\n            transformQueryTitle: 'Enter a JMESPath query',\n            transformWizardLabel: 'Wizard',\n            transformWizardFilter: 'Filter',\n            transformWizardSortBy: 'Sort by',\n            transformWizardSelectFields: 'Select fields',\n            transformQueryLabel: 'Query',\n            transformPreviewLabel: 'Preview',\n            type: 'Type',\n            typeTitle: 'Change the type of this field',\n            openUrl: 'Ctrl+Click or Ctrl+Enter to open url in new window',\n            undo: 'Undo last action (Ctrl+Z)',\n            validationCannotMove: 'Cannot move a field into a child of itself',\n            autoType: 'Field type \"auto\". ' + 'The field type is automatically determined from the value ' + 'and can be a string, number, boolean, or null.',\n            objectType: 'Field type \"object\". ' + 'An object contains an unordered set of key/value pairs.',\n            arrayType: 'Field type \"array\". ' + 'An array contains an ordered collection of values.',\n            stringType: 'Field type \"string\". ' + 'Field type is not determined from the value, ' + 'but always returned as string.',\n            modeCodeText: 'Code',\n            modeCodeTitle: 'Switch to code highlighter',\n            modeFormText: 'Form',\n            modeFormTitle: 'Switch to form editor',\n            modeTextText: 'Text',\n            modeTextTitle: 'Switch to plain text editor',\n            modeTreeText: 'Tree',\n            modeTreeTitle: 'Switch to tree editor',\n            modeViewText: 'View',\n            modeViewTitle: 'Switch to tree view',\n            modePreviewText: 'Preview',\n            modePreviewTitle: 'Switch to preview mode',\n            examples: 'Examples',\n            \"default\": 'Default'\n          },\n          'zh-CN': {\n            array: '',\n            auto: '',\n            appendText: '',\n            appendTitle: 'auto (Ctrl+Shift+Ins)',\n            appendSubmenuTitle: '',\n            appendTitleAuto: 'auto (Ctrl+Shift+Ins)',\n            ascending: '',\n            ascendingTitle: '${type}',\n            actionsMenu: '(Ctrl+M)',\n            collapseAll: '',\n            descending: '',\n            descendingTitle: '${type}',\n            drag: '(Alt+Shift+Arrows)',\n            duplicateKey: '',\n            duplicateText: '',\n            duplicateTitle: '(Ctrl+D)',\n            duplicateField: '(Ctrl+D)',\n            duplicateFieldError: '',\n            cannotParseFieldError: 'JSON',\n            cannotParseValueError: 'JSON',\n            empty: '',\n            expandAll: '',\n            expandTitle: ' / (Ctrl+E). \\n' + 'Ctrl+Click / .',\n            insert: '',\n            insertTitle: 'auto (Ctrl+Ins)',\n            insertSub: '',\n            object: '',\n            ok: 'Ok',\n            redo: ' (Ctrl+Shift+Z)',\n            removeText: '',\n            removeTitle: ' (Ctrl+Del)',\n            removeField: ' (Ctrl+Del)',\n            selectNode: '...',\n            showAll: '',\n            showMore: '',\n            showMoreStatus: '${totalChilds}${visibleChilds}.',\n            sort: '',\n            sortTitle: '${type}',\n            sortTitleShort: '',\n            sortFieldLabel: '',\n            sortDirectionLabel: '',\n            sortFieldTitle: '',\n            sortAscending: '',\n            sortAscendingTitle: '',\n            sortDescending: '',\n            sortDescendingTitle: '',\n            string: '',\n            transform: '',\n            transformTitle: '${type}',\n            transformTitleShort: '',\n            extract: '',\n            extractTitle: ' ${type}',\n            transformQueryTitle: 'JMESPath',\n            transformWizardLabel: '',\n            transformWizardFilter: '',\n            transformWizardSortBy: '',\n            transformWizardSelectFields: '',\n            transformQueryLabel: '',\n            transformPreviewLabel: '',\n            type: '',\n            typeTitle: '',\n            openUrl: 'Ctrl+Click  Ctrl+Enter ',\n            undo: ' (Ctrl+Z)',\n            validationCannotMove: '',\n            autoType: ' \"auto\". ' + ' ' + ' stringnumberboolean null.',\n            objectType: ' \"object\". ' + '/.',\n            arrayType: ' \"array\". ' + '.',\n            stringType: ' \"string\". ' + '' + '.',\n            modeCodeText: '',\n            modeCodeTitle: '',\n            modeFormText: '',\n            modeFormTitle: '',\n            modeTextText: '',\n            modeTextTitle: '',\n            modeTreeText: '',\n            modeTreeTitle: '',\n            modeViewText: '',\n            modeViewTitle: '',\n            modePreviewText: '',\n            modePreviewTitle: '',\n            examples: '',\n            \"default\": ''\n          },\n          'pt-BR': {\n            array: 'Lista',\n            auto: 'Automatico',\n            appendText: 'Adicionar',\n            appendTitle: 'Adicionar novo campo com tipo \\'auto\\' depois deste campo (Ctrl+Shift+Ins)',\n            appendSubmenuTitle: 'Selecione o tipo do campo a ser adicionado',\n            appendTitleAuto: 'Adicionar novo campo com tipo \\'auto\\' (Ctrl+Shift+Ins)',\n            ascending: 'Ascendente',\n            ascendingTitle: 'Organizar filhor do tipo ${type} em crescente',\n            actionsMenu: 'Clique para abrir o menu de aes (Ctrl+M)',\n            collapseAll: 'Fechar todos campos',\n            descending: 'Descendente',\n            descendingTitle: 'Organizar o filhos do tipo ${type} em decrescente',\n            duplicateKey: 'chave duplicada',\n            drag: 'Arraste para mover este campo (Alt+Shift+Arrows)',\n            duplicateText: 'Duplicar',\n            duplicateTitle: 'Duplicar campos selecionados (Ctrl+D)',\n            duplicateField: 'Duplicar este campo (Ctrl+D)',\n            duplicateFieldError: 'Nome do campo duplicado',\n            cannotParseFieldError: 'No  possvel analisar o campo no JSON',\n            cannotParseValueError: 'No  possvel analisar o valor em JSON',\n            empty: 'vazio',\n            expandAll: 'Expandir todos campos',\n            expandTitle: 'Clique para expandir/encolher este campo (Ctrl+E). \\n' + 'Ctrl+Click para expandir/encolher incluindo todos os filhos.',\n            insert: 'Inserir',\n            insertTitle: 'Inserir um novo campo do tipo \\'auto\\' antes deste campo (Ctrl+Ins)',\n            insertSub: 'Selecionar o tipo de campo a ser inserido',\n            object: 'Objeto',\n            ok: 'Ok',\n            redo: 'Refazer (Ctrl+Shift+Z)',\n            removeText: 'Remover',\n            removeTitle: 'Remover campos selecionados (Ctrl+Del)',\n            removeField: 'Remover este campo (Ctrl+Del)',\n            // TODO: correctly translate\n            selectNode: 'Selecione um ndulo...',\n            showAll: 'mostrar todos',\n            showMore: 'mostrar mais',\n            // TODO: correctly translate\n            showMoreStatus: 'exibindo ${visibleChilds} de ${totalChilds} itens.',\n            sort: 'Organizar',\n            sortTitle: 'Organizar os filhos deste ${type}',\n            // TODO: correctly translate\n            sortTitleShort: 'Organizar os filhos',\n            sortFieldLabel: 'Campo:',\n            sortDirectionLabel: 'Direo:',\n            sortFieldTitle: 'Selecione um campo filho pelo qual ordenar o array ou objeto',\n            sortAscending: 'Ascendente',\n            sortAscendingTitle: 'Ordenar o campo selecionado por ordem ascendente',\n            sortDescending: 'Descendente',\n            sortDescendingTitle: 'Ordenar o campo selecionado por ordem descendente',\n            string: 'Texto',\n            // TODO: correctly translate\n            transform: 'Transformar',\n            transformTitle: 'Filtrar, ordenar ou transformar os filhos deste ${type}',\n            transformTitleShort: 'Filtrar, ordenar ou transformar contedos',\n            // TODO: correctly translate\n            transformQueryTitle: 'Insira uma expresso JMESPath',\n            // TODO: correctly translate\n            transformWizardLabel: 'Assistente',\n            transformWizardFilter: 'Filtro',\n            transformWizardSortBy: 'Ordenar por',\n            transformWizardSelectFields: 'Selecionar campos',\n            transformQueryLabel: 'Expresso',\n            transformPreviewLabel: 'Visualizar',\n            type: 'Tipo',\n            typeTitle: 'Mudar o tipo deste campo',\n            openUrl: 'Ctrl+Click ou Ctrl+Enter para abrir link em nova janela',\n            undo: 'Desfazer ltimo ao (Ctrl+Z)',\n            validationCannotMove: 'No pode mover um campo como filho dele mesmo',\n            autoType: 'Campo do tipo \"auto\". ' + 'O tipo do campo  determinao automaticamente a partir do seu valor ' + 'e pode ser texto, nmero, verdade/falso ou nulo.',\n            objectType: 'Campo do tipo \"objeto\". ' + 'Um objeto contm uma lista de pares com chave e valor.',\n            arrayType: 'Campo do tipo \"lista\". ' + 'Uma lista contem uma coleo de valores ordenados.',\n            stringType: 'Campo do tipo \"string\". ' + 'Campo do tipo nao  determinado atravs do seu valor, ' + 'mas sempre retornara um texto.',\n            examples: 'Exemplos',\n            \"default\": 'Revelia'\n          },\n          tr: {\n            array: 'Dizin',\n            auto: 'Otomatik',\n            appendText: 'Ekle',\n            appendTitle: 'Bu alann altna \\'otomatik\\' tipinde yeni bir alan ekle (Ctrl+Shift+Ins)',\n            appendSubmenuTitle: 'Eklenecek alann tipini se',\n            appendTitleAuto: '\\'Otomatik\\' tipinde yeni bir alan ekle (Ctrl+Shift+Ins)',\n            ascending: 'Artan',\n            ascendingTitle: '${type}\\'n alt tiplerini artan dzende srala',\n            actionsMenu: 'Aksiyon mensn amak iin tklayn (Ctrl+M)',\n            collapseAll: 'Tm alanlar kapat',\n            descending: 'Azalan',\n            descendingTitle: '${type}\\'n alt tiplerini azalan dzende srala',\n            drag: 'Bu alan tamak iin srkleyin (Alt+Shift+Arrows)',\n            duplicateKey: 'Var olan anahtar',\n            duplicateText: 'Aaya kopyala',\n            duplicateTitle: 'Seili alanlardan bir daha olutur (Ctrl+D)',\n            duplicateField: 'Bu alandan bir daha olutur (Ctrl+D)',\n            duplicateFieldError: 'Duplicate field name',\n            cannotParseFieldError: 'Alan JSON\\'a ayrtrlamyor',\n            cannotParseValueError: 'JSON\\'a deer ayrtrlamyor',\n            empty: 'bo',\n            expandAll: 'Tm alanlar a',\n            expandTitle: 'Bu alan amak/kapatmak iin tkla (Ctrl+E). \\n' + 'Alt alanlarda dahil tm alanlar amak iin Ctrl+Click ',\n            insert: 'Ekle',\n            insertTitle: 'Bu alann stne \\'otomatik\\' tipinde yeni bir alan ekle (Ctrl+Ins)',\n            insertSub: 'Araya eklenecek alann tipini se',\n            object: 'Nesne',\n            ok: 'Tamam',\n            redo: 'Yeniden yap (Ctrl+Shift+Z)',\n            removeText: 'Kaldr',\n            removeTitle: 'Seilen alanlar kaldr (Ctrl+Del)',\n            removeField: 'Bu alan kaldr (Ctrl+Del)',\n            selectNode: 'Bir nesne se...',\n            showAll: 'tmn gster',\n            showMore: 'daha fazla gster',\n            showMoreStatus: '${totalChilds} alann ${visibleChilds} alt alanlar gsteriliyor',\n            sort: 'Srala',\n            sortTitle: '${type}\\'n alt alanlarn srala',\n            sortTitleShort: 'erikleri srala',\n            sortFieldLabel: 'Alan:',\n            sortDirectionLabel: 'Yn:',\n            sortFieldTitle: 'Diziyi veya nesneyi sralamak iin i ie gemi alan sein',\n            sortAscending: 'Artan',\n            sortAscendingTitle: 'Seili alan artan dzende srala',\n            sortDescending: 'Azalan',\n            sortDescendingTitle: 'Seili alan azalan dzende srala',\n            string: 'Karakter Dizisi',\n            transform: 'Dntr',\n            transformTitle: '${type}\\'n alt alanlarn filtrele, srala veya dntr',\n            transformTitleShort: 'erikleri filterele, srala veya dntr',\n            transformQueryTitle: 'JMESPath sorgusu gir',\n            transformWizardLabel: 'Sihirbaz',\n            transformWizardFilter: 'Filtre',\n            transformWizardSortBy: 'Srala',\n            transformWizardSelectFields: 'Alanlar se',\n            transformQueryLabel: 'Sorgu',\n            transformPreviewLabel: 'nizleme',\n            type: 'Tip',\n            typeTitle: 'Bu alann tipini deitir',\n            openUrl: 'URL\\'i yeni bir pencerede amak iin Ctrl+Click veya Ctrl+Enter',\n            undo: 'Son deiiklii geri al (Ctrl+Z)',\n            validationCannotMove: 'Alt alan olarak tanamyor',\n            autoType: 'Alan tipi \"otomatik\". ' + 'Alan tr otomatik olarak deerden belirlenir' + 've bir dize, say, boolean veya null olabilir.',\n            objectType: 'Alan tipi \"nesne\". ' + 'Bir nesne, sralanmam bir anahtar / deer ifti kmesi ierir.',\n            arrayType: 'Alan tipi \"dizi\". ' + 'Bir dizi, dzenli deerler koleksiyonu ierir.',\n            stringType: 'Alan tipi \"karakter dizisi\". ' + 'Alan tr deerden belirlenmez,' + 'ancak her zaman karakter dizisi olarak dndrlr.',\n            modeCodeText: 'Kod',\n            modeCodeTitle: 'Kod vurgulaycya ge',\n            modeFormText: 'Form',\n            modeFormTitle: 'Form dzenleyiciye ge',\n            modeTextText: 'Metin',\n            modeTextTitle: 'Dz metin dzenleyiciye ge',\n            modeTreeText: 'Aa',\n            modeTreeTitle: 'Aa dzenleyiciye ge',\n            modeViewText: 'Grnm',\n            modeViewTitle: 'Aa grnmne ge',\n            examples: 'rnekler',\n            \"default\": 'Varsaylan'\n          }\n        };\n        var _defaultLang = 'en';\n        var userLang = typeof navigator !== 'undefined' ? navigator.language || navigator.userLanguage : undefined;\n\n        var _lang = _locales.find(function (l) {\n          return l === userLang;\n        }) || _defaultLang;\n\n        function setLanguage(lang) {\n          if (!lang) {\n            return;\n          }\n\n          var langFound = _locales.find(function (l) {\n            return l === lang;\n          });\n\n          if (langFound) {\n            _lang = langFound;\n          } else {\n            console.error('Language not found');\n          }\n        }\n\n        function setLanguages(languages) {\n          if (!languages) {\n            return;\n          }\n\n          var _loop = function _loop(key) {\n            var langFound = _locales.find(function (l) {\n              return l === key;\n            });\n\n            if (!langFound) {\n              _locales.push(key);\n            }\n\n            _defs[key] = Object.assign({}, _defs[_defaultLang], _defs[key], languages[key]);\n          };\n\n          for (var key in languages) {\n            _loop(key);\n          }\n        }\n\n        function translate(key, data, lang) {\n          if (!lang) {\n            lang = _lang;\n          }\n\n          var text = _defs[lang][key];\n\n          if (data) {\n            for (key in data) {\n              text = text.replace('${' + key + '}', data[key]);\n            }\n          }\n\n          return text || key;\n        }\n        /***/\n\n      },\n      /* 2 */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        /* harmony export (binding) */\n        __webpack_require__.d(__webpack_exports__, \"a\", function () {\n          return DEFAULT_MODAL_ANCHOR;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"d\", function () {\n          return SIZE_LARGE;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"b\", function () {\n          return MAX_PREVIEW_CHARACTERS;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"c\", function () {\n          return PREVIEW_HISTORY_LIMIT;\n        });\n\n        var DEFAULT_MODAL_ANCHOR = document.body;\n        var SIZE_LARGE = 10 * 1024 * 1024; // 10 MB\n\n        var MAX_PREVIEW_CHARACTERS = 20000;\n        var PREVIEW_HISTORY_LIMIT = 2 * 1024 * 1024 * 1024; // 2 GB\n\n        /***/\n      },\n      /* 3 */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        /* harmony export (binding) */\n        __webpack_require__.d(__webpack_exports__, \"a\", function () {\n          return ContextMenu;\n        });\n        /* harmony import */\n\n\n        var _createAbsoluteAnchor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);\n        /* harmony import */\n\n\n        var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);\n        /* harmony import */\n\n\n        var _i18n__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1);\n\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        function _defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        function _createClass(Constructor, protoProps, staticProps) {\n          if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) _defineProperties(Constructor, staticProps);\n          return Constructor;\n        }\n        /**\n         * A context menu\n         * @param {Object[]} items    Array containing the menu structure\n         *                            TODO: describe structure\n         * @param {Object} [options]  Object with options. Available options:\n         *                            {function} close    Callback called when the\n         *                                                context menu is being closed.\n         * @constructor\n         */\n\n\n        var ContextMenu =\n        /*#__PURE__*/\n        function () {\n          function ContextMenu(items, options) {\n            _classCallCheck(this, ContextMenu);\n\n            this.dom = {};\n            var me = this;\n            var dom = this.dom;\n            this.anchor = undefined;\n            this.items = items;\n            this.eventListeners = {};\n            this.selection = undefined; // holds the selection before the menu was opened\n\n            this.onClose = options ? options.close : undefined; // create root element\n\n            var root = document.createElement('div');\n            root.className = 'jsoneditor-contextmenu-root';\n            dom.root = root; // create a container element\n\n            var menu = document.createElement('div');\n            menu.className = 'jsoneditor-contextmenu';\n            dom.menu = menu;\n            root.appendChild(menu); // create a list to hold the menu items\n\n            var list = document.createElement('ul');\n            list.className = 'jsoneditor-menu';\n            menu.appendChild(list);\n            dom.list = list;\n            dom.items = []; // list with all buttons\n            // create a (non-visible) button to set the focus to the menu\n\n            var focusButton = document.createElement('button');\n            focusButton.type = 'button';\n            dom.focusButton = focusButton;\n            var li = document.createElement('li');\n            li.style.overflow = 'hidden';\n            li.style.height = '0';\n            li.appendChild(focusButton);\n            list.appendChild(li);\n\n            function createMenuItems(list, domItems, items) {\n              items.forEach(function (item) {\n                if (item.type === 'separator') {\n                  // create a separator\n                  var separator = document.createElement('div');\n                  separator.className = 'jsoneditor-separator';\n\n                  var _li = document.createElement('li');\n\n                  _li.appendChild(separator);\n\n                  list.appendChild(_li);\n                } else {\n                  var domItem = {}; // create a menu item\n\n                  var _li2 = document.createElement('li');\n\n                  list.appendChild(_li2); // create a button in the menu item\n\n                  var button = document.createElement('button');\n                  button.type = 'button';\n                  button.className = item.className;\n                  domItem.button = button;\n\n                  if (item.title) {\n                    button.title = item.title;\n                  }\n\n                  if (item.click) {\n                    button.onclick = function (event) {\n                      event.preventDefault();\n                      me.hide();\n                      item.click();\n                    };\n                  }\n\n                  _li2.appendChild(button); // create the contents of the button\n\n\n                  if (item.submenu) {\n                    // add the icon to the button\n                    var divIcon = document.createElement('div');\n                    divIcon.className = 'jsoneditor-icon';\n                    button.appendChild(divIcon);\n                    var divText = document.createElement('div');\n                    divText.className = 'jsoneditor-text' + (item.click ? '' : ' jsoneditor-right-margin');\n                    divText.appendChild(document.createTextNode(item.text));\n                    button.appendChild(divText);\n                    var buttonSubmenu;\n\n                    if (item.click) {\n                      // submenu and a button with a click handler\n                      button.className += ' jsoneditor-default';\n                      var buttonExpand = document.createElement('button');\n                      buttonExpand.type = 'button';\n                      domItem.buttonExpand = buttonExpand;\n                      buttonExpand.className = 'jsoneditor-expand';\n                      buttonExpand.innerHTML = '<div class=\"jsoneditor-expand\"></div>';\n\n                      _li2.appendChild(buttonExpand);\n\n                      if (item.submenuTitle) {\n                        buttonExpand.title = item.submenuTitle;\n                      }\n\n                      buttonSubmenu = buttonExpand;\n                    } else {\n                      // submenu and a button without a click handler\n                      var divExpand = document.createElement('div');\n                      divExpand.className = 'jsoneditor-expand';\n                      button.appendChild(divExpand);\n                      buttonSubmenu = button;\n                    } // attach a handler to expand/collapse the submenu\n\n\n                    buttonSubmenu.onclick = function (event) {\n                      event.preventDefault();\n\n                      me._onExpandItem(domItem);\n\n                      buttonSubmenu.focus();\n                    }; // create the submenu\n\n\n                    var domSubItems = [];\n                    domItem.subItems = domSubItems;\n                    var ul = document.createElement('ul');\n                    domItem.ul = ul;\n                    ul.className = 'jsoneditor-menu';\n                    ul.style.height = '0';\n\n                    _li2.appendChild(ul);\n\n                    createMenuItems(ul, domSubItems, item.submenu);\n                  } else {\n                    // no submenu, just a button with clickhandler\n                    button.innerHTML = '<div class=\"jsoneditor-icon\"></div>' + '<div class=\"jsoneditor-text\">' + Object(_i18n__WEBPACK_IMPORTED_MODULE_2__[\n                    /* translate */\n                    \"c\"])(item.text) + '</div>';\n                  }\n\n                  domItems.push(domItem);\n                }\n              });\n            }\n\n            createMenuItems(list, this.dom.items, items); // TODO: when the editor is small, show the submenu on the right instead of inline?\n            // calculate the max height of the menu with one submenu expanded\n\n            this.maxHeight = 0; // height in pixels\n\n            items.forEach(function (item) {\n              var height = (items.length + (item.submenu ? item.submenu.length : 0)) * 24;\n              me.maxHeight = Math.max(me.maxHeight, height);\n            });\n          }\n          /**\n           * Get the currently visible buttons\n           * @return {Array.<HTMLElement>} buttons\n           * @private\n           */\n\n\n          _createClass(ContextMenu, [{\n            key: \"_getVisibleButtons\",\n            value: function _getVisibleButtons() {\n              var buttons = [];\n              var me = this;\n              this.dom.items.forEach(function (item) {\n                buttons.push(item.button);\n\n                if (item.buttonExpand) {\n                  buttons.push(item.buttonExpand);\n                }\n\n                if (item.subItems && item === me.expandedItem) {\n                  item.subItems.forEach(function (subItem) {\n                    buttons.push(subItem.button);\n\n                    if (subItem.buttonExpand) {\n                      buttons.push(subItem.buttonExpand);\n                    } // TODO: change to fully recursive method\n\n                  });\n                }\n              });\n              return buttons;\n            }\n            /**\n             * Attach the menu to an anchor\n             * @param {HTMLElement} anchor    Anchor where the menu will be attached as sibling.\n             * @param {HTMLElement} frame     The root of the JSONEditor window\n             * @param {Boolean=} ignoreParent ignore anchor parent in regard to the calculation of the position, needed when the parent position is absolute\n             */\n\n          }, {\n            key: \"show\",\n            value: function show(anchor, frame, ignoreParent) {\n              this.hide(); // determine whether to display the menu below or above the anchor\n\n              var showBelow = true;\n              var parent = anchor.parentNode;\n              var anchorRect = anchor.getBoundingClientRect();\n              var parentRect = parent.getBoundingClientRect();\n              var frameRect = frame.getBoundingClientRect();\n              var me = this;\n              this.dom.absoluteAnchor = Object(_createAbsoluteAnchor__WEBPACK_IMPORTED_MODULE_0__[\n              /* createAbsoluteAnchor */\n              \"a\"])(anchor, frame, function () {\n                me.hide();\n              });\n              if (anchorRect.bottom + this.maxHeight < frameRect.bottom) ;else if (anchorRect.top - this.maxHeight > frameRect.top) {\n                // fits above -> show above\n                showBelow = false;\n              }\n              var topGap = ignoreParent ? 0 : anchorRect.top - parentRect.top; // position the menu\n\n              if (showBelow) {\n                // display the menu below the anchor\n                var anchorHeight = anchor.offsetHeight;\n                this.dom.menu.style.left = '0';\n                this.dom.menu.style.top = topGap + anchorHeight + 'px';\n                this.dom.menu.style.bottom = '';\n              } else {\n                // display the menu above the anchor\n                this.dom.menu.style.left = '0';\n                this.dom.menu.style.top = '';\n                this.dom.menu.style.bottom = '0px';\n              } // attach the menu to the temporary, absolute anchor\n              // parent.insertBefore(this.dom.root, anchor);\n\n\n              this.dom.absoluteAnchor.appendChild(this.dom.root); // move focus to the first button in the context menu\n\n              this.selection = Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"getSelection\"])();\n              this.anchor = anchor;\n              setTimeout(function () {\n                me.dom.focusButton.focus();\n              }, 0);\n\n              if (ContextMenu.visibleMenu) {\n                ContextMenu.visibleMenu.hide();\n              }\n\n              ContextMenu.visibleMenu = this;\n            }\n            /**\n             * Hide the context menu if visible\n             */\n\n          }, {\n            key: \"hide\",\n            value: function hide() {\n              // remove temporary absolutely positioned anchor\n              if (this.dom.absoluteAnchor) {\n                this.dom.absoluteAnchor.destroy();\n                delete this.dom.absoluteAnchor;\n              } // remove the menu from the DOM\n\n\n              if (this.dom.root.parentNode) {\n                this.dom.root.parentNode.removeChild(this.dom.root);\n\n                if (this.onClose) {\n                  this.onClose();\n                }\n              }\n\n              if (ContextMenu.visibleMenu === this) {\n                ContextMenu.visibleMenu = undefined;\n              }\n            }\n            /**\n             * Expand a submenu\n             * Any currently expanded submenu will be hided.\n             * @param {Object} domItem\n             * @private\n             */\n\n          }, {\n            key: \"_onExpandItem\",\n            value: function _onExpandItem(domItem) {\n              var me = this;\n              var alreadyVisible = domItem === this.expandedItem; // hide the currently visible submenu\n\n              var expandedItem = this.expandedItem;\n\n              if (expandedItem) {\n                // var ul = expandedItem.ul;\n                expandedItem.ul.style.height = '0';\n                expandedItem.ul.style.padding = '';\n                setTimeout(function () {\n                  if (me.expandedItem !== expandedItem) {\n                    expandedItem.ul.style.display = '';\n                    Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"removeClassName\"])(expandedItem.ul.parentNode, 'jsoneditor-selected');\n                  }\n                }, 300); // timeout duration must match the css transition duration\n\n                this.expandedItem = undefined;\n              }\n\n              if (!alreadyVisible) {\n                var ul = domItem.ul;\n                ul.style.display = 'block'; // eslint-disable-next-line no-unused-expressions\n\n                ul.clientHeight; // force a reflow in Firefox\n\n                setTimeout(function () {\n                  if (me.expandedItem === domItem) {\n                    var childsHeight = 0;\n\n                    for (var i = 0; i < ul.childNodes.length; i++) {\n                      childsHeight += ul.childNodes[i].clientHeight;\n                    }\n\n                    ul.style.height = childsHeight + 'px';\n                    ul.style.padding = '5px 10px';\n                  }\n                }, 0);\n                Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"addClassName\"])(ul.parentNode, 'jsoneditor-selected');\n                this.expandedItem = domItem;\n              }\n            }\n            /**\n             * Handle onkeydown event\n             * @param {Event} event\n             * @private\n             */\n\n          }, {\n            key: \"_onKeyDown\",\n            value: function _onKeyDown(event) {\n              var target = event.target;\n              var keynum = event.which;\n              var handled = false;\n              var buttons, targetIndex, prevButton, nextButton;\n\n              if (keynum === 27) {\n                // ESC\n                // hide the menu on ESC key\n                // restore previous selection and focus\n                if (this.selection) {\n                  Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"setSelection\"])(this.selection);\n                }\n\n                if (this.anchor) {\n                  this.anchor.focus();\n                }\n\n                this.hide();\n                handled = true;\n              } else if (keynum === 9) {\n                // Tab\n                if (!event.shiftKey) {\n                  // Tab\n                  buttons = this._getVisibleButtons();\n                  targetIndex = buttons.indexOf(target);\n\n                  if (targetIndex === buttons.length - 1) {\n                    // move to first button\n                    buttons[0].focus();\n                    handled = true;\n                  }\n                } else {\n                  // Shift+Tab\n                  buttons = this._getVisibleButtons();\n                  targetIndex = buttons.indexOf(target);\n\n                  if (targetIndex === 0) {\n                    // move to last button\n                    buttons[buttons.length - 1].focus();\n                    handled = true;\n                  }\n                }\n              } else if (keynum === 37) {\n                // Arrow Left\n                if (target.className === 'jsoneditor-expand') {\n                  buttons = this._getVisibleButtons();\n                  targetIndex = buttons.indexOf(target);\n                  prevButton = buttons[targetIndex - 1];\n\n                  if (prevButton) {\n                    prevButton.focus();\n                  }\n                }\n\n                handled = true;\n              } else if (keynum === 38) {\n                // Arrow Up\n                buttons = this._getVisibleButtons();\n                targetIndex = buttons.indexOf(target);\n                prevButton = buttons[targetIndex - 1];\n\n                if (prevButton && prevButton.className === 'jsoneditor-expand') {\n                  // skip expand button\n                  prevButton = buttons[targetIndex - 2];\n                }\n\n                if (!prevButton) {\n                  // move to last button\n                  prevButton = buttons[buttons.length - 1];\n                }\n\n                if (prevButton) {\n                  prevButton.focus();\n                }\n\n                handled = true;\n              } else if (keynum === 39) {\n                // Arrow Right\n                buttons = this._getVisibleButtons();\n                targetIndex = buttons.indexOf(target);\n                nextButton = buttons[targetIndex + 1];\n\n                if (nextButton && nextButton.className === 'jsoneditor-expand') {\n                  nextButton.focus();\n                }\n\n                handled = true;\n              } else if (keynum === 40) {\n                // Arrow Down\n                buttons = this._getVisibleButtons();\n                targetIndex = buttons.indexOf(target);\n                nextButton = buttons[targetIndex + 1];\n\n                if (nextButton && nextButton.className === 'jsoneditor-expand') {\n                  // skip expand button\n                  nextButton = buttons[targetIndex + 2];\n                }\n\n                if (!nextButton) {\n                  // move to first button\n                  nextButton = buttons[0];\n                }\n\n                if (nextButton) {\n                  nextButton.focus();\n                  handled = true;\n                }\n\n                handled = true;\n              } // TODO: arrow left and right\n\n\n              if (handled) {\n                event.stopPropagation();\n                event.preventDefault();\n              }\n            }\n          }]);\n\n          return ContextMenu;\n        }(); // currently displayed context menu, a singleton. We may only have one visible context menu\n\n\n        ContextMenu.visibleMenu = undefined;\n        /***/\n      },\n      /* 4 */\n\n      /***/\n      function (module, exports, __webpack_require__) {\n        (function (exports) {\n          function isArray(obj) {\n            if (obj !== null) {\n              return Object.prototype.toString.call(obj) === \"[object Array]\";\n            } else {\n              return false;\n            }\n          }\n\n          function isObject(obj) {\n            if (obj !== null) {\n              return Object.prototype.toString.call(obj) === \"[object Object]\";\n            } else {\n              return false;\n            }\n          }\n\n          function strictDeepEqual(first, second) {\n            // Check the scalar case first.\n            if (first === second) {\n              return true;\n            } // Check if they are the same type.\n\n\n            var firstType = Object.prototype.toString.call(first);\n\n            if (firstType !== Object.prototype.toString.call(second)) {\n              return false;\n            } // We know that first and second have the same type so we can just check the\n            // first type from now on.\n\n\n            if (isArray(first) === true) {\n              // Short circuit if they're not the same length;\n              if (first.length !== second.length) {\n                return false;\n              }\n\n              for (var i = 0; i < first.length; i++) {\n                if (strictDeepEqual(first[i], second[i]) === false) {\n                  return false;\n                }\n              }\n\n              return true;\n            }\n\n            if (isObject(first) === true) {\n              // An object is equal if it has the same key/value pairs.\n              var keysSeen = {};\n\n              for (var key in first) {\n                if (hasOwnProperty.call(first, key)) {\n                  if (strictDeepEqual(first[key], second[key]) === false) {\n                    return false;\n                  }\n\n                  keysSeen[key] = true;\n                }\n              } // Now check that there aren't any keys in second that weren't\n              // in first.\n\n\n              for (var key2 in second) {\n                if (hasOwnProperty.call(second, key2)) {\n                  if (keysSeen[key2] !== true) {\n                    return false;\n                  }\n                }\n              }\n\n              return true;\n            }\n\n            return false;\n          }\n\n          function isFalse(obj) {\n            // From the spec:\n            // A false value corresponds to the following values:\n            // Empty list\n            // Empty object\n            // Empty string\n            // False boolean\n            // null value\n            // First check the scalar values.\n            if (obj === \"\" || obj === false || obj === null) {\n              return true;\n            } else if (isArray(obj) && obj.length === 0) {\n              // Check for an empty array.\n              return true;\n            } else if (isObject(obj)) {\n              // Check for an empty object.\n              for (var key in obj) {\n                // If there are any keys, then\n                // the object is not empty so the object\n                // is not false.\n                if (obj.hasOwnProperty(key)) {\n                  return false;\n                }\n              }\n\n              return true;\n            } else {\n              return false;\n            }\n          }\n\n          function objValues(obj) {\n            var keys = Object.keys(obj);\n            var values = [];\n\n            for (var i = 0; i < keys.length; i++) {\n              values.push(obj[keys[i]]);\n            }\n\n            return values;\n          }\n\n          var trimLeft;\n\n          if (typeof String.prototype.trimLeft === \"function\") {\n            trimLeft = function (str) {\n              return str.trimLeft();\n            };\n          } else {\n            trimLeft = function (str) {\n              return str.match(/^\\s*(.*)/)[1];\n            };\n          } // Type constants used to define functions.\n\n\n          var TYPE_NUMBER = 0;\n          var TYPE_ANY = 1;\n          var TYPE_STRING = 2;\n          var TYPE_ARRAY = 3;\n          var TYPE_OBJECT = 4;\n          var TYPE_BOOLEAN = 5;\n          var TYPE_EXPREF = 6;\n          var TYPE_NULL = 7;\n          var TYPE_ARRAY_NUMBER = 8;\n          var TYPE_ARRAY_STRING = 9;\n          var TOK_EOF = \"EOF\";\n          var TOK_UNQUOTEDIDENTIFIER = \"UnquotedIdentifier\";\n          var TOK_QUOTEDIDENTIFIER = \"QuotedIdentifier\";\n          var TOK_RBRACKET = \"Rbracket\";\n          var TOK_RPAREN = \"Rparen\";\n          var TOK_COMMA = \"Comma\";\n          var TOK_COLON = \"Colon\";\n          var TOK_RBRACE = \"Rbrace\";\n          var TOK_NUMBER = \"Number\";\n          var TOK_CURRENT = \"Current\";\n          var TOK_EXPREF = \"Expref\";\n          var TOK_PIPE = \"Pipe\";\n          var TOK_OR = \"Or\";\n          var TOK_AND = \"And\";\n          var TOK_EQ = \"EQ\";\n          var TOK_GT = \"GT\";\n          var TOK_LT = \"LT\";\n          var TOK_GTE = \"GTE\";\n          var TOK_LTE = \"LTE\";\n          var TOK_NE = \"NE\";\n          var TOK_FLATTEN = \"Flatten\";\n          var TOK_STAR = \"Star\";\n          var TOK_FILTER = \"Filter\";\n          var TOK_DOT = \"Dot\";\n          var TOK_NOT = \"Not\";\n          var TOK_LBRACE = \"Lbrace\";\n          var TOK_LBRACKET = \"Lbracket\";\n          var TOK_LPAREN = \"Lparen\";\n          var TOK_LITERAL = \"Literal\"; // The \"&\", \"[\", \"<\", \">\" tokens\n          // are not in basicToken because\n          // there are two token variants\n          // (\"&&\", \"[?\", \"<=\", \">=\").  This is specially handled\n          // below.\n\n          var basicTokens = {\n            \".\": TOK_DOT,\n            \"*\": TOK_STAR,\n            \",\": TOK_COMMA,\n            \":\": TOK_COLON,\n            \"{\": TOK_LBRACE,\n            \"}\": TOK_RBRACE,\n            \"]\": TOK_RBRACKET,\n            \"(\": TOK_LPAREN,\n            \")\": TOK_RPAREN,\n            \"@\": TOK_CURRENT\n          };\n          var operatorStartToken = {\n            \"<\": true,\n            \">\": true,\n            \"=\": true,\n            \"!\": true\n          };\n          var skipChars = {\n            \" \": true,\n            \"\\t\": true,\n            \"\\n\": true\n          };\n\n          function isAlpha(ch) {\n            return ch >= \"a\" && ch <= \"z\" || ch >= \"A\" && ch <= \"Z\" || ch === \"_\";\n          }\n\n          function isNum(ch) {\n            return ch >= \"0\" && ch <= \"9\" || ch === \"-\";\n          }\n\n          function isAlphaNum(ch) {\n            return ch >= \"a\" && ch <= \"z\" || ch >= \"A\" && ch <= \"Z\" || ch >= \"0\" && ch <= \"9\" || ch === \"_\";\n          }\n\n          function Lexer() {}\n\n          Lexer.prototype = {\n            tokenize: function (stream) {\n              var tokens = [];\n              this._current = 0;\n              var start;\n              var identifier;\n              var token;\n\n              while (this._current < stream.length) {\n                if (isAlpha(stream[this._current])) {\n                  start = this._current;\n                  identifier = this._consumeUnquotedIdentifier(stream);\n                  tokens.push({\n                    type: TOK_UNQUOTEDIDENTIFIER,\n                    value: identifier,\n                    start: start\n                  });\n                } else if (basicTokens[stream[this._current]] !== undefined) {\n                  tokens.push({\n                    type: basicTokens[stream[this._current]],\n                    value: stream[this._current],\n                    start: this._current\n                  });\n                  this._current++;\n                } else if (isNum(stream[this._current])) {\n                  token = this._consumeNumber(stream);\n                  tokens.push(token);\n                } else if (stream[this._current] === \"[\") {\n                  // No need to increment this._current.  This happens\n                  // in _consumeLBracket\n                  token = this._consumeLBracket(stream);\n                  tokens.push(token);\n                } else if (stream[this._current] === \"\\\"\") {\n                  start = this._current;\n                  identifier = this._consumeQuotedIdentifier(stream);\n                  tokens.push({\n                    type: TOK_QUOTEDIDENTIFIER,\n                    value: identifier,\n                    start: start\n                  });\n                } else if (stream[this._current] === \"'\") {\n                  start = this._current;\n                  identifier = this._consumeRawStringLiteral(stream);\n                  tokens.push({\n                    type: TOK_LITERAL,\n                    value: identifier,\n                    start: start\n                  });\n                } else if (stream[this._current] === \"`\") {\n                  start = this._current;\n\n                  var literal = this._consumeLiteral(stream);\n\n                  tokens.push({\n                    type: TOK_LITERAL,\n                    value: literal,\n                    start: start\n                  });\n                } else if (operatorStartToken[stream[this._current]] !== undefined) {\n                  tokens.push(this._consumeOperator(stream));\n                } else if (skipChars[stream[this._current]] !== undefined) {\n                  // Ignore whitespace.\n                  this._current++;\n                } else if (stream[this._current] === \"&\") {\n                  start = this._current;\n                  this._current++;\n\n                  if (stream[this._current] === \"&\") {\n                    this._current++;\n                    tokens.push({\n                      type: TOK_AND,\n                      value: \"&&\",\n                      start: start\n                    });\n                  } else {\n                    tokens.push({\n                      type: TOK_EXPREF,\n                      value: \"&\",\n                      start: start\n                    });\n                  }\n                } else if (stream[this._current] === \"|\") {\n                  start = this._current;\n                  this._current++;\n\n                  if (stream[this._current] === \"|\") {\n                    this._current++;\n                    tokens.push({\n                      type: TOK_OR,\n                      value: \"||\",\n                      start: start\n                    });\n                  } else {\n                    tokens.push({\n                      type: TOK_PIPE,\n                      value: \"|\",\n                      start: start\n                    });\n                  }\n                } else {\n                  var error = new Error(\"Unknown character:\" + stream[this._current]);\n                  error.name = \"LexerError\";\n                  throw error;\n                }\n              }\n\n              return tokens;\n            },\n            _consumeUnquotedIdentifier: function (stream) {\n              var start = this._current;\n              this._current++;\n\n              while (this._current < stream.length && isAlphaNum(stream[this._current])) {\n                this._current++;\n              }\n\n              return stream.slice(start, this._current);\n            },\n            _consumeQuotedIdentifier: function (stream) {\n              var start = this._current;\n              this._current++;\n              var maxLength = stream.length;\n\n              while (stream[this._current] !== \"\\\"\" && this._current < maxLength) {\n                // You can escape a double quote and you can escape an escape.\n                var current = this._current;\n\n                if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" || stream[current + 1] === \"\\\"\")) {\n                  current += 2;\n                } else {\n                  current++;\n                }\n\n                this._current = current;\n              }\n\n              this._current++;\n              return JSON.parse(stream.slice(start, this._current));\n            },\n            _consumeRawStringLiteral: function (stream) {\n              var start = this._current;\n              this._current++;\n              var maxLength = stream.length;\n\n              while (stream[this._current] !== \"'\" && this._current < maxLength) {\n                // You can escape a single quote and you can escape an escape.\n                var current = this._current;\n\n                if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" || stream[current + 1] === \"'\")) {\n                  current += 2;\n                } else {\n                  current++;\n                }\n\n                this._current = current;\n              }\n\n              this._current++;\n              var literal = stream.slice(start + 1, this._current - 1);\n              return literal.replace(\"\\\\'\", \"'\");\n            },\n            _consumeNumber: function (stream) {\n              var start = this._current;\n              this._current++;\n              var maxLength = stream.length;\n\n              while (isNum(stream[this._current]) && this._current < maxLength) {\n                this._current++;\n              }\n\n              var value = parseInt(stream.slice(start, this._current));\n              return {\n                type: TOK_NUMBER,\n                value: value,\n                start: start\n              };\n            },\n            _consumeLBracket: function (stream) {\n              var start = this._current;\n              this._current++;\n\n              if (stream[this._current] === \"?\") {\n                this._current++;\n                return {\n                  type: TOK_FILTER,\n                  value: \"[?\",\n                  start: start\n                };\n              } else if (stream[this._current] === \"]\") {\n                this._current++;\n                return {\n                  type: TOK_FLATTEN,\n                  value: \"[]\",\n                  start: start\n                };\n              } else {\n                return {\n                  type: TOK_LBRACKET,\n                  value: \"[\",\n                  start: start\n                };\n              }\n            },\n            _consumeOperator: function (stream) {\n              var start = this._current;\n              var startingChar = stream[start];\n              this._current++;\n\n              if (startingChar === \"!\") {\n                if (stream[this._current] === \"=\") {\n                  this._current++;\n                  return {\n                    type: TOK_NE,\n                    value: \"!=\",\n                    start: start\n                  };\n                } else {\n                  return {\n                    type: TOK_NOT,\n                    value: \"!\",\n                    start: start\n                  };\n                }\n              } else if (startingChar === \"<\") {\n                if (stream[this._current] === \"=\") {\n                  this._current++;\n                  return {\n                    type: TOK_LTE,\n                    value: \"<=\",\n                    start: start\n                  };\n                } else {\n                  return {\n                    type: TOK_LT,\n                    value: \"<\",\n                    start: start\n                  };\n                }\n              } else if (startingChar === \">\") {\n                if (stream[this._current] === \"=\") {\n                  this._current++;\n                  return {\n                    type: TOK_GTE,\n                    value: \">=\",\n                    start: start\n                  };\n                } else {\n                  return {\n                    type: TOK_GT,\n                    value: \">\",\n                    start: start\n                  };\n                }\n              } else if (startingChar === \"=\") {\n                if (stream[this._current] === \"=\") {\n                  this._current++;\n                  return {\n                    type: TOK_EQ,\n                    value: \"==\",\n                    start: start\n                  };\n                }\n              }\n            },\n            _consumeLiteral: function (stream) {\n              this._current++;\n              var start = this._current;\n              var maxLength = stream.length;\n              var literal;\n\n              while (stream[this._current] !== \"`\" && this._current < maxLength) {\n                // You can escape a literal char or you can escape the escape.\n                var current = this._current;\n\n                if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" || stream[current + 1] === \"`\")) {\n                  current += 2;\n                } else {\n                  current++;\n                }\n\n                this._current = current;\n              }\n\n              var literalString = trimLeft(stream.slice(start, this._current));\n              literalString = literalString.replace(\"\\\\`\", \"`\");\n\n              if (this._looksLikeJSON(literalString)) {\n                literal = JSON.parse(literalString);\n              } else {\n                // Try to JSON parse it as \"<literal>\"\n                literal = JSON.parse(\"\\\"\" + literalString + \"\\\"\");\n              } // +1 gets us to the ending \"`\", +1 to move on to the next char.\n\n\n              this._current++;\n              return literal;\n            },\n            _looksLikeJSON: function (literalString) {\n              var startingChars = \"[{\\\"\";\n              var jsonLiterals = [\"true\", \"false\", \"null\"];\n              var numberLooking = \"-0123456789\";\n\n              if (literalString === \"\") {\n                return false;\n              } else if (startingChars.indexOf(literalString[0]) >= 0) {\n                return true;\n              } else if (jsonLiterals.indexOf(literalString) >= 0) {\n                return true;\n              } else if (numberLooking.indexOf(literalString[0]) >= 0) {\n                try {\n                  JSON.parse(literalString);\n                  return true;\n                } catch (ex) {\n                  return false;\n                }\n              } else {\n                return false;\n              }\n            }\n          };\n          var bindingPower = {};\n          bindingPower[TOK_EOF] = 0;\n          bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;\n          bindingPower[TOK_QUOTEDIDENTIFIER] = 0;\n          bindingPower[TOK_RBRACKET] = 0;\n          bindingPower[TOK_RPAREN] = 0;\n          bindingPower[TOK_COMMA] = 0;\n          bindingPower[TOK_RBRACE] = 0;\n          bindingPower[TOK_NUMBER] = 0;\n          bindingPower[TOK_CURRENT] = 0;\n          bindingPower[TOK_EXPREF] = 0;\n          bindingPower[TOK_PIPE] = 1;\n          bindingPower[TOK_OR] = 2;\n          bindingPower[TOK_AND] = 3;\n          bindingPower[TOK_EQ] = 5;\n          bindingPower[TOK_GT] = 5;\n          bindingPower[TOK_LT] = 5;\n          bindingPower[TOK_GTE] = 5;\n          bindingPower[TOK_LTE] = 5;\n          bindingPower[TOK_NE] = 5;\n          bindingPower[TOK_FLATTEN] = 9;\n          bindingPower[TOK_STAR] = 20;\n          bindingPower[TOK_FILTER] = 21;\n          bindingPower[TOK_DOT] = 40;\n          bindingPower[TOK_NOT] = 45;\n          bindingPower[TOK_LBRACE] = 50;\n          bindingPower[TOK_LBRACKET] = 55;\n          bindingPower[TOK_LPAREN] = 60;\n\n          function Parser() {}\n\n          Parser.prototype = {\n            parse: function (expression) {\n              this._loadTokens(expression);\n\n              this.index = 0;\n              var ast = this.expression(0);\n\n              if (this._lookahead(0) !== TOK_EOF) {\n                var t = this._lookaheadToken(0);\n\n                var error = new Error(\"Unexpected token type: \" + t.type + \", value: \" + t.value);\n                error.name = \"ParserError\";\n                throw error;\n              }\n\n              return ast;\n            },\n            _loadTokens: function (expression) {\n              var lexer = new Lexer();\n              var tokens = lexer.tokenize(expression);\n              tokens.push({\n                type: TOK_EOF,\n                value: \"\",\n                start: expression.length\n              });\n              this.tokens = tokens;\n            },\n            expression: function (rbp) {\n              var leftToken = this._lookaheadToken(0);\n\n              this._advance();\n\n              var left = this.nud(leftToken);\n\n              var currentToken = this._lookahead(0);\n\n              while (rbp < bindingPower[currentToken]) {\n                this._advance();\n\n                left = this.led(currentToken, left);\n                currentToken = this._lookahead(0);\n              }\n\n              return left;\n            },\n            _lookahead: function (number) {\n              return this.tokens[this.index + number].type;\n            },\n            _lookaheadToken: function (number) {\n              return this.tokens[this.index + number];\n            },\n            _advance: function () {\n              this.index++;\n            },\n            nud: function (token) {\n              var left;\n              var right;\n              var expression;\n\n              switch (token.type) {\n                case TOK_LITERAL:\n                  return {\n                    type: \"Literal\",\n                    value: token.value\n                  };\n\n                case TOK_UNQUOTEDIDENTIFIER:\n                  return {\n                    type: \"Field\",\n                    name: token.value\n                  };\n\n                case TOK_QUOTEDIDENTIFIER:\n                  var node = {\n                    type: \"Field\",\n                    name: token.value\n                  };\n\n                  if (this._lookahead(0) === TOK_LPAREN) {\n                    throw new Error(\"Quoted identifier not allowed for function names.\");\n                  } else {\n                    return node;\n                  }\n\n                  break;\n\n                case TOK_NOT:\n                  right = this.expression(bindingPower.Not);\n                  return {\n                    type: \"NotExpression\",\n                    children: [right]\n                  };\n\n                case TOK_STAR:\n                  left = {\n                    type: \"Identity\"\n                  };\n                  right = null;\n\n                  if (this._lookahead(0) === TOK_RBRACKET) {\n                    // This can happen in a multiselect,\n                    // [a, b, *]\n                    right = {\n                      type: \"Identity\"\n                    };\n                  } else {\n                    right = this._parseProjectionRHS(bindingPower.Star);\n                  }\n\n                  return {\n                    type: \"ValueProjection\",\n                    children: [left, right]\n                  };\n\n                case TOK_FILTER:\n                  return this.led(token.type, {\n                    type: \"Identity\"\n                  });\n\n                case TOK_LBRACE:\n                  return this._parseMultiselectHash();\n\n                case TOK_FLATTEN:\n                  left = {\n                    type: TOK_FLATTEN,\n                    children: [{\n                      type: \"Identity\"\n                    }]\n                  };\n                  right = this._parseProjectionRHS(bindingPower.Flatten);\n                  return {\n                    type: \"Projection\",\n                    children: [left, right]\n                  };\n\n                case TOK_LBRACKET:\n                  if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {\n                    right = this._parseIndexExpression();\n                    return this._projectIfSlice({\n                      type: \"Identity\"\n                    }, right);\n                  } else if (this._lookahead(0) === TOK_STAR && this._lookahead(1) === TOK_RBRACKET) {\n                    this._advance();\n\n                    this._advance();\n\n                    right = this._parseProjectionRHS(bindingPower.Star);\n                    return {\n                      type: \"Projection\",\n                      children: [{\n                        type: \"Identity\"\n                      }, right]\n                    };\n                  } else {\n                    return this._parseMultiselectList();\n                  }\n\n                  break;\n\n                case TOK_CURRENT:\n                  return {\n                    type: TOK_CURRENT\n                  };\n\n                case TOK_EXPREF:\n                  expression = this.expression(bindingPower.Expref);\n                  return {\n                    type: \"ExpressionReference\",\n                    children: [expression]\n                  };\n\n                case TOK_LPAREN:\n                  var args = [];\n\n                  while (this._lookahead(0) !== TOK_RPAREN) {\n                    if (this._lookahead(0) === TOK_CURRENT) {\n                      expression = {\n                        type: TOK_CURRENT\n                      };\n\n                      this._advance();\n                    } else {\n                      expression = this.expression(0);\n                    }\n\n                    args.push(expression);\n                  }\n\n                  this._match(TOK_RPAREN);\n\n                  return args[0];\n\n                default:\n                  this._errorToken(token);\n\n              }\n            },\n            led: function (tokenName, left) {\n              var right;\n\n              switch (tokenName) {\n                case TOK_DOT:\n                  var rbp = bindingPower.Dot;\n\n                  if (this._lookahead(0) !== TOK_STAR) {\n                    right = this._parseDotRHS(rbp);\n                    return {\n                      type: \"Subexpression\",\n                      children: [left, right]\n                    };\n                  } else {\n                    // Creating a projection.\n                    this._advance();\n\n                    right = this._parseProjectionRHS(rbp);\n                    return {\n                      type: \"ValueProjection\",\n                      children: [left, right]\n                    };\n                  }\n\n                  break;\n\n                case TOK_PIPE:\n                  right = this.expression(bindingPower.Pipe);\n                  return {\n                    type: TOK_PIPE,\n                    children: [left, right]\n                  };\n\n                case TOK_OR:\n                  right = this.expression(bindingPower.Or);\n                  return {\n                    type: \"OrExpression\",\n                    children: [left, right]\n                  };\n\n                case TOK_AND:\n                  right = this.expression(bindingPower.And);\n                  return {\n                    type: \"AndExpression\",\n                    children: [left, right]\n                  };\n\n                case TOK_LPAREN:\n                  var name = left.name;\n                  var args = [];\n                  var expression, node;\n\n                  while (this._lookahead(0) !== TOK_RPAREN) {\n                    if (this._lookahead(0) === TOK_CURRENT) {\n                      expression = {\n                        type: TOK_CURRENT\n                      };\n\n                      this._advance();\n                    } else {\n                      expression = this.expression(0);\n                    }\n\n                    if (this._lookahead(0) === TOK_COMMA) {\n                      this._match(TOK_COMMA);\n                    }\n\n                    args.push(expression);\n                  }\n\n                  this._match(TOK_RPAREN);\n\n                  node = {\n                    type: \"Function\",\n                    name: name,\n                    children: args\n                  };\n                  return node;\n\n                case TOK_FILTER:\n                  var condition = this.expression(0);\n\n                  this._match(TOK_RBRACKET);\n\n                  if (this._lookahead(0) === TOK_FLATTEN) {\n                    right = {\n                      type: \"Identity\"\n                    };\n                  } else {\n                    right = this._parseProjectionRHS(bindingPower.Filter);\n                  }\n\n                  return {\n                    type: \"FilterProjection\",\n                    children: [left, right, condition]\n                  };\n\n                case TOK_FLATTEN:\n                  var leftNode = {\n                    type: TOK_FLATTEN,\n                    children: [left]\n                  };\n\n                  var rightNode = this._parseProjectionRHS(bindingPower.Flatten);\n\n                  return {\n                    type: \"Projection\",\n                    children: [leftNode, rightNode]\n                  };\n\n                case TOK_EQ:\n                case TOK_NE:\n                case TOK_GT:\n                case TOK_GTE:\n                case TOK_LT:\n                case TOK_LTE:\n                  return this._parseComparator(left, tokenName);\n\n                case TOK_LBRACKET:\n                  var token = this._lookaheadToken(0);\n\n                  if (token.type === TOK_NUMBER || token.type === TOK_COLON) {\n                    right = this._parseIndexExpression();\n                    return this._projectIfSlice(left, right);\n                  } else {\n                    this._match(TOK_STAR);\n\n                    this._match(TOK_RBRACKET);\n\n                    right = this._parseProjectionRHS(bindingPower.Star);\n                    return {\n                      type: \"Projection\",\n                      children: [left, right]\n                    };\n                  }\n\n                  break;\n\n                default:\n                  this._errorToken(this._lookaheadToken(0));\n\n              }\n            },\n            _match: function (tokenType) {\n              if (this._lookahead(0) === tokenType) {\n                this._advance();\n              } else {\n                var t = this._lookaheadToken(0);\n\n                var error = new Error(\"Expected \" + tokenType + \", got: \" + t.type);\n                error.name = \"ParserError\";\n                throw error;\n              }\n            },\n            _errorToken: function (token) {\n              var error = new Error(\"Invalid token (\" + token.type + \"): \\\"\" + token.value + \"\\\"\");\n              error.name = \"ParserError\";\n              throw error;\n            },\n            _parseIndexExpression: function () {\n              if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {\n                return this._parseSliceExpression();\n              } else {\n                var node = {\n                  type: \"Index\",\n                  value: this._lookaheadToken(0).value\n                };\n\n                this._advance();\n\n                this._match(TOK_RBRACKET);\n\n                return node;\n              }\n            },\n            _projectIfSlice: function (left, right) {\n              var indexExpr = {\n                type: \"IndexExpression\",\n                children: [left, right]\n              };\n\n              if (right.type === \"Slice\") {\n                return {\n                  type: \"Projection\",\n                  children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]\n                };\n              } else {\n                return indexExpr;\n              }\n            },\n            _parseSliceExpression: function () {\n              // [start:end:step] where each part is optional, as well as the last\n              // colon.\n              var parts = [null, null, null];\n              var index = 0;\n\n              var currentToken = this._lookahead(0);\n\n              while (currentToken !== TOK_RBRACKET && index < 3) {\n                if (currentToken === TOK_COLON) {\n                  index++;\n\n                  this._advance();\n                } else if (currentToken === TOK_NUMBER) {\n                  parts[index] = this._lookaheadToken(0).value;\n\n                  this._advance();\n                } else {\n                  var t = this._lookahead(0);\n\n                  var error = new Error(\"Syntax error, unexpected token: \" + t.value + \"(\" + t.type + \")\");\n                  error.name = \"Parsererror\";\n                  throw error;\n                }\n\n                currentToken = this._lookahead(0);\n              }\n\n              this._match(TOK_RBRACKET);\n\n              return {\n                type: \"Slice\",\n                children: parts\n              };\n            },\n            _parseComparator: function (left, comparator) {\n              var right = this.expression(bindingPower[comparator]);\n              return {\n                type: \"Comparator\",\n                name: comparator,\n                children: [left, right]\n              };\n            },\n            _parseDotRHS: function (rbp) {\n              var lookahead = this._lookahead(0);\n\n              var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];\n\n              if (exprTokens.indexOf(lookahead) >= 0) {\n                return this.expression(rbp);\n              } else if (lookahead === TOK_LBRACKET) {\n                this._match(TOK_LBRACKET);\n\n                return this._parseMultiselectList();\n              } else if (lookahead === TOK_LBRACE) {\n                this._match(TOK_LBRACE);\n\n                return this._parseMultiselectHash();\n              }\n            },\n            _parseProjectionRHS: function (rbp) {\n              var right;\n\n              if (bindingPower[this._lookahead(0)] < 10) {\n                right = {\n                  type: \"Identity\"\n                };\n              } else if (this._lookahead(0) === TOK_LBRACKET) {\n                right = this.expression(rbp);\n              } else if (this._lookahead(0) === TOK_FILTER) {\n                right = this.expression(rbp);\n              } else if (this._lookahead(0) === TOK_DOT) {\n                this._match(TOK_DOT);\n\n                right = this._parseDotRHS(rbp);\n              } else {\n                var t = this._lookaheadToken(0);\n\n                var error = new Error(\"Sytanx error, unexpected token: \" + t.value + \"(\" + t.type + \")\");\n                error.name = \"ParserError\";\n                throw error;\n              }\n\n              return right;\n            },\n            _parseMultiselectList: function () {\n              var expressions = [];\n\n              while (this._lookahead(0) !== TOK_RBRACKET) {\n                var expression = this.expression(0);\n                expressions.push(expression);\n\n                if (this._lookahead(0) === TOK_COMMA) {\n                  this._match(TOK_COMMA);\n\n                  if (this._lookahead(0) === TOK_RBRACKET) {\n                    throw new Error(\"Unexpected token Rbracket\");\n                  }\n                }\n              }\n\n              this._match(TOK_RBRACKET);\n\n              return {\n                type: \"MultiSelectList\",\n                children: expressions\n              };\n            },\n            _parseMultiselectHash: function () {\n              var pairs = [];\n              var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];\n              var keyToken, keyName, value, node;\n\n              for (;;) {\n                keyToken = this._lookaheadToken(0);\n\n                if (identifierTypes.indexOf(keyToken.type) < 0) {\n                  throw new Error(\"Expecting an identifier token, got: \" + keyToken.type);\n                }\n\n                keyName = keyToken.value;\n\n                this._advance();\n\n                this._match(TOK_COLON);\n\n                value = this.expression(0);\n                node = {\n                  type: \"KeyValuePair\",\n                  name: keyName,\n                  value: value\n                };\n                pairs.push(node);\n\n                if (this._lookahead(0) === TOK_COMMA) {\n                  this._match(TOK_COMMA);\n                } else if (this._lookahead(0) === TOK_RBRACE) {\n                  this._match(TOK_RBRACE);\n\n                  break;\n                }\n              }\n\n              return {\n                type: \"MultiSelectHash\",\n                children: pairs\n              };\n            }\n          };\n\n          function TreeInterpreter(runtime) {\n            this.runtime = runtime;\n          }\n\n          TreeInterpreter.prototype = {\n            search: function (node, value) {\n              return this.visit(node, value);\n            },\n            visit: function (node, value) {\n              var matched, current, result, first, second, field, left, right, collected, i;\n\n              switch (node.type) {\n                case \"Field\":\n                  if (value === null) {\n                    return null;\n                  } else if (isObject(value)) {\n                    field = value[node.name];\n\n                    if (field === undefined) {\n                      return null;\n                    } else {\n                      return field;\n                    }\n                  } else {\n                    return null;\n                  }\n\n                  break;\n\n                case \"Subexpression\":\n                  result = this.visit(node.children[0], value);\n\n                  for (i = 1; i < node.children.length; i++) {\n                    result = this.visit(node.children[1], result);\n\n                    if (result === null) {\n                      return null;\n                    }\n                  }\n\n                  return result;\n\n                case \"IndexExpression\":\n                  left = this.visit(node.children[0], value);\n                  right = this.visit(node.children[1], left);\n                  return right;\n\n                case \"Index\":\n                  if (!isArray(value)) {\n                    return null;\n                  }\n\n                  var index = node.value;\n\n                  if (index < 0) {\n                    index = value.length + index;\n                  }\n\n                  result = value[index];\n\n                  if (result === undefined) {\n                    result = null;\n                  }\n\n                  return result;\n\n                case \"Slice\":\n                  if (!isArray(value)) {\n                    return null;\n                  }\n\n                  var sliceParams = node.children.slice(0);\n                  var computed = this.computeSliceParams(value.length, sliceParams);\n                  var start = computed[0];\n                  var stop = computed[1];\n                  var step = computed[2];\n                  result = [];\n\n                  if (step > 0) {\n                    for (i = start; i < stop; i += step) {\n                      result.push(value[i]);\n                    }\n                  } else {\n                    for (i = start; i > stop; i += step) {\n                      result.push(value[i]);\n                    }\n                  }\n\n                  return result;\n\n                case \"Projection\":\n                  // Evaluate left child.\n                  var base = this.visit(node.children[0], value);\n\n                  if (!isArray(base)) {\n                    return null;\n                  }\n\n                  collected = [];\n\n                  for (i = 0; i < base.length; i++) {\n                    current = this.visit(node.children[1], base[i]);\n\n                    if (current !== null) {\n                      collected.push(current);\n                    }\n                  }\n\n                  return collected;\n\n                case \"ValueProjection\":\n                  // Evaluate left child.\n                  base = this.visit(node.children[0], value);\n\n                  if (!isObject(base)) {\n                    return null;\n                  }\n\n                  collected = [];\n                  var values = objValues(base);\n\n                  for (i = 0; i < values.length; i++) {\n                    current = this.visit(node.children[1], values[i]);\n\n                    if (current !== null) {\n                      collected.push(current);\n                    }\n                  }\n\n                  return collected;\n\n                case \"FilterProjection\":\n                  base = this.visit(node.children[0], value);\n\n                  if (!isArray(base)) {\n                    return null;\n                  }\n\n                  var filtered = [];\n                  var finalResults = [];\n\n                  for (i = 0; i < base.length; i++) {\n                    matched = this.visit(node.children[2], base[i]);\n\n                    if (!isFalse(matched)) {\n                      filtered.push(base[i]);\n                    }\n                  }\n\n                  for (var j = 0; j < filtered.length; j++) {\n                    current = this.visit(node.children[1], filtered[j]);\n\n                    if (current !== null) {\n                      finalResults.push(current);\n                    }\n                  }\n\n                  return finalResults;\n\n                case \"Comparator\":\n                  first = this.visit(node.children[0], value);\n                  second = this.visit(node.children[1], value);\n\n                  switch (node.name) {\n                    case TOK_EQ:\n                      result = strictDeepEqual(first, second);\n                      break;\n\n                    case TOK_NE:\n                      result = !strictDeepEqual(first, second);\n                      break;\n\n                    case TOK_GT:\n                      result = first > second;\n                      break;\n\n                    case TOK_GTE:\n                      result = first >= second;\n                      break;\n\n                    case TOK_LT:\n                      result = first < second;\n                      break;\n\n                    case TOK_LTE:\n                      result = first <= second;\n                      break;\n\n                    default:\n                      throw new Error(\"Unknown comparator: \" + node.name);\n                  }\n\n                  return result;\n\n                case TOK_FLATTEN:\n                  var original = this.visit(node.children[0], value);\n\n                  if (!isArray(original)) {\n                    return null;\n                  }\n\n                  var merged = [];\n\n                  for (i = 0; i < original.length; i++) {\n                    current = original[i];\n\n                    if (isArray(current)) {\n                      merged.push.apply(merged, current);\n                    } else {\n                      merged.push(current);\n                    }\n                  }\n\n                  return merged;\n\n                case \"Identity\":\n                  return value;\n\n                case \"MultiSelectList\":\n                  if (value === null) {\n                    return null;\n                  }\n\n                  collected = [];\n\n                  for (i = 0; i < node.children.length; i++) {\n                    collected.push(this.visit(node.children[i], value));\n                  }\n\n                  return collected;\n\n                case \"MultiSelectHash\":\n                  if (value === null) {\n                    return null;\n                  }\n\n                  collected = {};\n                  var child;\n\n                  for (i = 0; i < node.children.length; i++) {\n                    child = node.children[i];\n                    collected[child.name] = this.visit(child.value, value);\n                  }\n\n                  return collected;\n\n                case \"OrExpression\":\n                  matched = this.visit(node.children[0], value);\n\n                  if (isFalse(matched)) {\n                    matched = this.visit(node.children[1], value);\n                  }\n\n                  return matched;\n\n                case \"AndExpression\":\n                  first = this.visit(node.children[0], value);\n\n                  if (isFalse(first) === true) {\n                    return first;\n                  }\n\n                  return this.visit(node.children[1], value);\n\n                case \"NotExpression\":\n                  first = this.visit(node.children[0], value);\n                  return isFalse(first);\n\n                case \"Literal\":\n                  return node.value;\n\n                case TOK_PIPE:\n                  left = this.visit(node.children[0], value);\n                  return this.visit(node.children[1], left);\n\n                case TOK_CURRENT:\n                  return value;\n\n                case \"Function\":\n                  var resolvedArgs = [];\n\n                  for (i = 0; i < node.children.length; i++) {\n                    resolvedArgs.push(this.visit(node.children[i], value));\n                  }\n\n                  return this.runtime.callFunction(node.name, resolvedArgs);\n\n                case \"ExpressionReference\":\n                  var refNode = node.children[0]; // Tag the node with a specific attribute so the type\n                  // checker verify the type.\n\n                  refNode.jmespathType = TOK_EXPREF;\n                  return refNode;\n\n                default:\n                  throw new Error(\"Unknown node type: \" + node.type);\n              }\n            },\n            computeSliceParams: function (arrayLength, sliceParams) {\n              var start = sliceParams[0];\n              var stop = sliceParams[1];\n              var step = sliceParams[2];\n              var computed = [null, null, null];\n\n              if (step === null) {\n                step = 1;\n              } else if (step === 0) {\n                var error = new Error(\"Invalid slice, step cannot be 0\");\n                error.name = \"RuntimeError\";\n                throw error;\n              }\n\n              var stepValueNegative = step < 0 ? true : false;\n\n              if (start === null) {\n                start = stepValueNegative ? arrayLength - 1 : 0;\n              } else {\n                start = this.capSliceRange(arrayLength, start, step);\n              }\n\n              if (stop === null) {\n                stop = stepValueNegative ? -1 : arrayLength;\n              } else {\n                stop = this.capSliceRange(arrayLength, stop, step);\n              }\n\n              computed[0] = start;\n              computed[1] = stop;\n              computed[2] = step;\n              return computed;\n            },\n            capSliceRange: function (arrayLength, actualValue, step) {\n              if (actualValue < 0) {\n                actualValue += arrayLength;\n\n                if (actualValue < 0) {\n                  actualValue = step < 0 ? -1 : 0;\n                }\n              } else if (actualValue >= arrayLength) {\n                actualValue = step < 0 ? arrayLength - 1 : arrayLength;\n              }\n\n              return actualValue;\n            }\n          };\n\n          function Runtime(interpreter) {\n            this._interpreter = interpreter;\n            this.functionTable = {\n              // name: [function, <signature>]\n              // The <signature> can be:\n              //\n              // {\n              //   args: [[type1, type2], [type1, type2]],\n              //   variadic: true|false\n              // }\n              //\n              // Each arg in the arg list is a list of valid types\n              // (if the function is overloaded and supports multiple\n              // types.  If the type is \"any\" then no type checking\n              // occurs on the argument.  Variadic is optional\n              // and if not provided is assumed to be false.\n              abs: {\n                _func: this._functionAbs,\n                _signature: [{\n                  types: [TYPE_NUMBER]\n                }]\n              },\n              avg: {\n                _func: this._functionAvg,\n                _signature: [{\n                  types: [TYPE_ARRAY_NUMBER]\n                }]\n              },\n              ceil: {\n                _func: this._functionCeil,\n                _signature: [{\n                  types: [TYPE_NUMBER]\n                }]\n              },\n              contains: {\n                _func: this._functionContains,\n                _signature: [{\n                  types: [TYPE_STRING, TYPE_ARRAY]\n                }, {\n                  types: [TYPE_ANY]\n                }]\n              },\n              \"ends_with\": {\n                _func: this._functionEndsWith,\n                _signature: [{\n                  types: [TYPE_STRING]\n                }, {\n                  types: [TYPE_STRING]\n                }]\n              },\n              floor: {\n                _func: this._functionFloor,\n                _signature: [{\n                  types: [TYPE_NUMBER]\n                }]\n              },\n              length: {\n                _func: this._functionLength,\n                _signature: [{\n                  types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]\n                }]\n              },\n              map: {\n                _func: this._functionMap,\n                _signature: [{\n                  types: [TYPE_EXPREF]\n                }, {\n                  types: [TYPE_ARRAY]\n                }]\n              },\n              max: {\n                _func: this._functionMax,\n                _signature: [{\n                  types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]\n                }]\n              },\n              \"merge\": {\n                _func: this._functionMerge,\n                _signature: [{\n                  types: [TYPE_OBJECT],\n                  variadic: true\n                }]\n              },\n              \"max_by\": {\n                _func: this._functionMaxBy,\n                _signature: [{\n                  types: [TYPE_ARRAY]\n                }, {\n                  types: [TYPE_EXPREF]\n                }]\n              },\n              sum: {\n                _func: this._functionSum,\n                _signature: [{\n                  types: [TYPE_ARRAY_NUMBER]\n                }]\n              },\n              \"starts_with\": {\n                _func: this._functionStartsWith,\n                _signature: [{\n                  types: [TYPE_STRING]\n                }, {\n                  types: [TYPE_STRING]\n                }]\n              },\n              min: {\n                _func: this._functionMin,\n                _signature: [{\n                  types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]\n                }]\n              },\n              \"min_by\": {\n                _func: this._functionMinBy,\n                _signature: [{\n                  types: [TYPE_ARRAY]\n                }, {\n                  types: [TYPE_EXPREF]\n                }]\n              },\n              type: {\n                _func: this._functionType,\n                _signature: [{\n                  types: [TYPE_ANY]\n                }]\n              },\n              keys: {\n                _func: this._functionKeys,\n                _signature: [{\n                  types: [TYPE_OBJECT]\n                }]\n              },\n              values: {\n                _func: this._functionValues,\n                _signature: [{\n                  types: [TYPE_OBJECT]\n                }]\n              },\n              sort: {\n                _func: this._functionSort,\n                _signature: [{\n                  types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]\n                }]\n              },\n              \"sort_by\": {\n                _func: this._functionSortBy,\n                _signature: [{\n                  types: [TYPE_ARRAY]\n                }, {\n                  types: [TYPE_EXPREF]\n                }]\n              },\n              join: {\n                _func: this._functionJoin,\n                _signature: [{\n                  types: [TYPE_STRING]\n                }, {\n                  types: [TYPE_ARRAY_STRING]\n                }]\n              },\n              reverse: {\n                _func: this._functionReverse,\n                _signature: [{\n                  types: [TYPE_STRING, TYPE_ARRAY]\n                }]\n              },\n              \"to_array\": {\n                _func: this._functionToArray,\n                _signature: [{\n                  types: [TYPE_ANY]\n                }]\n              },\n              \"to_string\": {\n                _func: this._functionToString,\n                _signature: [{\n                  types: [TYPE_ANY]\n                }]\n              },\n              \"to_number\": {\n                _func: this._functionToNumber,\n                _signature: [{\n                  types: [TYPE_ANY]\n                }]\n              },\n              \"not_null\": {\n                _func: this._functionNotNull,\n                _signature: [{\n                  types: [TYPE_ANY],\n                  variadic: true\n                }]\n              }\n            };\n          }\n\n          Runtime.prototype = {\n            callFunction: function (name, resolvedArgs) {\n              var functionEntry = this.functionTable[name];\n\n              if (functionEntry === undefined) {\n                throw new Error(\"Unknown function: \" + name + \"()\");\n              }\n\n              this._validateArgs(name, resolvedArgs, functionEntry._signature);\n\n              return functionEntry._func.call(this, resolvedArgs);\n            },\n            _validateArgs: function (name, args, signature) {\n              // Validating the args requires validating\n              // the correct arity and the correct type of each arg.\n              // If the last argument is declared as variadic, then we need\n              // a minimum number of args to be required.  Otherwise it has to\n              // be an exact amount.\n              var pluralized;\n\n              if (signature[signature.length - 1].variadic) {\n                if (args.length < signature.length) {\n                  pluralized = signature.length === 1 ? \" argument\" : \" arguments\";\n                  throw new Error(\"ArgumentError: \" + name + \"() \" + \"takes at least\" + signature.length + pluralized + \" but received \" + args.length);\n                }\n              } else if (args.length !== signature.length) {\n                pluralized = signature.length === 1 ? \" argument\" : \" arguments\";\n                throw new Error(\"ArgumentError: \" + name + \"() \" + \"takes \" + signature.length + pluralized + \" but received \" + args.length);\n              }\n\n              var currentSpec;\n              var actualType;\n              var typeMatched;\n\n              for (var i = 0; i < signature.length; i++) {\n                typeMatched = false;\n                currentSpec = signature[i].types;\n                actualType = this._getTypeName(args[i]);\n\n                for (var j = 0; j < currentSpec.length; j++) {\n                  if (this._typeMatches(actualType, currentSpec[j], args[i])) {\n                    typeMatched = true;\n                    break;\n                  }\n                }\n\n                if (!typeMatched) {\n                  throw new Error(\"TypeError: \" + name + \"() \" + \"expected argument \" + (i + 1) + \" to be type \" + currentSpec + \" but received type \" + actualType + \" instead.\");\n                }\n              }\n            },\n            _typeMatches: function (actual, expected, argValue) {\n              if (expected === TYPE_ANY) {\n                return true;\n              }\n\n              if (expected === TYPE_ARRAY_STRING || expected === TYPE_ARRAY_NUMBER || expected === TYPE_ARRAY) {\n                // The expected type can either just be array,\n                // or it can require a specific subtype (array of numbers).\n                //\n                // The simplest case is if \"array\" with no subtype is specified.\n                if (expected === TYPE_ARRAY) {\n                  return actual === TYPE_ARRAY;\n                } else if (actual === TYPE_ARRAY) {\n                  // Otherwise we need to check subtypes.\n                  // I think this has potential to be improved.\n                  var subtype;\n\n                  if (expected === TYPE_ARRAY_NUMBER) {\n                    subtype = TYPE_NUMBER;\n                  } else if (expected === TYPE_ARRAY_STRING) {\n                    subtype = TYPE_STRING;\n                  }\n\n                  for (var i = 0; i < argValue.length; i++) {\n                    if (!this._typeMatches(this._getTypeName(argValue[i]), subtype, argValue[i])) {\n                      return false;\n                    }\n                  }\n\n                  return true;\n                }\n              } else {\n                return actual === expected;\n              }\n            },\n            _getTypeName: function (obj) {\n              switch (Object.prototype.toString.call(obj)) {\n                case \"[object String]\":\n                  return TYPE_STRING;\n\n                case \"[object Number]\":\n                  return TYPE_NUMBER;\n\n                case \"[object Array]\":\n                  return TYPE_ARRAY;\n\n                case \"[object Boolean]\":\n                  return TYPE_BOOLEAN;\n\n                case \"[object Null]\":\n                  return TYPE_NULL;\n\n                case \"[object Object]\":\n                  // Check if it's an expref.  If it has, it's been\n                  // tagged with a jmespathType attr of 'Expref';\n                  if (obj.jmespathType === TOK_EXPREF) {\n                    return TYPE_EXPREF;\n                  } else {\n                    return TYPE_OBJECT;\n                  }\n\n              }\n            },\n            _functionStartsWith: function (resolvedArgs) {\n              return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;\n            },\n            _functionEndsWith: function (resolvedArgs) {\n              var searchStr = resolvedArgs[0];\n              var suffix = resolvedArgs[1];\n              return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;\n            },\n            _functionReverse: function (resolvedArgs) {\n              var typeName = this._getTypeName(resolvedArgs[0]);\n\n              if (typeName === TYPE_STRING) {\n                var originalStr = resolvedArgs[0];\n                var reversedStr = \"\";\n\n                for (var i = originalStr.length - 1; i >= 0; i--) {\n                  reversedStr += originalStr[i];\n                }\n\n                return reversedStr;\n              } else {\n                var reversedArray = resolvedArgs[0].slice(0);\n                reversedArray.reverse();\n                return reversedArray;\n              }\n            },\n            _functionAbs: function (resolvedArgs) {\n              return Math.abs(resolvedArgs[0]);\n            },\n            _functionCeil: function (resolvedArgs) {\n              return Math.ceil(resolvedArgs[0]);\n            },\n            _functionAvg: function (resolvedArgs) {\n              var sum = 0;\n              var inputArray = resolvedArgs[0];\n\n              for (var i = 0; i < inputArray.length; i++) {\n                sum += inputArray[i];\n              }\n\n              return sum / inputArray.length;\n            },\n            _functionContains: function (resolvedArgs) {\n              return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;\n            },\n            _functionFloor: function (resolvedArgs) {\n              return Math.floor(resolvedArgs[0]);\n            },\n            _functionLength: function (resolvedArgs) {\n              if (!isObject(resolvedArgs[0])) {\n                return resolvedArgs[0].length;\n              } else {\n                // As far as I can tell, there's no way to get the length\n                // of an object without O(n) iteration through the object.\n                return Object.keys(resolvedArgs[0]).length;\n              }\n            },\n            _functionMap: function (resolvedArgs) {\n              var mapped = [];\n              var interpreter = this._interpreter;\n              var exprefNode = resolvedArgs[0];\n              var elements = resolvedArgs[1];\n\n              for (var i = 0; i < elements.length; i++) {\n                mapped.push(interpreter.visit(exprefNode, elements[i]));\n              }\n\n              return mapped;\n            },\n            _functionMerge: function (resolvedArgs) {\n              var merged = {};\n\n              for (var i = 0; i < resolvedArgs.length; i++) {\n                var current = resolvedArgs[i];\n\n                for (var key in current) {\n                  merged[key] = current[key];\n                }\n              }\n\n              return merged;\n            },\n            _functionMax: function (resolvedArgs) {\n              if (resolvedArgs[0].length > 0) {\n                var typeName = this._getTypeName(resolvedArgs[0][0]);\n\n                if (typeName === TYPE_NUMBER) {\n                  return Math.max.apply(Math, resolvedArgs[0]);\n                } else {\n                  var elements = resolvedArgs[0];\n                  var maxElement = elements[0];\n\n                  for (var i = 1; i < elements.length; i++) {\n                    if (maxElement.localeCompare(elements[i]) < 0) {\n                      maxElement = elements[i];\n                    }\n                  }\n\n                  return maxElement;\n                }\n              } else {\n                return null;\n              }\n            },\n            _functionMin: function (resolvedArgs) {\n              if (resolvedArgs[0].length > 0) {\n                var typeName = this._getTypeName(resolvedArgs[0][0]);\n\n                if (typeName === TYPE_NUMBER) {\n                  return Math.min.apply(Math, resolvedArgs[0]);\n                } else {\n                  var elements = resolvedArgs[0];\n                  var minElement = elements[0];\n\n                  for (var i = 1; i < elements.length; i++) {\n                    if (elements[i].localeCompare(minElement) < 0) {\n                      minElement = elements[i];\n                    }\n                  }\n\n                  return minElement;\n                }\n              } else {\n                return null;\n              }\n            },\n            _functionSum: function (resolvedArgs) {\n              var sum = 0;\n              var listToSum = resolvedArgs[0];\n\n              for (var i = 0; i < listToSum.length; i++) {\n                sum += listToSum[i];\n              }\n\n              return sum;\n            },\n            _functionType: function (resolvedArgs) {\n              switch (this._getTypeName(resolvedArgs[0])) {\n                case TYPE_NUMBER:\n                  return \"number\";\n\n                case TYPE_STRING:\n                  return \"string\";\n\n                case TYPE_ARRAY:\n                  return \"array\";\n\n                case TYPE_OBJECT:\n                  return \"object\";\n\n                case TYPE_BOOLEAN:\n                  return \"boolean\";\n\n                case TYPE_EXPREF:\n                  return \"expref\";\n\n                case TYPE_NULL:\n                  return \"null\";\n              }\n            },\n            _functionKeys: function (resolvedArgs) {\n              return Object.keys(resolvedArgs[0]);\n            },\n            _functionValues: function (resolvedArgs) {\n              var obj = resolvedArgs[0];\n              var keys = Object.keys(obj);\n              var values = [];\n\n              for (var i = 0; i < keys.length; i++) {\n                values.push(obj[keys[i]]);\n              }\n\n              return values;\n            },\n            _functionJoin: function (resolvedArgs) {\n              var joinChar = resolvedArgs[0];\n              var listJoin = resolvedArgs[1];\n              return listJoin.join(joinChar);\n            },\n            _functionToArray: function (resolvedArgs) {\n              if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {\n                return resolvedArgs[0];\n              } else {\n                return [resolvedArgs[0]];\n              }\n            },\n            _functionToString: function (resolvedArgs) {\n              if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {\n                return resolvedArgs[0];\n              } else {\n                return JSON.stringify(resolvedArgs[0]);\n              }\n            },\n            _functionToNumber: function (resolvedArgs) {\n              var typeName = this._getTypeName(resolvedArgs[0]);\n\n              var convertedValue;\n\n              if (typeName === TYPE_NUMBER) {\n                return resolvedArgs[0];\n              } else if (typeName === TYPE_STRING) {\n                convertedValue = +resolvedArgs[0];\n\n                if (!isNaN(convertedValue)) {\n                  return convertedValue;\n                }\n              }\n\n              return null;\n            },\n            _functionNotNull: function (resolvedArgs) {\n              for (var i = 0; i < resolvedArgs.length; i++) {\n                if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {\n                  return resolvedArgs[i];\n                }\n              }\n\n              return null;\n            },\n            _functionSort: function (resolvedArgs) {\n              var sortedArray = resolvedArgs[0].slice(0);\n              sortedArray.sort();\n              return sortedArray;\n            },\n            _functionSortBy: function (resolvedArgs) {\n              var sortedArray = resolvedArgs[0].slice(0);\n\n              if (sortedArray.length === 0) {\n                return sortedArray;\n              }\n\n              var interpreter = this._interpreter;\n              var exprefNode = resolvedArgs[1];\n\n              var requiredType = this._getTypeName(interpreter.visit(exprefNode, sortedArray[0]));\n\n              if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {\n                throw new Error(\"TypeError\");\n              }\n\n              var that = this; // In order to get a stable sort out of an unstable\n              // sort algorithm, we decorate/sort/undecorate (DSU)\n              // by creating a new list of [index, element] pairs.\n              // In the cmp function, if the evaluated elements are\n              // equal, then the index will be used as the tiebreaker.\n              // After the decorated list has been sorted, it will be\n              // undecorated to extract the original elements.\n\n              var decorated = [];\n\n              for (var i = 0; i < sortedArray.length; i++) {\n                decorated.push([i, sortedArray[i]]);\n              }\n\n              decorated.sort(function (a, b) {\n                var exprA = interpreter.visit(exprefNode, a[1]);\n                var exprB = interpreter.visit(exprefNode, b[1]);\n\n                if (that._getTypeName(exprA) !== requiredType) {\n                  throw new Error(\"TypeError: expected \" + requiredType + \", received \" + that._getTypeName(exprA));\n                } else if (that._getTypeName(exprB) !== requiredType) {\n                  throw new Error(\"TypeError: expected \" + requiredType + \", received \" + that._getTypeName(exprB));\n                }\n\n                if (exprA > exprB) {\n                  return 1;\n                } else if (exprA < exprB) {\n                  return -1;\n                } else {\n                  // If they're equal compare the items by their\n                  // order to maintain relative order of equal keys\n                  // (i.e. to get a stable sort).\n                  return a[0] - b[0];\n                }\n              }); // Undecorate: extract out the original list elements.\n\n              for (var j = 0; j < decorated.length; j++) {\n                sortedArray[j] = decorated[j][1];\n              }\n\n              return sortedArray;\n            },\n            _functionMaxBy: function (resolvedArgs) {\n              var exprefNode = resolvedArgs[1];\n              var resolvedArray = resolvedArgs[0];\n              var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n              var maxNumber = -Infinity;\n              var maxRecord;\n              var current;\n\n              for (var i = 0; i < resolvedArray.length; i++) {\n                current = keyFunction(resolvedArray[i]);\n\n                if (current > maxNumber) {\n                  maxNumber = current;\n                  maxRecord = resolvedArray[i];\n                }\n              }\n\n              return maxRecord;\n            },\n            _functionMinBy: function (resolvedArgs) {\n              var exprefNode = resolvedArgs[1];\n              var resolvedArray = resolvedArgs[0];\n              var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n              var minNumber = Infinity;\n              var minRecord;\n              var current;\n\n              for (var i = 0; i < resolvedArray.length; i++) {\n                current = keyFunction(resolvedArray[i]);\n\n                if (current < minNumber) {\n                  minNumber = current;\n                  minRecord = resolvedArray[i];\n                }\n              }\n\n              return minRecord;\n            },\n            createKeyFunction: function (exprefNode, allowedTypes) {\n              var that = this;\n              var interpreter = this._interpreter;\n\n              var keyFunc = function (x) {\n                var current = interpreter.visit(exprefNode, x);\n\n                if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {\n                  var msg = \"TypeError: expected one of \" + allowedTypes + \", received \" + that._getTypeName(current);\n\n                  throw new Error(msg);\n                }\n\n                return current;\n              };\n\n              return keyFunc;\n            }\n          };\n\n          function compile(stream) {\n            var parser = new Parser();\n            var ast = parser.parse(stream);\n            return ast;\n          }\n\n          function tokenize(stream) {\n            var lexer = new Lexer();\n            return lexer.tokenize(stream);\n          }\n\n          function search(data, expression) {\n            var parser = new Parser(); // This needs to be improved.  Both the interpreter and runtime depend on\n            // each other.  The runtime needs the interpreter to support exprefs.\n            // There's likely a clean way to avoid the cyclic dependency.\n\n            var runtime = new Runtime();\n            var interpreter = new TreeInterpreter(runtime);\n            runtime._interpreter = interpreter;\n            var node = parser.parse(expression);\n            return interpreter.search(node, data);\n          }\n\n          exports.tokenize = tokenize;\n          exports.compile = compile;\n          exports.search = search;\n          exports.strictDeepEqual = strictDeepEqual;\n        })(exports);\n        /***/\n\n      },\n      /* 5 */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        /* harmony export (binding) */\n        __webpack_require__.d(__webpack_exports__, \"a\", function () {\n          return showSortModal;\n        });\n        /* harmony import */\n\n\n        var picomodal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);\n        /* harmony import */\n\n\n        var picomodal__WEBPACK_IMPORTED_MODULE_0___default =\n        /*#__PURE__*/\n        __webpack_require__.n(picomodal__WEBPACK_IMPORTED_MODULE_0__);\n        /* harmony import */\n\n\n        var _i18n__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);\n        /* harmony import */\n\n\n        var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);\n        /**\n         * Show advanced sorting modal\n         * @param {HTMLElement} container   The container where to center\n         *                                  the modal and create an overlay\n         * @param {JSON} json               The JSON data to be sorted.\n         * @param {function} onSort         Callback function, invoked with\n         *                                  an object containing the selected\n         *                                  path and direction\n         * @param {Object} options\n         *            Available options:\n         *                - {string} path              The selected path\n         *                - {'asc' | 'desc'} direction The selected direction\n         */\n\n\n        function showSortModal(container, json, onSort, options) {\n          var paths = Array.isArray(json) ? Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"getChildPaths\"])(json) : [''];\n          var selectedPath = options && options.path && Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"contains\"])(paths, options.path) ? options.path : paths[0];\n          var selectedDirection = options && options.direction || 'asc';\n          var content = '<div class=\"pico-modal-contents\">' + '<div class=\"pico-modal-header\">' + Object(_i18n__WEBPACK_IMPORTED_MODULE_1__[\n          /* translate */\n          \"c\"])('sort') + '</div>' + '<form>' + '<table>' + '<tbody>' + '<tr>' + '  <td>' + Object(_i18n__WEBPACK_IMPORTED_MODULE_1__[\n          /* translate */\n          \"c\"])('sortFieldLabel') + ' </td>' + '  <td class=\"jsoneditor-modal-input\">' + '  <div class=\"jsoneditor-select-wrapper\">' + '    <select id=\"field\" title=\"' + Object(_i18n__WEBPACK_IMPORTED_MODULE_1__[\n          /* translate */\n          \"c\"])('sortFieldTitle') + '\">' + '    </select>' + '  </div>' + '  </td>' + '</tr>' + '<tr>' + '  <td>' + Object(_i18n__WEBPACK_IMPORTED_MODULE_1__[\n          /* translate */\n          \"c\"])('sortDirectionLabel') + ' </td>' + '  <td class=\"jsoneditor-modal-input\">' + '  <div id=\"direction\" class=\"jsoneditor-button-group\">' + '<input type=\"button\" ' + 'value=\"' + Object(_i18n__WEBPACK_IMPORTED_MODULE_1__[\n          /* translate */\n          \"c\"])('sortAscending') + '\" ' + 'title=\"' + Object(_i18n__WEBPACK_IMPORTED_MODULE_1__[\n          /* translate */\n          \"c\"])('sortAscendingTitle') + '\" ' + 'data-value=\"asc\" ' + 'class=\"jsoneditor-button-first jsoneditor-button-asc\"/>' + '<input type=\"button\" ' + 'value=\"' + Object(_i18n__WEBPACK_IMPORTED_MODULE_1__[\n          /* translate */\n          \"c\"])('sortDescending') + '\" ' + 'title=\"' + Object(_i18n__WEBPACK_IMPORTED_MODULE_1__[\n          /* translate */\n          \"c\"])('sortDescendingTitle') + '\" ' + 'data-value=\"desc\" ' + 'class=\"jsoneditor-button-last jsoneditor-button-desc\"/>' + '  </div>' + '  </td>' + '</tr>' + '<tr>' + '<td colspan=\"2\" class=\"jsoneditor-modal-input jsoneditor-modal-actions\">' + '  <input type=\"submit\" id=\"ok\" value=\"' + Object(_i18n__WEBPACK_IMPORTED_MODULE_1__[\n          /* translate */\n          \"c\"])('ok') + '\" />' + '</td>' + '</tr>' + '</tbody>' + '</table>' + '</form>' + '</div>';\n          picomodal__WEBPACK_IMPORTED_MODULE_0___default()({\n            parent: container,\n            content: content,\n            overlayClass: 'jsoneditor-modal-overlay',\n            overlayStyles: {\n              backgroundColor: 'rgb(1,1,1)',\n              opacity: 0.3\n            },\n            modalClass: 'jsoneditor-modal jsoneditor-modal-sort'\n          }).afterCreate(function (modal) {\n            var form = modal.modalElem().querySelector('form');\n            var ok = modal.modalElem().querySelector('#ok');\n            var field = modal.modalElem().querySelector('#field');\n            var direction = modal.modalElem().querySelector('#direction');\n\n            function preprocessPath(path) {\n              return path === '' ? '@' : path[0] === '.' ? path.slice(1) : path;\n            }\n\n            paths.forEach(function (path) {\n              var option = document.createElement('option');\n              option.text = preprocessPath(path);\n              option.value = path;\n              field.appendChild(option);\n            });\n\n            function setDirection(value) {\n              direction.value = value;\n              direction.className = 'jsoneditor-button-group jsoneditor-button-group-value-' + direction.value;\n            }\n\n            field.value = selectedPath || paths[0];\n            setDirection(selectedDirection || 'asc');\n\n            direction.onclick = function (event) {\n              setDirection(event.target.getAttribute('data-value'));\n            };\n\n            ok.onclick = function (event) {\n              event.preventDefault();\n              event.stopPropagation();\n              modal.close();\n              onSort({\n                path: field.value,\n                direction: direction.value\n              });\n            };\n\n            if (form) {\n              // form is not available when JSONEditor is created inside a form\n              form.onsubmit = ok.onclick;\n            }\n          }).afterClose(function (modal) {\n            modal.destroy();\n          }).show();\n        }\n        /***/\n\n      },\n      /* 6 */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        /* harmony export (binding) */\n        __webpack_require__.d(__webpack_exports__, \"a\", function () {\n          return ModeSwitcher;\n        });\n        /* harmony import */\n\n\n        var _ContextMenu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);\n        /* harmony import */\n\n\n        var _i18n__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);\n\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        function _defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        function _createClass(Constructor, protoProps, staticProps) {\n          if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) _defineProperties(Constructor, staticProps);\n          return Constructor;\n        }\n        /**\n         * Create a select box to be used in the editor menu's, which allows to switch mode\n         * @param {HTMLElement} container\n         * @param {String[]} modes  Available modes: 'code', 'form', 'text', 'tree', 'view', 'preview'\n         * @param {String} current  Available modes: 'code', 'form', 'text', 'tree', 'view', 'preview'\n         * @param {function(mode: string)} onSwitch  Callback invoked on switch\n         * @constructor\n         */\n\n\n        var ModeSwitcher =\n        /*#__PURE__*/\n        function () {\n          function ModeSwitcher(container, modes, current, onSwitch) {\n            _classCallCheck(this, ModeSwitcher); // available modes\n\n\n            var availableModes = {\n              code: {\n                text: Object(_i18n__WEBPACK_IMPORTED_MODULE_1__[\n                /* translate */\n                \"c\"])('modeCodeText'),\n                title: Object(_i18n__WEBPACK_IMPORTED_MODULE_1__[\n                /* translate */\n                \"c\"])('modeCodeTitle'),\n                click: function click() {\n                  onSwitch('code');\n                }\n              },\n              form: {\n                text: Object(_i18n__WEBPACK_IMPORTED_MODULE_1__[\n                /* translate */\n                \"c\"])('modeFormText'),\n                title: Object(_i18n__WEBPACK_IMPORTED_MODULE_1__[\n                /* translate */\n                \"c\"])('modeFormTitle'),\n                click: function click() {\n                  onSwitch('form');\n                }\n              },\n              text: {\n                text: Object(_i18n__WEBPACK_IMPORTED_MODULE_1__[\n                /* translate */\n                \"c\"])('modeTextText'),\n                title: Object(_i18n__WEBPACK_IMPORTED_MODULE_1__[\n                /* translate */\n                \"c\"])('modeTextTitle'),\n                click: function click() {\n                  onSwitch('text');\n                }\n              },\n              tree: {\n                text: Object(_i18n__WEBPACK_IMPORTED_MODULE_1__[\n                /* translate */\n                \"c\"])('modeTreeText'),\n                title: Object(_i18n__WEBPACK_IMPORTED_MODULE_1__[\n                /* translate */\n                \"c\"])('modeTreeTitle'),\n                click: function click() {\n                  onSwitch('tree');\n                }\n              },\n              view: {\n                text: Object(_i18n__WEBPACK_IMPORTED_MODULE_1__[\n                /* translate */\n                \"c\"])('modeViewText'),\n                title: Object(_i18n__WEBPACK_IMPORTED_MODULE_1__[\n                /* translate */\n                \"c\"])('modeViewTitle'),\n                click: function click() {\n                  onSwitch('view');\n                }\n              },\n              preview: {\n                text: Object(_i18n__WEBPACK_IMPORTED_MODULE_1__[\n                /* translate */\n                \"c\"])('modePreviewText'),\n                title: Object(_i18n__WEBPACK_IMPORTED_MODULE_1__[\n                /* translate */\n                \"c\"])('modePreviewTitle'),\n                click: function click() {\n                  onSwitch('preview');\n                }\n              }\n            }; // list the selected modes\n\n            var items = [];\n\n            for (var i = 0; i < modes.length; i++) {\n              var mode = modes[i];\n              var item = availableModes[mode];\n\n              if (!item) {\n                throw new Error('Unknown mode \"' + mode + '\"');\n              }\n\n              item.className = 'jsoneditor-type-modes' + (current === mode ? ' jsoneditor-selected' : '');\n              items.push(item);\n            } // retrieve the title of current mode\n\n\n            var currentMode = availableModes[current];\n\n            if (!currentMode) {\n              throw new Error('Unknown mode \"' + current + '\"');\n            }\n\n            var currentTitle = currentMode.text; // create the html element\n\n            var box = document.createElement('button');\n            box.type = 'button';\n            box.className = 'jsoneditor-modes jsoneditor-separator';\n            box.innerHTML = currentTitle + ' &#x25BE;';\n            box.title = 'Switch editor mode';\n\n            box.onclick = function () {\n              var menu = new _ContextMenu__WEBPACK_IMPORTED_MODULE_0__[\n              /* ContextMenu */\n              \"a\"](items);\n              menu.show(box, container);\n            };\n\n            var frame = document.createElement('div');\n            frame.className = 'jsoneditor-modes';\n            frame.style.position = 'relative';\n            frame.appendChild(box);\n            container.appendChild(frame);\n            this.dom = {\n              container: container,\n              box: box,\n              frame: frame\n            };\n          }\n          /**\n           * Set focus to switcher\n           */\n\n\n          _createClass(ModeSwitcher, [{\n            key: \"focus\",\n            value: function focus() {\n              this.dom.box.focus();\n            }\n            /**\n             * Destroy the ModeSwitcher, remove from DOM\n             */\n\n          }, {\n            key: \"destroy\",\n            value: function destroy() {\n              if (this.dom && this.dom.frame && this.dom.frame.parentNode) {\n                this.dom.frame.parentNode.removeChild(this.dom.frame);\n              }\n\n              this.dom = null;\n            }\n          }]);\n\n          return ModeSwitcher;\n        }();\n        /***/\n\n      },\n      /* 7 */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        // EXTERNAL MODULE: ./node_modules/jmespath/jmespath.js\n        var jmespath = __webpack_require__(4);\n\n        var jmespath_default =\n        /*#__PURE__*/\n        __webpack_require__.n(jmespath); // EXTERNAL MODULE: ./node_modules/picomodal/src/picoModal.js\n\n\n        var picoModal = __webpack_require__(12);\n\n        var picoModal_default =\n        /*#__PURE__*/\n        __webpack_require__.n(picoModal); // EXTERNAL MODULE: ./src/js/assets/selectr/selectr.js\n\n\n        var selectr = __webpack_require__(8);\n\n        var selectr_default =\n        /*#__PURE__*/\n        __webpack_require__.n(selectr); // EXTERNAL MODULE: ./src/js/i18n.js\n\n\n        var i18n = __webpack_require__(1); // CONCATENATED MODULE: ./src/js/jsonUtils.js\n\n        /**\n         * Convert part of a JSON object to a JSON string.\n         * Use case is to stringify a small part of a large JSON object so you can see\n         * a preview.\n         *\n         * @param {*} value\n         * The value to convert to a JSON string.\n         *\n         * @param {number | string | null} [space]\n         * A String or Number object that's used to insert white space into the output\n         * JSON string for readability purposes. If this is a Number, it indicates the\n         * number of space characters to use as white space; this number is capped at 10\n         * if it's larger than that. Values less than 1 indicate that no space should be\n         * used. If this is a String, the string (or the first 10 characters of the string,\n         * if it's longer than that) is used as white space. If this parameter is not\n         * provided (or is null), no white space is used.\n         *\n         * @param {number} [limit] Maximum size of the string output.\n         *\n         * @returns {string | undefined} Returns the string representation of the JSON object.\n         */\n\n\n        function _typeof(obj) {\n          if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n              return typeof obj;\n            };\n          } else {\n            _typeof = function _typeof(obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n          }\n\n          return _typeof(obj);\n        }\n\n        function stringifyPartial(value, space, limit) {\n          var _space; // undefined by default\n\n\n          if (typeof space === 'number') {\n            if (space > 10) {\n              _space = repeat(' ', 10);\n            } else if (space >= 1) {\n              _space = repeat(' ', space);\n            } // else ignore\n\n          } else if (typeof space === 'string' && space !== '') {\n            _space = space;\n          }\n\n          var output = stringifyValue(value, _space, '', limit);\n          return output.length > limit ? slice(output, limit) + '...' : output;\n        }\n        /**\n         * Stringify a value\n         * @param {*} value\n         * @param {string} space\n         * @param {string} indent\n         * @param {number} limit\n         * @return {string | undefined}\n         */\n\n\n        function stringifyValue(value, space, indent, limit) {\n          // boolean, null, number, string, or date\n          if (typeof value === 'boolean' || value instanceof Boolean || value === null || typeof value === 'number' || value instanceof Number || typeof value === 'string' || value instanceof String || value instanceof Date) {\n            return JSON.stringify(value);\n          } // array\n\n\n          if (Array.isArray(value)) {\n            return stringifyArray(value, space, indent, limit);\n          } // object (test lastly!)\n\n\n          if (value && _typeof(value) === 'object') {\n            return stringifyObject(value, space, indent, limit);\n          }\n\n          return undefined;\n        }\n        /**\n         * Stringify an array\n         * @param {Array} array\n         * @param {string} space\n         * @param {string} indent\n         * @param {number} limit\n         * @return {string}\n         */\n\n\n        function stringifyArray(array, space, indent, limit) {\n          var childIndent = space ? indent + space : undefined;\n          var str = space ? '[\\n' : '[';\n\n          for (var i = 0; i < array.length; i++) {\n            var item = array[i];\n\n            if (space) {\n              str += childIndent;\n            }\n\n            if (typeof item !== 'undefined' && typeof item !== 'function') {\n              str += stringifyValue(item, space, childIndent, limit);\n            } else {\n              str += 'null';\n            }\n\n            if (i < array.length - 1) {\n              str += space ? ',\\n' : ',';\n            } // stop as soon as we're exceeding the limit\n\n\n            if (str.length > limit) {\n              return str + '...';\n            }\n          }\n\n          str += space ? '\\n' + indent + ']' : ']';\n          return str;\n        }\n        /**\n         * Stringify an object\n         * @param {Object} object\n         * @param {string} space\n         * @param {string} indent\n         * @param {number} limit\n         * @return {string}\n         */\n\n\n        function stringifyObject(object, space, indent, limit) {\n          var childIndent = space ? indent + space : undefined;\n          var first = true;\n          var str = space ? '{\\n' : '{';\n\n          if (typeof object.toJSON === 'function') {\n            return stringifyValue(object.toJSON(), space, indent, limit);\n          }\n\n          for (var key in object) {\n            if (jsonUtils_hasOwnProperty(object, key)) {\n              var value = object[key];\n\n              if (first) {\n                first = false;\n              } else {\n                str += space ? ',\\n' : ',';\n              }\n\n              str += space ? childIndent + '\"' + key + '\": ' : '\"' + key + '\":';\n              str += stringifyValue(value, space, childIndent, limit); // stop as soon as we're exceeding the limit\n\n              if (str.length > limit) {\n                return str + '...';\n              }\n            }\n          }\n\n          str += space ? '\\n' + indent + '}' : '}';\n          return str;\n        }\n        /**\n         * Repeat a string a number of times.\n         * Simple linear solution, we only need up to 10 iterations in practice\n         * @param {string} text\n         * @param {number} times\n         * @return {string}\n         */\n\n\n        function repeat(text, times) {\n          var res = '';\n\n          while (times-- > 0) {\n            res += text;\n          }\n\n          return res;\n        }\n        /**\n         * Limit the length of text\n         * @param {string} text\n         * @param {number} [limit]\n         * @return {string}\n         */\n\n\n        function slice(text, limit) {\n          return typeof limit === 'number' ? text.slice(0, limit) : text;\n        }\n\n        function jsonUtils_hasOwnProperty(object, key) {\n          return Object.prototype.hasOwnProperty.call(object, key);\n        } // EXTERNAL MODULE: ./src/js/util.js\n\n\n        var util = __webpack_require__(0); // EXTERNAL MODULE: ./src/js/constants.js\n\n\n        var constants = __webpack_require__(2); // CONCATENATED MODULE: ./src/js/showTransformModal.js\n\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"a\", function () {\n          return showTransformModal;\n        });\n        /**\n         * Show advanced filter and transform modal using JMESPath\n         * @param {HTMLElement} container   The container where to center\n         *                                  the modal and create an overlay\n         * @param {JSON} json               The json data to be transformed\n         * @param {function} onTransform    Callback invoked with the created\n         *                                  query as callback\n         */\n\n\n        function showTransformModal(container, json, onTransform) {\n          var value = json;\n          var content = '<label class=\"pico-modal-contents\">' + '<div class=\"pico-modal-header\">' + Object(i18n[\"c\"\n          /* translate */\n          ])('transform') + '</div>' + '<p>' + 'Enter a <a href=\"http://jmespath.org\" target=\"_blank\">JMESPath</a> query to filter, sort, or transform the JSON data.<br/>' + 'To learn JMESPath, go to <a href=\"http://jmespath.org/tutorial.html\" target=\"_blank\">the interactive tutorial</a>.' + '</p>' + '<div class=\"jsoneditor-jmespath-label\">' + Object(i18n[\"c\"\n          /* translate */\n          ])('transformWizardLabel') + ' </div>' + '<div id=\"wizard\" class=\"jsoneditor-jmespath-block jsoneditor-jmespath-wizard\">' + '  <table class=\"jsoneditor-jmespath-wizard-table\">' + '    <tbody>' + '      <tr>' + '        <th>' + Object(i18n[\"c\"\n          /* translate */\n          ])('transformWizardFilter') + '</th>' + '        <td class=\"jsoneditor-jmespath-filter\">' + '          <div class=\"jsoneditor-inline jsoneditor-jmespath-filter-field\" >' + '            <select id=\"filterField\">' + '            </select>' + '          </div>' + '          <div class=\"jsoneditor-inline jsoneditor-jmespath-filter-relation\" >' + '            <select id=\"filterRelation\">' + '              <option value=\"==\">==</option>' + '              <option value=\"!=\">!=</option>' + '              <option value=\"<\">&lt;</option>' + '              <option value=\"<=\">&lt;=</option>' + '              <option value=\">\">&gt;</option>' + '              <option value=\">=\">&gt;=</option>' + '            </select>' + '          </div>' + '          <div class=\"jsoneditor-inline jsoneditor-jmespath-filter-value\" >' + '            <input placeholder=\"value...\" id=\"filterValue\" />' + '          </div>' + '        </td>' + '      </tr>' + '      <tr>' + '        <th>' + Object(i18n[\"c\"\n          /* translate */\n          ])('transformWizardSortBy') + '</th>' + '        <td class=\"jsoneditor-jmespath-filter\">' + '          <div class=\"jsoneditor-inline jsoneditor-jmespath-sort-field\">' + '            <select id=\"sortField\">' + '            </select>' + '          </div>' + '          <div class=\"jsoneditor-inline jsoneditor-jmespath-sort-order\" >' + '            <select id=\"sortOrder\">' + '              <option value=\"asc\">Ascending</option>' + '              <option value=\"desc\">Descending</option>' + '            </select>' + '          </div>' + '        </td>' + '      </tr>' + '      <tr id=\"selectFieldsPart\">' + '        <th>' + Object(i18n[\"c\"\n          /* translate */\n          ])('transformWizardSelectFields') + '</th>' + '        <td class=\"jsoneditor-jmespath-filter\">' + '          <select class=\"jsoneditor-jmespath-select-fields\" id=\"selectFields\" multiple></select>' + '        </td>' + '      </tr>' + '    </tbody>' + '  </table>' + '</div>' + '<div class=\"jsoneditor-jmespath-label\">' + Object(i18n[\"c\"\n          /* translate */\n          ])('transformQueryLabel') + ' </div>' + '<div class=\"jsoneditor-jmespath-block\">' + '  <textarea id=\"query\" ' + '            rows=\"4\" ' + '            autocomplete=\"off\" ' + '            autocorrect=\"off\" ' + '            autocapitalize=\"off\" ' + '            spellcheck=\"false\"' + '            title=\"' + Object(i18n[\"c\"\n          /* translate */\n          ])('transformQueryTitle') + '\">[*]</textarea>' + '</div>' + '<div class=\"jsoneditor-jmespath-label\">' + Object(i18n[\"c\"\n          /* translate */\n          ])('transformPreviewLabel') + ' </div>' + '<div class=\"jsoneditor-jmespath-block\">' + '  <textarea id=\"preview\" ' + '      class=\"jsoneditor-transform-preview\"' + '      readonly> </textarea>' + '</div>' + '<div class=\"jsoneditor-jmespath-block jsoneditor-modal-actions\">' + '  <input type=\"submit\" id=\"ok\" value=\"' + Object(i18n[\"c\"\n          /* translate */\n          ])('ok') + '\" autofocus />' + '</div>' + '</div>';\n          picoModal_default()({\n            parent: container,\n            content: content,\n            overlayClass: 'jsoneditor-modal-overlay',\n            overlayStyles: {\n              backgroundColor: 'rgb(1,1,1)',\n              opacity: 0.3\n            },\n            modalClass: 'jsoneditor-modal jsoneditor-modal-transform',\n            focus: false\n          }).afterCreate(function (modal) {\n            var elem = modal.modalElem();\n            var wizard = elem.querySelector('#wizard');\n            var ok = elem.querySelector('#ok');\n            var filterField = elem.querySelector('#filterField');\n            var filterRelation = elem.querySelector('#filterRelation');\n            var filterValue = elem.querySelector('#filterValue');\n            var sortField = elem.querySelector('#sortField');\n            var sortOrder = elem.querySelector('#sortOrder');\n            var selectFields = elem.querySelector('#selectFields');\n            var query = elem.querySelector('#query');\n            var preview = elem.querySelector('#preview');\n\n            if (!Array.isArray(value)) {\n              wizard.style.fontStyle = 'italic';\n              wizard.innerHTML = '(wizard not available for objects, only for arrays)';\n            }\n\n            var sortablePaths = Object(util[\"getChildPaths\"])(json);\n            sortablePaths.forEach(function (path) {\n              var formattedPath = preprocessPath(path);\n              var filterOption = document.createElement('option');\n              filterOption.text = formattedPath;\n              filterOption.value = formattedPath;\n              filterField.appendChild(filterOption);\n              var sortOption = document.createElement('option');\n              sortOption.text = formattedPath;\n              sortOption.value = formattedPath;\n              sortField.appendChild(sortOption);\n            });\n            var selectablePaths = Object(util[\"getChildPaths\"])(json, true).filter(function (path) {\n              return path !== '';\n            });\n\n            if (selectablePaths.length > 0) {\n              selectablePaths.forEach(function (path) {\n                var formattedPath = preprocessPath(path);\n                var option = document.createElement('option');\n                option.text = formattedPath;\n                option.value = formattedPath;\n                selectFields.appendChild(option);\n              });\n            } else {\n              var selectFieldsPart = elem.querySelector('#selectFieldsPart');\n\n              if (selectFieldsPart) {\n                selectFieldsPart.style.display = 'none';\n              }\n            }\n\n            var selectrFilterField = new selectr_default.a(filterField, {\n              defaultSelected: false,\n              clearable: true,\n              allowDeselect: true,\n              placeholder: 'field...'\n            });\n            var selectrFilterRelation = new selectr_default.a(filterRelation, {\n              defaultSelected: false,\n              clearable: true,\n              allowDeselect: true,\n              placeholder: 'compare...'\n            });\n            var selectrSortField = new selectr_default.a(sortField, {\n              defaultSelected: false,\n              clearable: true,\n              allowDeselect: true,\n              placeholder: 'field...'\n            });\n            var selectrSortOrder = new selectr_default.a(sortOrder, {\n              defaultSelected: false,\n              clearable: true,\n              allowDeselect: true,\n              placeholder: 'order...'\n            });\n            var selectrSelectFields = new selectr_default.a(selectFields, {\n              multiple: true,\n              clearable: true,\n              defaultSelected: false,\n              placeholder: 'select fields...'\n            });\n            selectrFilterField.on('selectr.change', generateQueryFromWizard);\n            selectrFilterRelation.on('selectr.change', generateQueryFromWizard);\n            filterValue.oninput = generateQueryFromWizard;\n            selectrSortField.on('selectr.change', generateQueryFromWizard);\n            selectrSortOrder.on('selectr.change', generateQueryFromWizard);\n            selectrSelectFields.on('selectr.change', generateQueryFromWizard);\n\n            elem.querySelector('.pico-modal-contents').onclick = function (event) {\n              // prevent the first clear button (in any select box) from getting\n              // focus when clicking anywhere in the modal. Only allow clicking links.\n              if (event.target.nodeName !== 'A') {\n                event.preventDefault();\n              }\n            };\n\n            query.value = Array.isArray(value) ? '[*]' : '@';\n\n            function preprocessPath(path) {\n              return path === '' ? '@' : path[0] === '.' ? path.slice(1) : path;\n            }\n\n            function generateQueryFromWizard() {\n              if (filterField.value && filterRelation.value && filterValue.value) {\n                var field1 = filterField.value;\n                var examplePath = field1 !== '@' ? ['0'].concat(Object(util[\"parsePath\"])('.' + field1)) : ['0'];\n                var exampleValue = Object(util[\"get\"])(value, examplePath);\n                var value1 = typeof exampleValue === 'string' ? filterValue.value : Object(util[\"parseString\"])(filterValue.value);\n                query.value = '[? ' + field1 + ' ' + filterRelation.value + ' ' + '`' + JSON.stringify(value1) + '`' + ']';\n              } else {\n                query.value = '[*]';\n              }\n\n              if (sortField.value && sortOrder.value) {\n                var field2 = sortField.value;\n\n                if (sortOrder.value === 'desc') {\n                  query.value += ' | reverse(sort_by(@, &' + field2 + '))';\n                } else {\n                  query.value += ' | sort_by(@, &' + field2 + ')';\n                }\n              }\n\n              if (selectFields.value) {\n                var values = [];\n\n                for (var i = 0; i < selectFields.options.length; i++) {\n                  if (selectFields.options[i].selected) {\n                    var selectedValue = selectFields.options[i].value;\n                    values.push(selectedValue);\n                  }\n                }\n\n                if (query.value[query.value.length - 1] !== ']') {\n                  query.value += ' | [*]';\n                }\n\n                if (values.length === 1) {\n                  query.value += '.' + values[0];\n                } else if (values.length > 1) {\n                  query.value += '.{' + values.map(function (value) {\n                    var parts = value.split('.');\n                    var last = parts[parts.length - 1];\n                    return last + ': ' + value;\n                  }).join(', ') + '}';\n                }\n              }\n\n              debouncedUpdatePreview();\n            }\n\n            function updatePreview() {\n              try {\n                var transformed = jmespath_default.a.search(value, query.value);\n                preview.className = 'jsoneditor-transform-preview';\n                preview.value = stringifyPartial(transformed, 2, constants[\"b\"\n                /* MAX_PREVIEW_CHARACTERS */\n                ]);\n                ok.disabled = false;\n              } catch (err) {\n                preview.className = 'jsoneditor-transform-preview jsoneditor-error';\n                preview.value = err.toString();\n                ok.disabled = true;\n              }\n            }\n\n            var debouncedUpdatePreview = Object(util[\"debounce\"])(updatePreview, 300);\n            query.oninput = debouncedUpdatePreview;\n            debouncedUpdatePreview();\n\n            ok.onclick = function (event) {\n              event.preventDefault();\n              event.stopPropagation();\n              modal.close();\n              onTransform(query.value);\n            };\n\n            setTimeout(function () {\n              query.select();\n              query.focus();\n              query.selectionStart = 3;\n              query.selectionEnd = 3;\n            });\n          }).afterClose(function (modal) {\n            modal.destroy();\n          }).show();\n        }\n        /***/\n\n      },\n      /* 8 */\n\n      /***/\n      function (module, exports, __webpack_require__) {\n        /*!\n         * Selectr 2.4.0\n         * https://github.com/Mobius1/Selectr\n         *\n         * Released under the MIT license\n         */\n\n        /**\n         * Default configuration options\n         * @type {Object}\n         */\n        var defaultConfig = {\n          /**\n           * Emulates browser behaviour by selecting the first option by default\n           * @type {Boolean}\n           */\n          defaultSelected: true,\n\n          /**\n           * Sets the width of the container\n           * @type {String}\n           */\n          width: \"auto\",\n\n          /**\n           * Enables/ disables the container\n           * @type {Boolean}\n           */\n          disabled: false,\n\n          /**\n           * Enables / disables the search function\n           * @type {Boolean}\n           */\n          searchable: true,\n\n          /**\n           * Enable disable the clear button\n           * @type {Boolean}\n           */\n          clearable: false,\n\n          /**\n           * Sort the tags / multiselect options\n           * @type {Boolean}\n           */\n          sortSelected: false,\n\n          /**\n           * Allow deselecting of select-one options\n           * @type {Boolean}\n           */\n          allowDeselect: false,\n\n          /**\n           * Close the dropdown when scrolling (@AlexanderReiswich, #11)\n           * @type {Boolean}\n           */\n          closeOnScroll: false,\n\n          /**\n           * Allow the use of the native dropdown (@jonnyscholes, #14)\n           * @type {Boolean}\n           */\n          nativeDropdown: false,\n\n          /**\n           * Set the main placeholder\n           * @type {String}\n           */\n          placeholder: \"Select an option...\",\n\n          /**\n           * Allow the tagging feature\n           * @type {Boolean}\n           */\n          taggable: false,\n\n          /**\n           * Set the tag input placeholder (@labikmartin, #21, #22)\n           * @type {String}\n           */\n          tagPlaceholder: \"Enter a tag...\"\n        };\n        /**\n         * Event Emitter\n         */\n\n        var Events = function Events() {};\n        /**\n         * Event Prototype\n         * @type {Object}\n         */\n\n\n        Events.prototype = {\n          /**\n           * Add custom event listener\n           * @param  {String} event Event type\n           * @param  {Function} func   Callback\n           * @return {Void}\n           */\n          on: function on(event, func) {\n            this._events = this._events || {};\n            this._events[event] = this._events[event] || [];\n\n            this._events[event].push(func);\n          },\n\n          /**\n           * Remove custom event listener\n           * @param  {String} event Event type\n           * @param  {Function} func   Callback\n           * @return {Void}\n           */\n          off: function off(event, func) {\n            this._events = this._events || {};\n            if (event in this._events === false) return;\n\n            this._events[event].splice(this._events[event].indexOf(func), 1);\n          },\n\n          /**\n           * Fire a custom event\n           * @param  {String} event Event type\n           * @return {Void}\n           */\n          emit: function emit(event\n          /* , args... */\n          ) {\n            this._events = this._events || {};\n            if (event in this._events === false) return;\n\n            for (var i = 0; i < this._events[event].length; i++) {\n              this._events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));\n            }\n          }\n        };\n        /**\n         * Event mixin\n         * @param  {Object} obj\n         * @return {Object}\n         */\n\n        Events.mixin = function (obj) {\n          var props = ['on', 'off', 'emit'];\n\n          for (var i = 0; i < props.length; i++) {\n            if (typeof obj === 'function') {\n              obj.prototype[props[i]] = Events.prototype[props[i]];\n            } else {\n              obj[props[i]] = Events.prototype[props[i]];\n            }\n          }\n\n          return obj;\n        };\n        /**\n         * Helpers\n         * @type {Object}\n         */\n\n\n        var util = {\n          extend: function extend(src, props) {\n            props = props || {};\n            var p;\n\n            for (p in src) {\n              if (src.hasOwnProperty(p)) {\n                if (!props.hasOwnProperty(p)) {\n                  props[p] = src[p];\n                }\n              }\n            }\n\n            return props;\n          },\n          each: function each(a, b, c) {\n            if (\"[object Object]\" === Object.prototype.toString.call(a)) {\n              for (var d in a) {\n                if (Object.prototype.hasOwnProperty.call(a, d)) {\n                  b.call(c, d, a[d], a);\n                }\n              }\n            } else {\n              for (var e = 0, f = a.length; e < f; e++) {\n                b.call(c, e, a[e], a);\n              }\n            }\n          },\n          createElement: function createElement(e, a) {\n            var d = document,\n                el = d.createElement(e);\n\n            if (a && \"[object Object]\" === Object.prototype.toString.call(a)) {\n              var i;\n\n              for (i in a) {\n                if (i in el) el[i] = a[i];else if (\"html\" === i) el.innerHTML = a[i];else if (\"text\" === i) {\n                  var t = d.createTextNode(a[i]);\n                  el.appendChild(t);\n                } else el.setAttribute(i, a[i]);\n              }\n            }\n\n            return el;\n          },\n          hasClass: function hasClass(a, b) {\n            if (a) return a.classList ? a.classList.contains(b) : !!a.className && !!a.className.match(new RegExp(\"(\\\\s|^)\" + b + \"(\\\\s|$)\"));\n          },\n          addClass: function addClass(a, b) {\n            if (!util.hasClass(a, b)) {\n              if (a.classList) {\n                a.classList.add(b);\n              } else {\n                a.className = a.className.trim() + \" \" + b;\n              }\n            }\n          },\n          removeClass: function removeClass(a, b) {\n            if (util.hasClass(a, b)) {\n              if (a.classList) {\n                a.classList.remove(b);\n              } else {\n                a.className = a.className.replace(new RegExp(\"(^|\\\\s)\" + b.split(\" \").join(\"|\") + \"(\\\\s|$)\", \"gi\"), \" \");\n              }\n            }\n          },\n          closest: function closest(el, fn) {\n            return el && el !== document.body && (fn(el) ? el : util.closest(el.parentNode, fn));\n          },\n          isInt: function isInt(val) {\n            return typeof val === 'number' && isFinite(val) && Math.floor(val) === val;\n          },\n          debounce: function debounce(a, b, c) {\n            var d;\n            return function () {\n              var e = this,\n                  f = arguments,\n                  g = function g() {\n                d = null;\n                if (!c) a.apply(e, f);\n              },\n                  h = c && !d;\n\n              clearTimeout(d);\n              d = setTimeout(g, b);\n\n              if (h) {\n                a.apply(e, f);\n              }\n            };\n          },\n          rect: function rect(el, abs) {\n            var w = window;\n            var r = el.getBoundingClientRect();\n            var x = abs ? w.pageXOffset : 0;\n            var y = abs ? w.pageYOffset : 0;\n            return {\n              bottom: r.bottom + y,\n              height: r.height,\n              left: r.left + x,\n              right: r.right + x,\n              top: r.top + y,\n              width: r.width\n            };\n          },\n          includes: function includes(a, b) {\n            return a.indexOf(b) > -1;\n          },\n          truncate: function truncate(el) {\n            while (el.firstChild) {\n              el.removeChild(el.firstChild);\n            }\n          }\n        };\n\n        function isset(obj, prop) {\n          return obj.hasOwnProperty(prop) && (obj[prop] === true || obj[prop].length);\n        }\n        /**\n         * Append an item to the list\n         * @param  {Object} item\n         * @param  {Object} custom\n         * @return {Void}\n         */\n\n\n        function appendItem(item, parent, custom) {\n          if (item.parentNode) {\n            if (!item.parentNode.parentNode) {\n              parent.appendChild(item.parentNode);\n            }\n          } else {\n            parent.appendChild(item);\n          }\n\n          util.removeClass(item, \"excluded\");\n\n          if (!custom) {\n            item.innerHTML = item.textContent;\n          }\n        }\n        /**\n         * Render the item list\n         * @return {Void}\n         */\n\n\n        var render = function render() {\n          if (this.items.length) {\n            var f = document.createDocumentFragment();\n\n            if (this.config.pagination) {\n              var pages = this.pages.slice(0, this.pageIndex);\n              util.each(pages, function (i, items) {\n                util.each(items, function (j, item) {\n                  appendItem(item, f, this.customOption);\n                }, this);\n              }, this);\n            } else {\n              util.each(this.items, function (i, item) {\n                appendItem(item, f, this.customOption);\n              }, this);\n            }\n\n            if (f.childElementCount) {\n              util.removeClass(this.items[this.navIndex], \"active\");\n              this.navIndex = f.querySelector(\".selectr-option\").idx;\n              util.addClass(this.items[this.navIndex], \"active\");\n            }\n\n            this.tree.appendChild(f);\n          }\n        };\n        /**\n         * Dismiss / close the dropdown\n         * @param  {obj} e\n         * @return {void}\n         */\n\n\n        var dismiss = function dismiss(e) {\n          var target = e.target;\n\n          if (!this.container.contains(target) && (this.opened || util.hasClass(this.container, \"notice\"))) {\n            this.close();\n          }\n        };\n        /**\n         * Build a list item from the HTMLOptionElement\n         * @param  {int} i      HTMLOptionElement index\n         * @param  {HTMLOptionElement} option\n         * @param  {bool} group  Has parent optgroup\n         * @return {void}\n         */\n\n\n        var createItem = function createItem(option, data) {\n          data = data || option;\n          var content = this.customOption ? this.config.renderOption(data) : option.textContent;\n          var opt = util.createElement(\"li\", {\n            \"class\": \"selectr-option\",\n            html: content,\n            role: \"treeitem\",\n            \"aria-selected\": false\n          });\n          opt.idx = option.idx;\n          this.items.push(opt);\n\n          if (option.defaultSelected) {\n            this.defaultSelected.push(option.idx);\n          }\n\n          if (option.disabled) {\n            opt.disabled = true;\n            util.addClass(opt, \"disabled\");\n          }\n\n          return opt;\n        };\n        /**\n         * Build the container\n         * @return {Void}\n         */\n\n\n        var build = function build() {\n          this.requiresPagination = this.config.pagination && this.config.pagination > 0; // Set width\n\n          if (isset(this.config, \"width\")) {\n            if (util.isInt(this.config.width)) {\n              this.width = this.config.width + \"px\";\n            } else {\n              if (this.config.width === \"auto\") {\n                this.width = \"100%\";\n              } else if (util.includes(this.config.width, \"%\")) {\n                this.width = this.config.width;\n              }\n            }\n          }\n\n          this.container = util.createElement(\"div\", {\n            \"class\": \"selectr-container\"\n          }); // Custom className\n\n          if (this.config.customClass) {\n            util.addClass(this.container, this.config.customClass);\n          } // Mobile device\n\n\n          if (this.mobileDevice) {\n            util.addClass(this.container, \"selectr-mobile\");\n          } else {\n            util.addClass(this.container, \"selectr-desktop\");\n          } // Hide the HTMLSelectElement and prevent focus\n\n\n          this.el.tabIndex = -1; // Native dropdown\n\n          if (this.config.nativeDropdown || this.mobileDevice) {\n            util.addClass(this.el, \"selectr-visible\");\n          } else {\n            util.addClass(this.el, \"selectr-hidden\");\n          }\n\n          this.selected = util.createElement(\"div\", {\n            \"class\": \"selectr-selected\",\n            disabled: this.disabled,\n            tabIndex: 1,\n            // enable tabIndex (#9)\n            \"aria-expanded\": false\n          });\n          this.label = util.createElement(this.el.multiple ? \"ul\" : \"span\", {\n            \"class\": \"selectr-label\"\n          });\n          var dropdown = util.createElement(\"div\", {\n            \"class\": \"selectr-options-container\"\n          });\n          this.tree = util.createElement(\"ul\", {\n            \"class\": \"selectr-options\",\n            role: \"tree\",\n            \"aria-hidden\": true,\n            \"aria-expanded\": false\n          });\n          this.notice = util.createElement(\"div\", {\n            \"class\": \"selectr-notice\"\n          });\n          this.el.setAttribute(\"aria-hidden\", true);\n\n          if (this.disabled) {\n            this.el.disabled = true;\n          }\n\n          if (this.el.multiple) {\n            util.addClass(this.label, \"selectr-tags\");\n            util.addClass(this.container, \"multiple\"); // Collection of tags\n\n            this.tags = []; // Collection of selected values\n\n            this.selectedValues = this.getSelectedProperties('value'); // Collection of selected indexes\n\n            this.selectedIndexes = this.getSelectedProperties('idx');\n          }\n\n          this.selected.appendChild(this.label);\n\n          if (this.config.clearable) {\n            this.selectClear = util.createElement(\"button\", {\n              \"class\": \"selectr-clear\",\n              type: \"button\"\n            });\n            this.container.appendChild(this.selectClear);\n            util.addClass(this.container, \"clearable\");\n          }\n\n          if (this.config.taggable) {\n            var li = util.createElement('li', {\n              \"class\": 'input-tag'\n            });\n            this.input = util.createElement(\"input\", {\n              \"class\": \"selectr-tag-input\",\n              placeholder: this.config.tagPlaceholder,\n              tagIndex: 0,\n              autocomplete: \"off\",\n              autocorrect: \"off\",\n              autocapitalize: \"off\",\n              spellcheck: \"false\",\n              role: \"textbox\",\n              type: \"search\"\n            });\n            li.appendChild(this.input);\n            this.label.appendChild(li);\n            util.addClass(this.container, \"taggable\");\n            this.tagSeperators = [\",\"];\n\n            if (this.config.tagSeperators) {\n              this.tagSeperators = this.tagSeperators.concat(this.config.tagSeperators);\n            }\n          }\n\n          if (this.config.searchable) {\n            this.input = util.createElement(\"input\", {\n              \"class\": \"selectr-input\",\n              tagIndex: -1,\n              autocomplete: \"off\",\n              autocorrect: \"off\",\n              autocapitalize: \"off\",\n              spellcheck: \"false\",\n              role: \"textbox\",\n              type: \"search\"\n            });\n            this.inputClear = util.createElement(\"button\", {\n              \"class\": \"selectr-input-clear\",\n              type: \"button\"\n            });\n            this.inputContainer = util.createElement(\"div\", {\n              \"class\": \"selectr-input-container\"\n            });\n            this.inputContainer.appendChild(this.input);\n            this.inputContainer.appendChild(this.inputClear);\n            dropdown.appendChild(this.inputContainer);\n          }\n\n          dropdown.appendChild(this.notice);\n          dropdown.appendChild(this.tree); // List of items for the dropdown\n\n          this.items = []; // Establish options\n\n          this.options = []; // Check for options in the element\n\n          if (this.el.options.length) {\n            this.options = [].slice.call(this.el.options);\n          } // Element may have optgroups so\n          // iterate element.children instead of element.options\n\n\n          var group = false,\n              j = 0;\n\n          if (this.el.children.length) {\n            util.each(this.el.children, function (i, element) {\n              if (element.nodeName === \"OPTGROUP\") {\n                group = util.createElement(\"ul\", {\n                  \"class\": \"selectr-optgroup\",\n                  role: \"group\",\n                  html: \"<li class='selectr-optgroup--label'>\" + element.label + \"</li>\"\n                });\n                util.each(element.children, function (x, el) {\n                  el.idx = j;\n                  group.appendChild(createItem.call(this, el, group));\n                  j++;\n                }, this);\n              } else {\n                element.idx = j;\n                createItem.call(this, element);\n                j++;\n              }\n            }, this);\n          } // Options defined by the data option\n\n\n          if (this.config.data && Array.isArray(this.config.data)) {\n            this.data = [];\n            var optgroup = false,\n                option;\n            group = false;\n            j = 0;\n            util.each(this.config.data, function (i, opt) {\n              // Check for group options\n              if (isset(opt, \"children\")) {\n                optgroup = util.createElement(\"optgroup\", {\n                  label: opt.text\n                });\n                group = util.createElement(\"ul\", {\n                  \"class\": \"selectr-optgroup\",\n                  role: \"group\",\n                  html: \"<li class='selectr-optgroup--label'>\" + opt.text + \"</li>\"\n                });\n                util.each(opt.children, function (x, data) {\n                  option = new Option(data.text, data.value, false, data.hasOwnProperty(\"selected\") && data.selected === true);\n                  option.disabled = isset(data, \"disabled\");\n                  this.options.push(option);\n                  optgroup.appendChild(option);\n                  option.idx = j;\n                  group.appendChild(createItem.call(this, option, data));\n                  this.data[j] = data;\n                  j++;\n                }, this);\n              } else {\n                option = new Option(opt.text, opt.value, false, opt.hasOwnProperty(\"selected\") && opt.selected === true);\n                option.disabled = isset(opt, \"disabled\");\n                this.options.push(option);\n                option.idx = j;\n                createItem.call(this, option, opt);\n                this.data[j] = opt;\n                j++;\n              }\n            }, this);\n          }\n\n          this.setSelected(true);\n          var first;\n          this.navIndex = 0;\n\n          for (var i = 0; i < this.items.length; i++) {\n            first = this.items[i];\n\n            if (!util.hasClass(first, \"disabled\")) {\n              util.addClass(first, \"active\");\n              this.navIndex = i;\n              break;\n            }\n          } // Check for pagination / infinite scroll\n\n\n          if (this.requiresPagination) {\n            this.pageIndex = 1; // Create the pages\n\n            this.paginate();\n          }\n\n          this.container.appendChild(this.selected);\n          this.container.appendChild(dropdown);\n          this.placeEl = util.createElement(\"div\", {\n            \"class\": \"selectr-placeholder\"\n          }); // Set the placeholder\n\n          this.setPlaceholder();\n          this.selected.appendChild(this.placeEl); // Disable if required\n\n          if (this.disabled) {\n            this.disable();\n          }\n\n          this.el.parentNode.insertBefore(this.container, this.el);\n          this.container.appendChild(this.el);\n        };\n        /**\n         * Navigate through the dropdown\n         * @param  {obj} e\n         * @return {void}\n         */\n\n\n        var navigate = function navigate(e) {\n          e = e || window.event; // Filter out the keys we don\"t want\n\n          if (!this.items.length || !this.opened || !util.includes([13, 38, 40], e.which)) {\n            this.navigating = false;\n            return;\n          }\n\n          e.preventDefault();\n\n          if (e.which === 13) {\n            if (this.config.taggable && this.input.value.length > 0) {\n              return false;\n            }\n\n            return this.change(this.navIndex);\n          }\n\n          var direction,\n              prevEl = this.items[this.navIndex];\n\n          switch (e.which) {\n            case 38:\n              direction = 0;\n\n              if (this.navIndex > 0) {\n                this.navIndex--;\n              }\n\n              break;\n\n            case 40:\n              direction = 1;\n\n              if (this.navIndex < this.items.length - 1) {\n                this.navIndex++;\n              }\n\n          }\n\n          this.navigating = true; // Instead of wasting memory holding a copy of this.items\n          // with disabled / excluded options omitted, skip them instead\n\n          while (util.hasClass(this.items[this.navIndex], \"disabled\") || util.hasClass(this.items[this.navIndex], \"excluded\")) {\n            if (direction) {\n              this.navIndex++;\n            } else {\n              this.navIndex--;\n            }\n\n            if (this.searching) {\n              if (this.navIndex > this.tree.lastElementChild.idx) {\n                this.navIndex = this.tree.lastElementChild.idx;\n                break;\n              } else if (this.navIndex < this.tree.firstElementChild.idx) {\n                this.navIndex = this.tree.firstElementChild.idx;\n                break;\n              }\n            }\n          } // Autoscroll the dropdown during navigation\n\n\n          var r = util.rect(this.items[this.navIndex]);\n\n          if (!direction) {\n            if (this.navIndex === 0) {\n              this.tree.scrollTop = 0;\n            } else if (r.top - this.optsRect.top < 0) {\n              this.tree.scrollTop = this.tree.scrollTop + (r.top - this.optsRect.top);\n            }\n          } else {\n            if (this.navIndex === 0) {\n              this.tree.scrollTop = 0;\n            } else if (r.top + r.height > this.optsRect.top + this.optsRect.height) {\n              this.tree.scrollTop = this.tree.scrollTop + (r.top + r.height - (this.optsRect.top + this.optsRect.height));\n            } // Load another page if needed\n\n\n            if (this.navIndex === this.tree.childElementCount - 1 && this.requiresPagination) {\n              load.call(this);\n            }\n          }\n\n          if (prevEl) {\n            util.removeClass(prevEl, \"active\");\n          }\n\n          util.addClass(this.items[this.navIndex], \"active\");\n        };\n        /**\n         * Add a tag\n         * @param  {HTMLElement} item\n         */\n\n\n        var addTag = function addTag(item) {\n          var that = this,\n              r;\n          var docFrag = document.createDocumentFragment();\n          var option = this.options[item.idx];\n          var data = this.data ? this.data[item.idx] : option;\n          var content = this.customSelected ? this.config.renderSelection(data) : option.textContent;\n          var tag = util.createElement(\"li\", {\n            \"class\": \"selectr-tag\",\n            html: content\n          });\n          var btn = util.createElement(\"button\", {\n            \"class\": \"selectr-tag-remove\",\n            type: \"button\"\n          });\n          tag.appendChild(btn); // Set property to check against later\n\n          tag.idx = item.idx;\n          tag.tag = option.value;\n          this.tags.push(tag);\n\n          if (this.config.sortSelected) {\n            var tags = this.tags.slice(); // Deal with values that contain numbers\n\n            r = function r(val, arr) {\n              val.replace(/(\\d+)|(\\D+)/g, function (that, $1, $2) {\n                arr.push([$1 || Infinity, $2 || \"\"]);\n              });\n            };\n\n            tags.sort(function (a, b) {\n              var x = [],\n                  y = [],\n                  ac,\n                  bc;\n\n              if (that.config.sortSelected === true) {\n                ac = a.tag;\n                bc = b.tag;\n              } else if (that.config.sortSelected === 'text') {\n                ac = a.textContent;\n                bc = b.textContent;\n              }\n\n              r(ac, x);\n              r(bc, y);\n\n              while (x.length && y.length) {\n                var ax = x.shift();\n                var by = y.shift();\n                var nn = ax[0] - by[0] || ax[1].localeCompare(by[1]);\n                if (nn) return nn;\n              }\n\n              return x.length - y.length;\n            });\n            util.each(tags, function (i, tg) {\n              docFrag.appendChild(tg);\n            });\n            this.label.innerHTML = \"\";\n          } else {\n            docFrag.appendChild(tag);\n          }\n\n          if (this.config.taggable) {\n            this.label.insertBefore(docFrag, this.input.parentNode);\n          } else {\n            this.label.appendChild(docFrag);\n          }\n        };\n        /**\n         * Remove a tag\n         * @param  {HTMLElement} item\n         * @return {void}\n         */\n\n\n        var removeTag = function removeTag(item) {\n          var tag = false;\n          util.each(this.tags, function (i, t) {\n            if (t.idx === item.idx) {\n              tag = t;\n            }\n          }, this);\n\n          if (tag) {\n            this.label.removeChild(tag);\n            this.tags.splice(this.tags.indexOf(tag), 1);\n          }\n        };\n        /**\n         * Load the next page of items\n         * @return {void}\n         */\n\n\n        var load = function load() {\n          var tree = this.tree;\n          var scrollTop = tree.scrollTop;\n          var scrollHeight = tree.scrollHeight;\n          var offsetHeight = tree.offsetHeight;\n          var atBottom = scrollTop >= scrollHeight - offsetHeight;\n\n          if (atBottom && this.pageIndex < this.pages.length) {\n            var f = document.createDocumentFragment();\n            util.each(this.pages[this.pageIndex], function (i, item) {\n              appendItem(item, f, this.customOption);\n            }, this);\n            tree.appendChild(f);\n            this.pageIndex++;\n            this.emit(\"selectr.paginate\", {\n              items: this.items.length,\n              total: this.data.length,\n              page: this.pageIndex,\n              pages: this.pages.length\n            });\n          }\n        };\n        /**\n         * Clear a search\n         * @return {void}\n         */\n\n\n        var clearSearch = function clearSearch() {\n          if (this.config.searchable || this.config.taggable) {\n            this.input.value = null;\n            this.searching = false;\n\n            if (this.config.searchable) {\n              util.removeClass(this.inputContainer, \"active\");\n            }\n\n            if (util.hasClass(this.container, \"notice\")) {\n              util.removeClass(this.container, \"notice\");\n              util.addClass(this.container, \"open\");\n              this.input.focus();\n            }\n\n            util.each(this.items, function (i, item) {\n              // Items that didn't match need the class\n              // removing to make them visible again\n              util.removeClass(item, \"excluded\"); // Remove the span element for underlining matched items\n\n              if (!this.customOption) {\n                item.innerHTML = item.textContent;\n              }\n            }, this);\n          }\n        };\n        /**\n         * Query matching for searches\n         * @param  {string} query\n         * @param  {HTMLOptionElement} option\n         * @return {bool}\n         */\n\n\n        var match = function match(query, option) {\n          var result = new RegExp(query, \"i\").exec(option.textContent);\n\n          if (result) {\n            return option.textContent.replace(result[0], \"<span class='selectr-match'>\" + result[0] + \"</span>\");\n          }\n\n          return false;\n        }; // Main Lib\n\n\n        var Selectr = function Selectr(el, config) {\n          config = config || {};\n\n          if (!el) {\n            throw new Error(\"You must supply either a HTMLSelectElement or a CSS3 selector string.\");\n          }\n\n          this.el = el; // CSS3 selector string\n\n          if (typeof el === \"string\") {\n            this.el = document.querySelector(el);\n          }\n\n          if (this.el === null) {\n            throw new Error(\"The element you passed to Selectr can not be found.\");\n          }\n\n          if (this.el.nodeName.toLowerCase() !== \"select\") {\n            throw new Error(\"The element you passed to Selectr is not a HTMLSelectElement.\");\n          }\n\n          this.render(config);\n        };\n        /**\n         * Render the instance\n         * @param  {object} config\n         * @return {void}\n         */\n\n\n        Selectr.prototype.render = function (config) {\n          if (this.rendered) return; // Merge defaults with user set config\n\n          this.config = util.extend(defaultConfig, config); // Store type\n\n          this.originalType = this.el.type; // Store tabIndex\n\n          this.originalIndex = this.el.tabIndex; // Store defaultSelected options for form reset\n\n          this.defaultSelected = []; // Store the original option count\n\n          this.originalOptionCount = this.el.options.length;\n\n          if (this.config.multiple || this.config.taggable) {\n            this.el.multiple = true;\n          } // Disabled?\n\n\n          this.disabled = isset(this.config, \"disabled\");\n          this.opened = false;\n\n          if (this.config.taggable) {\n            this.config.searchable = false;\n          }\n\n          this.navigating = false;\n          this.mobileDevice = false;\n\n          if (/Android|webOS|iPhone|iPad|BlackBerry|Windows Phone|Opera Mini|IEMobile|Mobile/i.test(navigator.userAgent)) {\n            this.mobileDevice = true;\n          }\n\n          this.customOption = this.config.hasOwnProperty(\"renderOption\") && typeof this.config.renderOption === \"function\";\n          this.customSelected = this.config.hasOwnProperty(\"renderSelection\") && typeof this.config.renderSelection === \"function\"; // Enable event emitter\n\n          Events.mixin(this);\n          build.call(this);\n          this.bindEvents();\n          this.update();\n          this.optsRect = util.rect(this.tree);\n          this.rendered = true; // Fixes macOS Safari bug #28\n\n          if (!this.el.multiple) {\n            this.el.selectedIndex = this.selectedIndex;\n          }\n\n          var that = this;\n          setTimeout(function () {\n            that.emit(\"selectr.init\");\n          }, 20);\n        };\n\n        Selectr.prototype.getSelected = function () {\n          var selected = this.el.querySelectorAll('option:checked');\n          return selected;\n        };\n\n        Selectr.prototype.getSelectedProperties = function (prop) {\n          var selected = this.getSelected();\n          var values = [].slice.call(selected).map(function (option) {\n            return option[prop];\n          }).filter(function (i) {\n            return i !== null && i !== undefined;\n          });\n          return values;\n        };\n        /**\n         * Attach the required event listeners\n         */\n\n\n        Selectr.prototype.bindEvents = function () {\n          var that = this;\n          this.events = {};\n          this.events.dismiss = dismiss.bind(this);\n          this.events.navigate = navigate.bind(this);\n          this.events.reset = this.reset.bind(this);\n\n          if (this.config.nativeDropdown || this.mobileDevice) {\n            this.container.addEventListener(\"touchstart\", function (e) {\n              if (e.changedTouches[0].target === that.el) {\n                that.toggle();\n              }\n            });\n\n            if (this.config.nativeDropdown || this.mobileDevice) {\n              this.container.addEventListener(\"click\", function (e) {\n                e.preventDefault(); // Jos: Added to prevent emitting clear directly after select\n\n                e.stopPropagation(); // Jos: Added to prevent emitting clear directly after select\n\n                if (e.target === that.el) {\n                  that.toggle();\n                }\n              });\n            }\n\n            var getChangedOptions = function getChangedOptions(last, current) {\n              var added = [],\n                  removed = last.slice(0);\n              var idx;\n\n              for (var i = 0; i < current.length; i++) {\n                idx = removed.indexOf(current[i]);\n                if (idx > -1) removed.splice(idx, 1);else added.push(current[i]);\n              }\n\n              return [added, removed];\n            }; // Listen for the change on the native select\n            // and update accordingly\n\n\n            this.el.addEventListener(\"change\", function (e) {\n              if (that.el.multiple) {\n                var indexes = that.getSelectedProperties('idx');\n                var changes = getChangedOptions(that.selectedIndexes, indexes);\n                util.each(changes[0], function (i, idx) {\n                  that.select(idx);\n                }, that);\n                util.each(changes[1], function (i, idx) {\n                  that.deselect(idx);\n                }, that);\n              } else {\n                if (that.el.selectedIndex > -1) {\n                  that.select(that.el.selectedIndex);\n                }\n              }\n            });\n          } // Open the dropdown with Enter key if focused\n\n\n          if (this.config.nativeDropdown) {\n            this.container.addEventListener(\"keydown\", function (e) {\n              if (e.key === \"Enter\" && that.selected === document.activeElement) {\n                // Show the native\n                that.toggle(); // Focus on the native multiselect\n\n                setTimeout(function () {\n                  that.el.focus();\n                }, 200);\n              }\n            });\n          } // Non-native dropdown\n\n\n          this.selected.addEventListener(\"click\", function (e) {\n            if (!that.disabled) {\n              that.toggle();\n            }\n\n            e.preventDefault();\n            e.stopPropagation(); // Jos: Added to prevent emitting clear directly after select\n          }); // Remove tag\n\n          this.label.addEventListener(\"click\", function (e) {\n            if (util.hasClass(e.target, \"selectr-tag-remove\")) {\n              that.deselect(e.target.parentNode.idx);\n            }\n          }); // Clear input\n\n          if (this.selectClear) {\n            this.selectClear.addEventListener(\"click\", this.clear.bind(this));\n          } // Prevent text selection\n\n\n          this.tree.addEventListener(\"mousedown\", function (e) {\n            e.preventDefault();\n          }); // Select / deselect items\n\n          this.tree.addEventListener(\"click\", function (e) {\n            e.preventDefault(); // Jos: Added to prevent emitting clear directly after select\n\n            e.stopPropagation(); // Jos: Added to prevent emitting clear directly after select\n\n            var item = util.closest(e.target, function (el) {\n              return el && util.hasClass(el, \"selectr-option\");\n            });\n\n            if (item) {\n              if (!util.hasClass(item, \"disabled\")) {\n                if (util.hasClass(item, \"selected\")) {\n                  if (that.el.multiple || !that.el.multiple && that.config.allowDeselect) {\n                    that.deselect(item.idx);\n                  }\n                } else {\n                  that.select(item.idx);\n                }\n\n                if (that.opened && !that.el.multiple) {\n                  that.close();\n                }\n              }\n            }\n          }); // Mouseover list items\n\n          this.tree.addEventListener(\"mouseover\", function (e) {\n            if (util.hasClass(e.target, \"selectr-option\")) {\n              if (!util.hasClass(e.target, \"disabled\")) {\n                util.removeClass(that.items[that.navIndex], \"active\");\n                util.addClass(e.target, \"active\");\n                that.navIndex = [].slice.call(that.items).indexOf(e.target);\n              }\n            }\n          }); // Searchable\n\n          if (this.config.searchable) {\n            // Show / hide the search input clear button\n            this.input.addEventListener(\"focus\", function (e) {\n              that.searching = true;\n            });\n            this.input.addEventListener(\"blur\", function (e) {\n              that.searching = false;\n            });\n            this.input.addEventListener(\"keyup\", function (e) {\n              that.search();\n\n              if (!that.config.taggable) {\n                // Show / hide the search input clear button\n                if (this.value.length) {\n                  util.addClass(this.parentNode, \"active\");\n                } else {\n                  util.removeClass(this.parentNode, \"active\");\n                }\n              }\n            }); // Clear the search input\n\n            this.inputClear.addEventListener(\"click\", function (e) {\n              that.input.value = null;\n              clearSearch.call(that);\n\n              if (!that.tree.childElementCount) {\n                render.call(that);\n              }\n            });\n          }\n\n          if (this.config.taggable) {\n            this.input.addEventListener(\"keyup\", function (e) {\n              that.search();\n\n              if (that.config.taggable && this.value.length) {\n                var val = this.value.trim();\n\n                if (e.which === 13 || util.includes(that.tagSeperators, e.key)) {\n                  util.each(that.tagSeperators, function (i, k) {\n                    val = val.replace(k, '');\n                  });\n                  var option = that.add({\n                    value: val,\n                    text: val,\n                    selected: true\n                  }, true);\n\n                  if (!option) {\n                    this.value = '';\n                    that.setMessage('That tag is already in use.');\n                  } else {\n                    that.close();\n                    clearSearch.call(that);\n                  }\n                }\n              }\n            });\n          }\n\n          this.update = util.debounce(function () {\n            // Optionally close dropdown on scroll / resize (#11)\n            if (that.opened && that.config.closeOnScroll) {\n              that.close();\n            }\n\n            if (that.width) {\n              that.container.style.width = that.width;\n            }\n\n            that.invert();\n          }, 50);\n\n          if (this.requiresPagination) {\n            this.paginateItems = util.debounce(function () {\n              load.call(this);\n            }, 50);\n            this.tree.addEventListener(\"scroll\", this.paginateItems.bind(this));\n          } // Dismiss when clicking outside the container\n\n\n          document.addEventListener(\"click\", this.events.dismiss);\n          window.addEventListener(\"keydown\", this.events.navigate);\n          window.addEventListener(\"resize\", this.update);\n          window.addEventListener(\"scroll\", this.update); // Listen for form.reset() (@ambrooks, #13)\n\n          if (this.el.form) {\n            this.el.form.addEventListener(\"reset\", this.events.reset);\n          }\n        };\n        /**\n         * Check for selected options\n         * @param {bool} reset\n         */\n\n\n        Selectr.prototype.setSelected = function (reset) {\n          // Select first option as with a native select-one element - #21, #24\n          if (!this.config.data && !this.el.multiple && this.el.options.length) {\n            // Browser has selected the first option by default\n            if (this.el.selectedIndex === 0) {\n              if (!this.el.options[0].defaultSelected && !this.config.defaultSelected) {\n                this.el.selectedIndex = -1;\n              }\n            }\n\n            this.selectedIndex = this.el.selectedIndex;\n\n            if (this.selectedIndex > -1) {\n              this.select(this.selectedIndex);\n            }\n          } // If we're changing a select-one to select-multiple via the config\n          // and there are no selected options, the first option will be selected by the browser\n          // Let's prevent that here.\n\n\n          if (this.config.multiple && this.originalType === \"select-one\" && !this.config.data) {\n            if (this.el.options[0].selected && !this.el.options[0].defaultSelected) {\n              this.el.options[0].selected = false;\n            }\n          }\n\n          util.each(this.options, function (i, option) {\n            if (option.selected && option.defaultSelected) {\n              this.select(option.idx);\n            }\n          }, this);\n\n          if (this.config.selectedValue) {\n            this.setValue(this.config.selectedValue);\n          }\n\n          if (this.config.data) {\n            if (!this.el.multiple && this.config.defaultSelected && this.el.selectedIndex < 0) {\n              this.select(0);\n            }\n\n            var j = 0;\n            util.each(this.config.data, function (i, opt) {\n              // Check for group options\n              if (isset(opt, \"children\")) {\n                util.each(opt.children, function (x, item) {\n                  if (item.hasOwnProperty(\"selected\") && item.selected === true) {\n                    this.select(j);\n                  }\n\n                  j++;\n                }, this);\n              } else {\n                if (opt.hasOwnProperty(\"selected\") && opt.selected === true) {\n                  this.select(j);\n                }\n\n                j++;\n              }\n            }, this);\n          }\n        };\n        /**\n         * Destroy the instance\n         * @return {void}\n         */\n\n\n        Selectr.prototype.destroy = function () {\n          if (!this.rendered) return;\n          this.emit(\"selectr.destroy\"); // Revert to select-single if programtically set to multiple\n\n          if (this.originalType === 'select-one') {\n            this.el.multiple = false;\n          }\n\n          if (this.config.data) {\n            this.el.innerHTML = \"\";\n          } // Remove the className from select element\n\n\n          util.removeClass(this.el, 'selectr-hidden'); // Remove reset listener from parent form\n\n          if (this.el.form) {\n            util.off(this.el.form, \"reset\", this.events.reset);\n          } // Remove event listeners attached to doc and win\n\n\n          util.off(document, \"click\", this.events.dismiss);\n          util.off(document, \"keydown\", this.events.navigate);\n          util.off(window, \"resize\", this.update);\n          util.off(window, \"scroll\", this.update); // Replace the container with the original select element\n\n          this.container.parentNode.replaceChild(this.el, this.container);\n          this.rendered = false;\n        };\n        /**\n         * Change an options state\n         * @param  {Number} index\n         * @return {void}\n         */\n\n\n        Selectr.prototype.change = function (index) {\n          var item = this.items[index],\n              option = this.options[index];\n\n          if (option.disabled) {\n            return;\n          }\n\n          if (option.selected && util.hasClass(item, \"selected\")) {\n            this.deselect(index);\n          } else {\n            this.select(index);\n          }\n\n          if (this.opened && !this.el.multiple) {\n            this.close();\n          }\n        };\n        /**\n         * Select an option\n         * @param  {Number} index\n         * @return {void}\n         */\n\n\n        Selectr.prototype.select = function (index) {\n          var item = this.items[index],\n              options = [].slice.call(this.el.options),\n              option = this.options[index];\n\n          if (this.el.multiple) {\n            if (util.includes(this.selectedIndexes, index)) {\n              return false;\n            }\n\n            if (this.config.maxSelections && this.tags.length === this.config.maxSelections) {\n              this.setMessage(\"A maximum of \" + this.config.maxSelections + \" items can be selected.\", true);\n              return false;\n            }\n\n            this.selectedValues.push(option.value);\n            this.selectedIndexes.push(index);\n            addTag.call(this, item);\n          } else {\n            var data = this.data ? this.data[index] : option;\n            this.label.innerHTML = this.customSelected ? this.config.renderSelection(data) : option.textContent;\n            this.selectedValue = option.value;\n            this.selectedIndex = index;\n            util.each(this.options, function (i, o) {\n              var opt = this.items[i];\n\n              if (i !== index) {\n                if (opt) {\n                  util.removeClass(opt, \"selected\");\n                }\n\n                o.selected = false;\n                o.removeAttribute(\"selected\");\n              }\n            }, this);\n          }\n\n          if (!util.includes(options, option)) {\n            this.el.add(option);\n          }\n\n          item.setAttribute(\"aria-selected\", true);\n          util.addClass(item, \"selected\");\n          util.addClass(this.container, \"has-selected\");\n          option.selected = true;\n          option.setAttribute(\"selected\", \"\");\n          this.emit(\"selectr.change\", option);\n          this.emit(\"selectr.select\", option);\n        };\n        /**\n         * Deselect an option\n         * @param  {Number} index\n         * @return {void}\n         */\n\n\n        Selectr.prototype.deselect = function (index, force) {\n          var item = this.items[index],\n              option = this.options[index];\n\n          if (this.el.multiple) {\n            var selIndex = this.selectedIndexes.indexOf(index);\n            this.selectedIndexes.splice(selIndex, 1);\n            var valIndex = this.selectedValues.indexOf(option.value);\n            this.selectedValues.splice(valIndex, 1);\n            removeTag.call(this, item);\n\n            if (!this.tags.length) {\n              util.removeClass(this.container, \"has-selected\");\n            }\n          } else {\n            if (!force && !this.config.clearable && !this.config.allowDeselect) {\n              return false;\n            }\n\n            this.label.innerHTML = \"\";\n            this.selectedValue = null;\n            this.el.selectedIndex = this.selectedIndex = -1;\n            util.removeClass(this.container, \"has-selected\");\n          }\n\n          this.items[index].setAttribute(\"aria-selected\", false);\n          util.removeClass(this.items[index], \"selected\");\n          option.selected = false;\n          option.removeAttribute(\"selected\");\n          this.emit(\"selectr.change\", null);\n          this.emit(\"selectr.deselect\", option);\n        };\n        /**\n         * Programmatically set selected values\n         * @param {String|Array} value - A string or an array of strings\n         */\n\n\n        Selectr.prototype.setValue = function (value) {\n          var isArray = Array.isArray(value);\n\n          if (!isArray) {\n            value = value.toString().trim();\n          } // Can't pass array to select-one\n\n\n          if (!this.el.multiple && isArray) {\n            return false;\n          }\n\n          util.each(this.options, function (i, option) {\n            if (isArray && util.includes(value.toString(), option.value) || option.value === value) {\n              this.change(option.idx);\n            }\n          }, this);\n        };\n        /**\n         * Set the selected value(s)\n         * @param  {bool} toObject Return only the raw values or an object\n         * @param  {bool} toJson   Return the object as a JSON string\n         * @return {mixed}         Array or String\n         */\n\n\n        Selectr.prototype.getValue = function (toObject, toJson) {\n          var value;\n\n          if (this.el.multiple) {\n            if (toObject) {\n              if (this.selectedIndexes.length) {\n                value = {};\n                value.values = [];\n                util.each(this.selectedIndexes, function (i, index) {\n                  var option = this.options[index];\n                  value.values[i] = {\n                    value: option.value,\n                    text: option.textContent\n                  };\n                }, this);\n              }\n            } else {\n              value = this.selectedValues.slice();\n            }\n          } else {\n            if (toObject) {\n              var option = this.options[this.selectedIndex];\n              value = {\n                value: option.value,\n                text: option.textContent\n              };\n            } else {\n              value = this.selectedValue;\n            }\n          }\n\n          if (toObject && toJson) {\n            value = JSON.stringify(value);\n          }\n\n          return value;\n        };\n        /**\n         * Add a new option or options\n         * @param {object} data\n         */\n\n\n        Selectr.prototype.add = function (data, checkDuplicate) {\n          if (data) {\n            this.data = this.data || [];\n            this.items = this.items || [];\n            this.options = this.options || [];\n\n            if (Array.isArray(data)) {\n              // We have an array on items\n              util.each(data, function (i, obj) {\n                this.add(obj, checkDuplicate);\n              }, this);\n            } // User passed a single object to the method\n            // or Selectr passed an object from an array\n            else if (\"[object Object]\" === Object.prototype.toString.call(data)) {\n                if (checkDuplicate) {\n                  var dupe = false;\n                  util.each(this.options, function (i, option) {\n                    if (option.value.toLowerCase() === data.value.toLowerCase()) {\n                      dupe = true;\n                    }\n                  });\n\n                  if (dupe) {\n                    return false;\n                  }\n                }\n\n                var option = util.createElement('option', data);\n                this.data.push(data); // Add the new option to the list\n\n                this.options.push(option); // Add the index for later use\n\n                option.idx = this.options.length > 0 ? this.options.length - 1 : 0; // Create a new item\n\n                createItem.call(this, option); // Select the item if required\n\n                if (data.selected) {\n                  this.select(option.idx);\n                }\n\n                return option;\n              } // We may have had an empty select so update\n            // the placeholder to reflect the changes.\n\n\n            this.setPlaceholder(); // Recount the pages\n\n            if (this.config.pagination) {\n              this.paginate();\n            }\n\n            return true;\n          }\n        };\n        /**\n         * Remove an option or options\n         * @param  {Mixed} o Array, integer (index) or string (value)\n         * @return {Void}\n         */\n\n\n        Selectr.prototype.remove = function (o) {\n          var options = [];\n\n          if (Array.isArray(o)) {\n            util.each(o, function (i, opt) {\n              if (util.isInt(opt)) {\n                options.push(this.getOptionByIndex(opt));\n              } else if (typeof o === \"string\") {\n                options.push(this.getOptionByValue(opt));\n              }\n            }, this);\n          } else if (util.isInt(o)) {\n            options.push(this.getOptionByIndex(o));\n          } else if (typeof o === \"string\") {\n            options.push(this.getOptionByValue(o));\n          }\n\n          if (options.length) {\n            var index;\n            util.each(options, function (i, option) {\n              index = option.idx; // Remove the HTMLOptionElement\n\n              this.el.remove(option); // Remove the reference from the option array\n\n              this.options.splice(index, 1); // If the item has a parentNode (group element) it needs to be removed\n              // otherwise the render function will still append it to the dropdown\n\n              var parentNode = this.items[index].parentNode;\n\n              if (parentNode) {\n                parentNode.removeChild(this.items[index]);\n              } // Remove reference from the items array\n\n\n              this.items.splice(index, 1); // Reset the indexes\n\n              util.each(this.options, function (i, opt) {\n                opt.idx = i;\n                this.items[i].idx = i;\n              }, this);\n            }, this); // We may have had an empty select now so update\n            // the placeholder to reflect the changes.\n\n            this.setPlaceholder(); // Recount the pages\n\n            if (this.config.pagination) {\n              this.paginate();\n            }\n          }\n        };\n        /**\n         * Remove all options\n         */\n\n\n        Selectr.prototype.removeAll = function () {\n          // Clear any selected options\n          this.clear(true); // Remove the HTMLOptionElements\n\n          util.each(this.el.options, function (i, option) {\n            this.el.remove(option);\n          }, this); // Empty the dropdown\n\n          util.truncate(this.tree); // Reset variables\n\n          this.items = [];\n          this.options = [];\n          this.data = [];\n          this.navIndex = 0;\n\n          if (this.requiresPagination) {\n            this.requiresPagination = false;\n            this.pageIndex = 1;\n            this.pages = [];\n          } // Update the placeholder\n\n\n          this.setPlaceholder();\n        };\n        /**\n         * Perform a search\n         * @param  {string} query The query string\n         */\n\n\n        Selectr.prototype.search = function (string) {\n          if (this.navigating) return;\n          string = string || this.input.value;\n          var f = document.createDocumentFragment(); // Remove message\n\n          this.removeMessage(); // Clear the dropdown\n\n          util.truncate(this.tree);\n\n          if (string.length > 1) {\n            // Check the options for the matching string\n            util.each(this.options, function (i, option) {\n              var item = this.items[option.idx];\n              var includes = util.includes(option.textContent.toLowerCase(), string.toLowerCase());\n\n              if (includes && !option.disabled) {\n                appendItem(item, f, this.customOption);\n                util.removeClass(item, \"excluded\"); // Underline the matching results\n\n                if (!this.customOption) {\n                  item.innerHTML = match(string, option);\n                }\n              } else {\n                util.addClass(item, \"excluded\");\n              }\n            }, this);\n\n            if (!f.childElementCount) {\n              if (!this.config.taggable) {\n                this.setMessage(\"no results.\");\n              }\n            } else {\n              // Highlight top result (@binary-koan #26)\n              var prevEl = this.items[this.navIndex];\n              var firstEl = f.firstElementChild;\n              util.removeClass(prevEl, \"active\");\n              this.navIndex = firstEl.idx;\n              util.addClass(firstEl, \"active\");\n            }\n          } else {\n            render.call(this);\n          }\n\n          this.tree.appendChild(f);\n        };\n        /**\n         * Toggle the dropdown\n         * @return {void}\n         */\n\n\n        Selectr.prototype.toggle = function () {\n          if (!this.disabled) {\n            if (this.opened) {\n              this.close();\n            } else {\n              this.open();\n            }\n          }\n        };\n        /**\n         * Open the dropdown\n         * @return {void}\n         */\n\n\n        Selectr.prototype.open = function () {\n          var that = this;\n\n          if (!this.options.length) {\n            return false;\n          }\n\n          if (!this.opened) {\n            this.emit(\"selectr.open\");\n          }\n\n          this.opened = true;\n\n          if (this.mobileDevice || this.config.nativeDropdown) {\n            util.addClass(this.container, \"native-open\");\n\n            if (this.config.data) {\n              // Dump the options into the select\n              // otherwise the native dropdown will be empty\n              util.each(this.options, function (i, option) {\n                this.el.add(option);\n              }, this);\n            }\n\n            return;\n          }\n\n          util.addClass(this.container, \"open\");\n          render.call(this);\n          this.invert();\n          this.tree.scrollTop = 0;\n          util.removeClass(this.container, \"notice\");\n          this.selected.setAttribute(\"aria-expanded\", true);\n          this.tree.setAttribute(\"aria-hidden\", false);\n          this.tree.setAttribute(\"aria-expanded\", true);\n\n          if (this.config.searchable && !this.config.taggable) {\n            setTimeout(function () {\n              that.input.focus(); // Allow tab focus\n\n              that.input.tabIndex = 0;\n            }, 10);\n          }\n        };\n        /**\n         * Close the dropdown\n         * @return {void}\n         */\n\n\n        Selectr.prototype.close = function () {\n          if (this.opened) {\n            this.emit(\"selectr.close\");\n          }\n\n          this.opened = false;\n\n          if (this.mobileDevice || this.config.nativeDropdown) {\n            util.removeClass(this.container, \"native-open\");\n            return;\n          }\n\n          var notice = util.hasClass(this.container, \"notice\");\n\n          if (this.config.searchable && !notice) {\n            this.input.blur(); // Disable tab focus\n\n            this.input.tabIndex = -1;\n            this.searching = false;\n          }\n\n          if (notice) {\n            util.removeClass(this.container, \"notice\");\n            this.notice.textContent = \"\";\n          }\n\n          util.removeClass(this.container, \"open\");\n          util.removeClass(this.container, \"native-open\");\n          this.selected.setAttribute(\"aria-expanded\", false);\n          this.tree.setAttribute(\"aria-hidden\", true);\n          this.tree.setAttribute(\"aria-expanded\", false);\n          util.truncate(this.tree);\n          clearSearch.call(this);\n        };\n        /**\n         * Enable the element\n         * @return {void}\n         */\n\n\n        Selectr.prototype.enable = function () {\n          this.disabled = false;\n          this.el.disabled = false;\n          this.selected.tabIndex = this.originalIndex;\n\n          if (this.el.multiple) {\n            util.each(this.tags, function (i, t) {\n              t.lastElementChild.tabIndex = 0;\n            });\n          }\n\n          util.removeClass(this.container, \"selectr-disabled\");\n        };\n        /**\n         * Disable the element\n         * @param  {boolean} container Disable the container only (allow value submit with form)\n         * @return {void}\n         */\n\n\n        Selectr.prototype.disable = function (container) {\n          if (!container) {\n            this.el.disabled = true;\n          }\n\n          this.selected.tabIndex = -1;\n\n          if (this.el.multiple) {\n            util.each(this.tags, function (i, t) {\n              t.lastElementChild.tabIndex = -1;\n            });\n          }\n\n          this.disabled = true;\n          util.addClass(this.container, \"selectr-disabled\");\n        };\n        /**\n         * Reset to initial state\n         * @return {void}\n         */\n\n\n        Selectr.prototype.reset = function () {\n          if (!this.disabled) {\n            this.clear();\n            this.setSelected(true);\n            util.each(this.defaultSelected, function (i, idx) {\n              this.select(idx);\n            }, this);\n            this.emit(\"selectr.reset\");\n          }\n        };\n        /**\n         * Clear all selections\n         * @return {void}\n         */\n\n\n        Selectr.prototype.clear = function (force) {\n          if (this.el.multiple) {\n            // Loop over the selectedIndexes so we don't have to loop over all the options\n            // which can be costly if there are a lot of them\n            if (this.selectedIndexes.length) {\n              // Copy the array or we'll get an error\n              var indexes = this.selectedIndexes.slice();\n              util.each(indexes, function (i, idx) {\n                this.deselect(idx);\n              }, this);\n            }\n          } else {\n            if (this.selectedIndex > -1) {\n              this.deselect(this.selectedIndex, force);\n            }\n          }\n\n          this.emit(\"selectr.clear\");\n        };\n        /**\n         * Return serialised data\n         * @param  {boolean} toJson\n         * @return {mixed} Returns either an object or JSON string\n         */\n\n\n        Selectr.prototype.serialise = function (toJson) {\n          var data = [];\n          util.each(this.options, function (i, option) {\n            var obj = {\n              value: option.value,\n              text: option.textContent\n            };\n\n            if (option.selected) {\n              obj.selected = true;\n            }\n\n            if (option.disabled) {\n              obj.disabled = true;\n            }\n\n            data[i] = obj;\n          });\n          return toJson ? JSON.stringify(data) : data;\n        };\n        /**\n         * Localised version of serialise() method\n         */\n\n\n        Selectr.prototype.serialize = function (toJson) {\n          return this.serialise(toJson);\n        };\n        /**\n         * Sets the placeholder\n         * @param {String} placeholder\n         */\n\n\n        Selectr.prototype.setPlaceholder = function (placeholder) {\n          // Set the placeholder\n          placeholder = placeholder || this.config.placeholder || this.el.getAttribute(\"placeholder\");\n\n          if (!this.options.length) {\n            placeholder = \"No options available\";\n          }\n\n          this.placeEl.innerHTML = placeholder;\n        };\n        /**\n         * Paginate the option list\n         * @return {Array}\n         */\n\n\n        Selectr.prototype.paginate = function () {\n          if (this.items.length) {\n            var that = this;\n            this.pages = this.items.map(function (v, i) {\n              return i % that.config.pagination === 0 ? that.items.slice(i, i + that.config.pagination) : null;\n            }).filter(function (pages) {\n              return pages;\n            });\n            return this.pages;\n          }\n        };\n        /**\n         * Display a message\n         * @param  {String} message The message\n         */\n\n\n        Selectr.prototype.setMessage = function (message, close) {\n          if (close) {\n            this.close();\n          }\n\n          util.addClass(this.container, \"notice\");\n          this.notice.textContent = message;\n        };\n        /**\n         * Dismiss the current message\n         */\n\n\n        Selectr.prototype.removeMessage = function () {\n          util.removeClass(this.container, \"notice\");\n          this.notice.innerHTML = \"\";\n        };\n        /**\n         * Keep the dropdown within the window\n         * @return {void}\n         */\n\n\n        Selectr.prototype.invert = function () {\n          var rt = util.rect(this.selected),\n              oh = this.tree.parentNode.offsetHeight,\n              wh = window.innerHeight,\n              doInvert = rt.top + rt.height + oh > wh;\n\n          if (doInvert) {\n            util.addClass(this.container, \"inverted\");\n            this.isInverted = true;\n          } else {\n            util.removeClass(this.container, \"inverted\");\n            this.isInverted = false;\n          }\n\n          this.optsRect = util.rect(this.tree);\n        };\n        /**\n         * Get an option via it's index\n         * @param  {Integer} index The index of the HTMLOptionElement required\n         * @return {HTMLOptionElement}\n         */\n\n\n        Selectr.prototype.getOptionByIndex = function (index) {\n          return this.options[index];\n        };\n        /**\n         * Get an option via it's value\n         * @param  {String} value The value of the HTMLOptionElement required\n         * @return {HTMLOptionElement}\n         */\n\n\n        Selectr.prototype.getOptionByValue = function (value) {\n          var option = false;\n\n          for (var i = 0, l = this.options.length; i < l; i++) {\n            if (this.options[i].value.trim() === value.toString().trim()) {\n              option = this.options[i];\n              break;\n            }\n          }\n\n          return option;\n        };\n\n        module.exports = Selectr;\n        /***/\n      },\n      /* 9 */\n\n      /***/\n      function (module, exports) {\n        /*\r\n         * Natural Sort algorithm for Javascript - Version 0.7 - Released under MIT license\r\n         * Author: Jim Palmer (based on chunking idea from Dave Koelle)\r\n         */\n\n        /*jshint unused:false */\n        module.exports = function naturalSort(a, b) {\n          var re = /(^([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)?$|^0x[0-9a-f]+$|\\d+)/gi,\n              sre = /(^[ ]*|[ ]*$)/g,\n              dre = /(^([\\w ]+,?[\\w ]+)?[\\w ]+,?[\\w ]+\\d+:\\d+(:\\d+)?[\\w ]?|^\\d{1,4}[\\/\\-]\\d{1,4}[\\/\\-]\\d{1,4}|^\\w+, \\w+ \\d+, \\d{4})/,\n              hre = /^0x[0-9a-f]+$/i,\n              ore = /^0/,\n              i = function (s) {\n            return naturalSort.insensitive && ('' + s).toLowerCase() || '' + s;\n          },\n              // convert all to strings strip whitespace\n          x = i(a).replace(sre, '') || '',\n              y = i(b).replace(sre, '') || '',\n              // chunk/tokenize\n          xN = x.replace(re, '\\0$1\\0').replace(/\\0$/, '').replace(/^\\0/, '').split('\\0'),\n              yN = y.replace(re, '\\0$1\\0').replace(/\\0$/, '').replace(/^\\0/, '').split('\\0'),\n              // numeric, hex or date detection\n          xD = parseInt(x.match(hre), 16) || xN.length !== 1 && x.match(dre) && Date.parse(x),\n              yD = parseInt(y.match(hre), 16) || xD && y.match(dre) && Date.parse(y) || null,\n              oFxNcL,\n              oFyNcL; // first try and sort Hex codes or Dates\n\n\n          if (yD) {\n            if (xD < yD) {\n              return -1;\n            } else if (xD > yD) {\n              return 1;\n            }\n          } // natural sorting through split numeric strings and default strings\n\n\n          for (var cLoc = 0, numS = Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {\n            // find floats not starting with '0', string or 0 if not defined (Clint Priest)\n            oFxNcL = !(xN[cLoc] || '').match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;\n            oFyNcL = !(yN[cLoc] || '').match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0; // handle numeric vs string comparison - number < string - (Kyle Adams)\n\n            if (isNaN(oFxNcL) !== isNaN(oFyNcL)) {\n              return isNaN(oFxNcL) ? 1 : -1;\n            } // rely on string comparison if different types - i.e. '02' < 2 != '02' < '2'\n            else if (typeof oFxNcL !== typeof oFyNcL) {\n                oFxNcL += '';\n                oFyNcL += '';\n              }\n\n            if (oFxNcL < oFyNcL) {\n              return -1;\n            }\n\n            if (oFxNcL > oFyNcL) {\n              return 1;\n            }\n          }\n\n          return 0;\n        };\n        /***/\n\n      },\n      /* 10 */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        /* harmony export (binding) */\n        __webpack_require__.d(__webpack_exports__, \"a\", function () {\n          return createAbsoluteAnchor;\n        });\n        /* harmony import */\n\n\n        var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n        /**\n         * Create an anchor element absolutely positioned in the `parent`\n         * element.\n         * @param {HTMLElement} anchor\n         * @param {HTMLElement} parent\n         * @param {function(HTMLElement)} [onDestroy]  Callback when the anchor is destroyed\n         * @param {boolean} [destroyOnMouseOut=false] If true, anchor will be removed on mouse out\n         * @returns {HTMLElement}\n         */\n\n\n        function createAbsoluteAnchor(anchor, parent, onDestroy) {\n          var destroyOnMouseOut = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n          var root = getRootNode(anchor);\n          var eventListeners = {};\n          var anchorRect = anchor.getBoundingClientRect();\n          var frameRect = parent.getBoundingClientRect();\n          var absoluteAnchor = document.createElement('div');\n          absoluteAnchor.className = 'jsoneditor-anchor';\n          absoluteAnchor.style.position = 'absolute';\n          absoluteAnchor.style.left = anchorRect.left - frameRect.left + 'px';\n          absoluteAnchor.style.top = anchorRect.top - frameRect.top + 'px';\n          absoluteAnchor.style.width = anchorRect.width - 2 + 'px';\n          absoluteAnchor.style.height = anchorRect.height - 2 + 'px';\n          absoluteAnchor.style.boxSizing = 'border-box';\n          parent.appendChild(absoluteAnchor);\n\n          function destroy() {\n            // remove temporary absolutely positioned anchor\n            if (absoluteAnchor && absoluteAnchor.parentNode) {\n              absoluteAnchor.parentNode.removeChild(absoluteAnchor); // remove all event listeners\n              // all event listeners are supposed to be attached to document.\n\n              for (var name in eventListeners) {\n                if (hasOwnProperty(eventListeners, name)) {\n                  var fn = eventListeners[name];\n\n                  if (fn) {\n                    Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"removeEventListener\"])(root, name, fn);\n                  }\n\n                  delete eventListeners[name];\n                }\n              }\n\n              if (typeof onDestroy === 'function') {\n                onDestroy(anchor);\n              }\n            }\n          }\n\n          function isOutside(target) {\n            return target !== absoluteAnchor && !Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"isChildOf\"])(target, absoluteAnchor);\n          } // create and attach event listeners\n\n\n          function destroyIfOutside(event) {\n            if (isOutside(event.target)) {\n              destroy();\n            }\n          }\n\n          eventListeners.mousedown = Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"addEventListener\"])(root, 'mousedown', destroyIfOutside);\n          eventListeners.mousewheel = Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"addEventListener\"])(root, 'mousewheel', destroyIfOutside);\n\n          if (destroyOnMouseOut) {\n            var destroyTimer = null;\n\n            absoluteAnchor.onmouseover = function () {\n              clearTimeout(destroyTimer);\n              destroyTimer = null;\n            };\n\n            absoluteAnchor.onmouseout = function () {\n              if (!destroyTimer) {\n                destroyTimer = setTimeout(destroy, 200);\n              }\n            };\n          }\n\n          absoluteAnchor.destroy = destroy;\n          return absoluteAnchor;\n        }\n        /**\n         * Node.getRootNode shim\n         * @param  {HTMLElement} node node to check\n         * @return {HTMLElement}      node's rootNode or `window` if there is ShadowDOM is not supported.\n         */\n\n\n        function getRootNode(node) {\n          return typeof node.getRootNode === 'function' ? node.getRootNode() : window;\n        }\n\n        function hasOwnProperty(object, key) {\n          return Object.prototype.hasOwnProperty.call(object, key);\n        }\n        /***/\n\n      },\n      /* 11 */\n\n      /***/\n      function (module, exports, __webpack_require__) {\n        var VanillaPicker;\n\n        if (window.Picker) {\n          // use the already loaded instance of VanillaPicker\n          VanillaPicker = window.Picker;\n        } else {\n          try {\n            // load color picker\n            VanillaPicker = __webpack_require__(!function webpackMissingModule() {\n              var e = new Error(\"Cannot find module 'vanilla-picker'\");\n              e.code = 'MODULE_NOT_FOUND';\n              throw e;\n            }());\n          } catch (err) {// probably running the minimalist bundle\n          }\n        }\n\n        module.exports = VanillaPicker;\n        /***/\n      },\n      /* 12 */\n\n      /***/\n      function (module, exports, __webpack_require__) {\n        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n        /**\n        * Permission is hereby granted, free of charge, to any person obtaining a copy\n        * of this software and associated documentation files (the \"Software\"), to deal\n        * in the Software without restriction, including without limitation the rights\n        * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n        * copies of the Software, and to permit persons to whom the Software is\n        * furnished to do so, subject to the following conditions:\n        *\n        * The above copyright notice and this permission notice shall be included in\n        * all copies or substantial portions of the Software.\n        *\n        * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n        * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n        * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n        * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n        * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n        * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n        * SOFTWARE.\n        */\n\n\n        (function (root, factory) {\n          {\n            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n          }\n        })(this, function () {\n          /** Returns whether a value is a dom node */\n          function isNode(value) {\n            if (typeof Node === \"object\") {\n              return value instanceof Node;\n            } else {\n              return value && typeof value === \"object\" && typeof value.nodeType === \"number\";\n            }\n          }\n          /** Returns whether a value is a string */\n\n\n          function isString(value) {\n            return typeof value === \"string\";\n          }\n          /**\n           * Generates observable objects that can be watched and triggered\n           */\n\n\n          function observable() {\n            var callbacks = [];\n            return {\n              watch: callbacks.push.bind(callbacks),\n              trigger: function (context, detail) {\n                var unprevented = true;\n                var event = {\n                  detail: detail,\n                  preventDefault: function preventDefault() {\n                    unprevented = false;\n                  }\n                };\n\n                for (var i = 0; i < callbacks.length; i++) {\n                  callbacks[i](context, event);\n                }\n\n                return unprevented;\n              }\n            };\n          }\n          /** Whether an element is hidden */\n\n\n          function isHidden(elem) {\n            // @see http://stackoverflow.com/questions/19669786\n            return window.getComputedStyle(elem).display === 'none';\n          }\n          /**\n           * A small interface for creating and managing a dom element\n           */\n\n\n          function Elem(elem) {\n            this.elem = elem;\n          }\n          /** Creates a new div */\n\n\n          Elem.make = function (parent, tag) {\n            if (typeof parent === \"string\") {\n              parent = document.querySelector(parent);\n            }\n\n            var elem = document.createElement(tag || 'div');\n            (parent || document.body).appendChild(elem);\n            return new Elem(elem);\n          };\n\n          Elem.prototype = {\n            /** Creates a child of this node */\n            child: function (tag) {\n              return Elem.make(this.elem, tag);\n            },\n\n            /** Applies a set of styles to an element */\n            stylize: function (styles) {\n              styles = styles || {};\n\n              if (typeof styles.opacity !== \"undefined\") {\n                styles.filter = \"alpha(opacity=\" + styles.opacity * 100 + \")\";\n              }\n\n              for (var prop in styles) {\n                if (styles.hasOwnProperty(prop)) {\n                  this.elem.style[prop] = styles[prop];\n                }\n              }\n\n              return this;\n            },\n\n            /** Adds a class name */\n            clazz: function (clazz) {\n              this.elem.className += \" \" + clazz;\n              return this;\n            },\n\n            /** Sets the HTML */\n            html: function (content) {\n              if (isNode(content)) {\n                this.elem.appendChild(content);\n              } else {\n                this.elem.innerHTML = content;\n              }\n\n              return this;\n            },\n\n            /** Adds a click handler to this element */\n            onClick: function (callback) {\n              this.elem.addEventListener('click', callback);\n              return this;\n            },\n\n            /** Removes this element from the DOM */\n            destroy: function () {\n              this.elem.parentNode.removeChild(this.elem);\n            },\n\n            /** Hides this element */\n            hide: function () {\n              this.elem.style.display = \"none\";\n            },\n\n            /** Shows this element */\n            show: function () {\n              this.elem.style.display = \"block\";\n            },\n\n            /** Sets an attribute on this element */\n            attr: function (name, value) {\n              if (value !== undefined) {\n                this.elem.setAttribute(name, value);\n              }\n\n              return this;\n            },\n\n            /** Executes a callback on all the ancestors of an element */\n            anyAncestor: function (predicate) {\n              var elem = this.elem;\n\n              while (elem) {\n                if (predicate(new Elem(elem))) {\n                  return true;\n                } else {\n                  elem = elem.parentNode;\n                }\n              }\n\n              return false;\n            },\n\n            /** Whether this element is visible */\n            isVisible: function () {\n              return !isHidden(this.elem);\n            }\n          };\n          /** Generates the grey-out effect */\n\n          function buildOverlay(getOption, close) {\n            return Elem.make(getOption(\"parent\")).clazz(\"pico-overlay\").clazz(getOption(\"overlayClass\", \"\")).stylize({\n              display: \"none\",\n              position: \"fixed\",\n              top: \"0px\",\n              left: \"0px\",\n              height: \"100%\",\n              width: \"100%\",\n              zIndex: 10000\n            }).stylize(getOption('overlayStyles', {\n              opacity: 0.5,\n              background: \"#000\"\n            })).onClick(function () {\n              if (getOption('overlayClose', true)) {\n                close();\n              }\n            });\n          } // An auto incrementing ID assigned to each modal\n\n\n          var autoinc = 1;\n          /** Builds the content of a modal */\n\n          function buildModal(getOption, close) {\n            var width = getOption('width', 'auto');\n\n            if (typeof width === \"number\") {\n              width = \"\" + width + \"px\";\n            }\n\n            var id = getOption(\"modalId\", \"pico-\" + autoinc++);\n            var elem = Elem.make(getOption(\"parent\")).clazz(\"pico-content\").clazz(getOption(\"modalClass\", \"\")).stylize({\n              display: 'none',\n              position: 'fixed',\n              zIndex: 10001,\n              left: \"50%\",\n              top: \"38.1966%\",\n              maxHeight: '90%',\n              boxSizing: 'border-box',\n              width: width,\n              '-ms-transform': 'translate(-50%,-38.1966%)',\n              '-moz-transform': 'translate(-50%,-38.1966%)',\n              '-webkit-transform': 'translate(-50%,-38.1966%)',\n              '-o-transform': 'translate(-50%,-38.1966%)',\n              transform: 'translate(-50%,-38.1966%)'\n            }).stylize(getOption('modalStyles', {\n              overflow: 'auto',\n              backgroundColor: \"white\",\n              padding: \"20px\",\n              borderRadius: \"5px\"\n            })).html(getOption('content')).attr(\"id\", id).attr(\"role\", \"dialog\").attr(\"aria-labelledby\", getOption(\"ariaLabelledBy\")).attr(\"aria-describedby\", getOption(\"ariaDescribedBy\", id)).onClick(function (event) {\n              var isCloseClick = new Elem(event.target).anyAncestor(function (elem) {\n                return /\\bpico-close\\b/.test(elem.elem.className);\n              });\n\n              if (isCloseClick) {\n                close();\n              }\n            });\n            return elem;\n          }\n          /** Builds the close button */\n\n\n          function buildClose(elem, getOption) {\n            if (getOption('closeButton', true)) {\n              return elem.child('button').html(getOption('closeHtml', \"&#xD7;\")).clazz(\"pico-close\").clazz(getOption(\"closeClass\", \"\")).stylize(getOption('closeStyles', {\n                borderRadius: \"2px\",\n                border: 0,\n                padding: 0,\n                cursor: \"pointer\",\n                height: \"15px\",\n                width: \"15px\",\n                position: \"absolute\",\n                top: \"5px\",\n                right: \"5px\",\n                fontSize: \"16px\",\n                textAlign: \"center\",\n                lineHeight: \"15px\",\n                background: \"#CCC\"\n              })).attr(\"aria-label\", getOption(\"close-label\", \"Close\"));\n            }\n          }\n          /** Builds a method that calls a method and returns an element */\n\n\n          function buildElemAccessor(builder) {\n            return function () {\n              return builder().elem;\n            };\n          } // An observable that is triggered whenever the escape key is pressed\n\n\n          var escapeKey = observable(); // An observable that is triggered when the user hits the tab key\n\n          var tabKey = observable();\n          /** A global event handler to detect the escape key being pressed */\n\n          document.documentElement.addEventListener('keydown', function onKeyPress(event) {\n            var keycode = event.which || event.keyCode; // If this is the escape key\n\n            if (keycode === 27) {\n              escapeKey.trigger();\n            } // If this is the tab key\n            else if (keycode === 9) {\n                tabKey.trigger(event);\n              }\n          });\n          /** Attaches focus management events */\n\n          function manageFocus(iface, isEnabled) {\n            /** Whether an element matches a selector */\n            function matches(elem, selector) {\n              var fn = elem.msMatchesSelector || elem.webkitMatchesSelector || elem.matches;\n              return fn.call(elem, selector);\n            }\n            /**\n             * Returns whether an element is focusable\n             * @see http://stackoverflow.com/questions/18261595\n             */\n\n\n            function canFocus(elem) {\n              if (isHidden(elem) || matches(elem, \":disabled\") || elem.hasAttribute(\"contenteditable\")) {\n                return false;\n              } else {\n                return elem.hasAttribute(\"tabindex\") || matches(elem, \"input,select,textarea,button,a[href],area[href],iframe\");\n              }\n            }\n            /** Returns the first descendant that can be focused */\n\n\n            function firstFocusable(elem) {\n              var items = elem.getElementsByTagName(\"*\");\n\n              for (var i = 0; i < items.length; i++) {\n                if (canFocus(items[i])) {\n                  return items[i];\n                }\n              }\n            }\n            /** Returns the last descendant that can be focused */\n\n\n            function lastFocusable(elem) {\n              var items = elem.getElementsByTagName(\"*\");\n\n              for (var i = items.length; i--;) {\n                if (canFocus(items[i])) {\n                  return items[i];\n                }\n              }\n            } // The element focused before the modal opens\n\n\n            var focused; // Records the currently focused element so state can be returned\n            // after the modal closes\n\n            iface.beforeShow(function getActiveFocus() {\n              focused = document.activeElement;\n            }); // Shift focus into the modal\n\n            iface.afterShow(function focusModal() {\n              if (isEnabled()) {\n                var focusable = firstFocusable(iface.modalElem());\n\n                if (focusable) {\n                  focusable.focus();\n                }\n              }\n            }); // Restore the previously focused element when the modal closes\n\n            iface.afterClose(function returnFocus() {\n              if (isEnabled() && focused) {\n                focused.focus();\n              }\n\n              focused = null;\n            }); // Capture tab key presses and loop them within the modal\n\n            tabKey.watch(function tabKeyPress(event) {\n              if (isEnabled() && iface.isVisible()) {\n                var first = firstFocusable(iface.modalElem());\n                var last = lastFocusable(iface.modalElem());\n                var from = event.shiftKey ? first : last;\n\n                if (from === document.activeElement) {\n                  (event.shiftKey ? last : first).focus();\n                  event.preventDefault();\n                }\n              }\n            });\n          }\n          /** Manages setting the 'overflow: hidden' on the body tag */\n\n\n          function manageBodyOverflow(iface, isEnabled) {\n            var origOverflow;\n            var body = new Elem(document.body);\n            iface.beforeShow(function () {\n              // Capture the current values so they can be restored\n              origOverflow = body.elem.style.overflow;\n\n              if (isEnabled()) {\n                body.stylize({\n                  overflow: \"hidden\"\n                });\n              }\n            });\n            iface.afterClose(function () {\n              body.stylize({\n                overflow: origOverflow\n              });\n            });\n          }\n          /**\n           * Displays a modal\n           */\n\n\n          return function picoModal(options) {\n            if (isString(options) || isNode(options)) {\n              options = {\n                content: options\n              };\n            }\n\n            var afterCreateEvent = observable();\n            var beforeShowEvent = observable();\n            var afterShowEvent = observable();\n            var beforeCloseEvent = observable();\n            var afterCloseEvent = observable();\n            /**\n             * Returns a named option if it has been explicitly defined. Otherwise,\n             * it returns the given default value\n             */\n\n            function getOption(opt, defaultValue) {\n              var value = options[opt];\n\n              if (typeof value === \"function\") {\n                value = value(defaultValue);\n              }\n\n              return value === undefined ? defaultValue : value;\n            } // The various DOM elements that constitute the modal\n\n\n            var modalElem = build.bind(window, 'modal');\n            var shadowElem = build.bind(window, 'overlay');\n            var closeElem = build.bind(window, 'close'); // This will eventually contain the modal API returned to the user\n\n            var iface;\n            /** Hides this modal */\n\n            function forceClose(detail) {\n              shadowElem().hide();\n              modalElem().hide();\n              afterCloseEvent.trigger(iface, detail);\n            }\n            /** Gracefully hides this modal */\n\n\n            function close(detail) {\n              if (beforeCloseEvent.trigger(iface, detail)) {\n                forceClose(detail);\n              }\n            }\n            /** Wraps a method so it returns the modal interface */\n\n\n            function returnIface(callback) {\n              return function () {\n                callback.apply(this, arguments);\n                return iface;\n              };\n            } // The constructed dom nodes\n\n\n            var built;\n            /** Builds a method that calls a method and returns an element */\n\n            function build(name, detail) {\n              if (!built) {\n                var modal = buildModal(getOption, close);\n                built = {\n                  modal: modal,\n                  overlay: buildOverlay(getOption, close),\n                  close: buildClose(modal, getOption)\n                };\n                afterCreateEvent.trigger(iface, detail);\n              }\n\n              return built[name];\n            }\n\n            iface = {\n              /** Returns the wrapping modal element */\n              modalElem: buildElemAccessor(modalElem),\n\n              /** Returns the close button element */\n              closeElem: buildElemAccessor(closeElem),\n\n              /** Returns the overlay element */\n              overlayElem: buildElemAccessor(shadowElem),\n\n              /** Builds the dom without showing the modal */\n              buildDom: returnIface(build.bind(null, null)),\n\n              /** Returns whether this modal is currently being shown */\n              isVisible: function () {\n                return !!(built && modalElem && modalElem().isVisible());\n              },\n\n              /** Shows this modal */\n              show: function (detail) {\n                if (beforeShowEvent.trigger(iface, detail)) {\n                  shadowElem().show();\n                  closeElem();\n                  modalElem().show();\n                  afterShowEvent.trigger(iface, detail);\n                }\n\n                return this;\n              },\n\n              /** Hides this modal */\n              close: returnIface(close),\n\n              /**\n               * Force closes this modal. This will not call beforeClose\n               * events and will just immediately hide the modal\n               */\n              forceClose: returnIface(forceClose),\n\n              /** Destroys this modal */\n              destroy: function () {\n                modalElem().destroy();\n                shadowElem().destroy();\n                shadowElem = modalElem = closeElem = undefined;\n              },\n\n              /**\n               * Updates the options for this modal. This will only let you\n               * change options that are re-evaluted regularly, such as\n               * `overlayClose`.\n               */\n              options: function (opts) {\n                Object.keys(opts).map(function (key) {\n                  options[key] = opts[key];\n                });\n              },\n\n              /** Executes after the DOM nodes are created */\n              afterCreate: returnIface(afterCreateEvent.watch),\n\n              /** Executes a callback before this modal is closed */\n              beforeShow: returnIface(beforeShowEvent.watch),\n\n              /** Executes a callback after this modal is shown */\n              afterShow: returnIface(afterShowEvent.watch),\n\n              /** Executes a callback before this modal is closed */\n              beforeClose: returnIface(beforeCloseEvent.watch),\n\n              /** Executes a callback after this modal is closed */\n              afterClose: returnIface(afterCloseEvent.watch)\n            };\n            manageFocus(iface, getOption.bind(null, \"focus\", true));\n            manageBodyOverflow(iface, getOption.bind(null, \"bodyOverflow\", true)); // If a user presses the 'escape' key, close the modal.\n\n            escapeKey.watch(function escapeKeyPress() {\n              if (getOption(\"escCloses\", true) && iface.isVisible()) {\n                iface.close();\n              }\n            });\n            return iface;\n          };\n        });\n        /***/\n\n      },\n      /* 13 */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        /* harmony export (binding) */\n        __webpack_require__.d(__webpack_exports__, \"a\", function () {\n          return ErrorTable;\n        });\n\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        function _defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        function _createClass(Constructor, protoProps, staticProps) {\n          if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) _defineProperties(Constructor, staticProps);\n          return Constructor;\n        }\n        /**\n         * Show errors and schema warnings in a clickable table view\n         * @param {Object} config\n         * @property {boolean} errorTableVisible\n         * @property {function (boolean) : void} onToggleVisibility\n         * @property {function (number)} [onFocusLine]\n         * @property {function (number)} onChangeHeight\n         * @constructor\n         */\n\n\n        var ErrorTable =\n        /*#__PURE__*/\n        function () {\n          function ErrorTable(config) {\n            _classCallCheck(this, ErrorTable);\n\n            this.errorTableVisible = config.errorTableVisible;\n            this.onToggleVisibility = config.onToggleVisibility;\n\n            this.onFocusLine = config.onFocusLine || function () {};\n\n            this.onChangeHeight = config.onChangeHeight;\n            this.dom = {};\n            var validationErrorsContainer = document.createElement('div');\n            validationErrorsContainer.className = 'jsoneditor-validation-errors-container';\n            this.dom.validationErrorsContainer = validationErrorsContainer;\n            var additionalErrorsIndication = document.createElement('div');\n            additionalErrorsIndication.style.display = 'none';\n            additionalErrorsIndication.className = 'jsoneditor-additional-errors fadein';\n            additionalErrorsIndication.innerHTML = 'Scroll for more &#9663;';\n            this.dom.additionalErrorsIndication = additionalErrorsIndication;\n            validationErrorsContainer.appendChild(additionalErrorsIndication);\n            var validationErrorIcon = document.createElement('span');\n            validationErrorIcon.className = 'jsoneditor-validation-error-icon';\n            validationErrorIcon.style.display = 'none';\n            this.dom.validationErrorIcon = validationErrorIcon;\n            var validationErrorCount = document.createElement('span');\n            validationErrorCount.className = 'jsoneditor-validation-error-count';\n            validationErrorCount.style.display = 'none';\n            this.dom.validationErrorCount = validationErrorCount;\n            this.dom.parseErrorIndication = document.createElement('span');\n            this.dom.parseErrorIndication.className = 'jsoneditor-parse-error-icon';\n            this.dom.parseErrorIndication.style.display = 'none';\n          }\n\n          _createClass(ErrorTable, [{\n            key: \"getErrorTable\",\n            value: function getErrorTable() {\n              return this.dom.validationErrorsContainer;\n            }\n          }, {\n            key: \"getErrorCounter\",\n            value: function getErrorCounter() {\n              return this.dom.validationErrorCount;\n            }\n          }, {\n            key: \"getWarningIcon\",\n            value: function getWarningIcon() {\n              return this.dom.validationErrorIcon;\n            }\n          }, {\n            key: \"getErrorIcon\",\n            value: function getErrorIcon() {\n              return this.dom.parseErrorIndication;\n            }\n          }, {\n            key: \"toggleTableVisibility\",\n            value: function toggleTableVisibility() {\n              this.errorTableVisible = !this.errorTableVisible;\n              this.onToggleVisibility(this.errorTableVisible);\n            }\n          }, {\n            key: \"setErrors\",\n            value: function setErrors(errors, errorLocations) {\n              var _this = this; // clear any previous errors\n\n\n              if (this.dom.validationErrors) {\n                this.dom.validationErrors.parentNode.removeChild(this.dom.validationErrors);\n                this.dom.validationErrors = null;\n                this.dom.additionalErrorsIndication.style.display = 'none';\n              } // create the table with errors\n              // keep default behavior for parse errors\n\n\n              if (this.errorTableVisible && errors.length > 0) {\n                var validationErrors = document.createElement('div');\n                validationErrors.className = 'jsoneditor-validation-errors';\n                validationErrors.innerHTML = '<table class=\"jsoneditor-text-errors\"><tbody></tbody></table>';\n                var tbody = validationErrors.getElementsByTagName('tbody')[0];\n                errors.forEach(function (error) {\n                  var message;\n\n                  if (typeof error === 'string') {\n                    message = '<td colspan=\"2\"><pre>' + error + '</pre></td>';\n                  } else {\n                    message = '<td>' + (error.dataPath || '') + '</td>' + '<td><pre>' + error.message + '</pre></td>';\n                  }\n\n                  var line;\n\n                  if (!isNaN(error.line)) {\n                    line = error.line;\n                  } else if (error.dataPath) {\n                    var errLoc = errorLocations.find(function (loc) {\n                      return loc.path === error.dataPath;\n                    });\n\n                    if (errLoc) {\n                      line = errLoc.line + 1;\n                    }\n                  }\n\n                  var trEl = document.createElement('tr');\n                  trEl.className = !isNaN(line) ? 'jump-to-line' : '';\n\n                  if (error.type === 'error') {\n                    trEl.className += ' parse-error';\n                  } else {\n                    trEl.className += ' validation-error';\n                  }\n\n                  trEl.innerHTML = '<td><button class=\"jsoneditor-schema-error\"></button></td><td style=\"white-space:nowrap;\">' + (!isNaN(line) ? 'Ln ' + line : '') + '</td>' + message;\n\n                  trEl.onclick = function () {\n                    _this.onFocusLine(line);\n                  };\n\n                  tbody.appendChild(trEl);\n                });\n                this.dom.validationErrors = validationErrors;\n                this.dom.validationErrorsContainer.appendChild(validationErrors);\n                this.dom.additionalErrorsIndication.title = errors.length + ' errors total';\n\n                if (this.dom.validationErrorsContainer.clientHeight < this.dom.validationErrorsContainer.scrollHeight) {\n                  this.dom.additionalErrorsIndication.style.display = 'block';\n\n                  this.dom.validationErrorsContainer.onscroll = function () {\n                    _this.dom.additionalErrorsIndication.style.display = _this.dom.validationErrorsContainer.clientHeight > 0 && _this.dom.validationErrorsContainer.scrollTop === 0 ? 'block' : 'none';\n                  };\n                } else {\n                  this.dom.validationErrorsContainer.onscroll = undefined;\n                }\n\n                var height = this.dom.validationErrorsContainer.clientHeight + (this.dom.statusBar ? this.dom.statusBar.clientHeight : 0); // this.content.style.marginBottom = (-height) + 'px';\n                // this.content.style.paddingBottom = height + 'px';\n\n                this.onChangeHeight(height);\n              } else {\n                this.onChangeHeight(0);\n              } // update the status bar\n\n\n              var validationErrorsCount = errors.filter(function (error) {\n                return error.type !== 'error';\n              }).length;\n\n              if (validationErrorsCount > 0) {\n                this.dom.validationErrorCount.style.display = 'inline';\n                this.dom.validationErrorCount.innerText = validationErrorsCount;\n                this.dom.validationErrorCount.onclick = this.toggleTableVisibility.bind(this);\n                this.dom.validationErrorIcon.style.display = 'inline';\n                this.dom.validationErrorIcon.title = validationErrorsCount + ' schema validation error(s) found';\n                this.dom.validationErrorIcon.onclick = this.toggleTableVisibility.bind(this);\n              } else {\n                this.dom.validationErrorCount.style.display = 'none';\n                this.dom.validationErrorIcon.style.display = 'none';\n              } // update the parse error icon\n\n\n              var hasParseErrors = errors.some(function (error) {\n                return error.type === 'error';\n              });\n\n              if (hasParseErrors) {\n                var line = errors[0].line;\n                this.dom.parseErrorIndication.style.display = 'block';\n                this.dom.parseErrorIndication.title = !isNaN(line) ? 'parse error on line ' + line : 'parse error - check that the json is valid';\n              } else {\n                this.dom.parseErrorIndication.style.display = 'none';\n              }\n            }\n          }]);\n\n          return ErrorTable;\n        }();\n        /***/\n\n      },\n      /* 14 */\n\n      /***/\n      function (module, exports, __webpack_require__) {\n        var ace;\n\n        if (window.ace) {\n          // use the already loaded instance of Ace\n          ace = window.ace;\n        } else {\n          try {\n            // load Ace editor\n            ace = __webpack_require__(!function webpackMissingModule() {\n              var e = new Error(\"Cannot find module 'ace-builds/src-noconflict/ace'\");\n              e.code = 'MODULE_NOT_FOUND';\n              throw e;\n            }()); // load required Ace plugins\n\n            __webpack_require__(!function webpackMissingModule() {\n              var e = new Error(\"Cannot find module 'ace-builds/src-noconflict/mode-json'\");\n              e.code = 'MODULE_NOT_FOUND';\n              throw e;\n            }());\n\n            __webpack_require__(!function webpackMissingModule() {\n              var e = new Error(\"Cannot find module 'ace-builds/src-noconflict/ext-searchbox'\");\n              e.code = 'MODULE_NOT_FOUND';\n              throw e;\n            }()); // embed Ace json worker\n            // https://github.com/ajaxorg/ace/issues/3913\n\n\n            var jsonWorkerDataUrl = __webpack_require__(!function webpackMissingModule() {\n              var e = new Error(\"Cannot find module '../generated/worker-json-data-url'\");\n              e.code = 'MODULE_NOT_FOUND';\n              throw e;\n            }());\n\n            ace.config.setModuleUrl('ace/mode/json_worker', jsonWorkerDataUrl);\n          } catch (err) {// failed to load Ace (can be minimalist bundle).\n            // No worries, the editor will fall back to plain text if needed.\n          }\n        }\n\n        module.exports = ace;\n        /***/\n      },\n      /* 15 */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        __webpack_require__.r(__webpack_exports__); // EXTERNAL MODULE: ./src/js/ace/index.js\n\n\n        var ace = __webpack_require__(14);\n\n        var ace_default =\n        /*#__PURE__*/\n        __webpack_require__.n(ace); // EXTERNAL MODULE: ./node_modules/jmespath/jmespath.js\n\n\n        var jmespath = __webpack_require__(4);\n\n        var jmespath_default =\n        /*#__PURE__*/\n        __webpack_require__.n(jmespath); // EXTERNAL MODULE: ./src/js/i18n.js\n\n\n        var i18n = __webpack_require__(1); // EXTERNAL MODULE: ./src/js/ModeSwitcher.js\n\n\n        var ModeSwitcher = __webpack_require__(6); // EXTERNAL MODULE: ./src/js/ErrorTable.js\n\n\n        var ErrorTable = __webpack_require__(13); // EXTERNAL MODULE: ./src/js/util.js\n\n\n        var util = __webpack_require__(0); // CONCATENATED MODULE: ./src/js/validationUtils.js\n\n        /**\n         * Execute custom validation if configured.\n         *\n         * Returns a promise resolving with the custom errors (or an empty array).\n         */\n\n\n        function validateCustom(json, onValidate) {\n          if (!onValidate) {\n            return Promise.resolve([]);\n          }\n\n          try {\n            var customValidateResults = onValidate(json);\n            var resultPromise = Object(util[\"isPromise\"])(customValidateResults) ? customValidateResults : Promise.resolve(customValidateResults);\n            return resultPromise.then(function (customValidationPathErrors) {\n              if (Array.isArray(customValidationPathErrors)) {\n                return customValidationPathErrors.filter(function (error) {\n                  var valid = Object(util[\"isValidValidationError\"])(error);\n\n                  if (!valid) {\n                    console.warn('Ignoring a custom validation error with invalid structure. ' + 'Expected structure: {path: [...], message: \"...\"}. ' + 'Actual error:', error);\n                  }\n\n                  return valid;\n                }).map(function (error) {\n                  return (// change data structure into the structure matching the JSON schema errors\n                    {\n                      dataPath: Object(util[\"stringifyPath\"])(error.path),\n                      message: error.message\n                    }\n                  );\n                });\n              } else {\n                return [];\n              }\n            });\n          } catch (err) {\n            return Promise.reject(err);\n          }\n        } // EXTERNAL MODULE: ./src/js/showSortModal.js\n\n\n        var showSortModal = __webpack_require__(5); // EXTERNAL MODULE: ./src/js/showTransformModal.js + 1 modules\n\n\n        var showTransformModal = __webpack_require__(7); // EXTERNAL MODULE: ./src/js/constants.js\n\n\n        var constants = __webpack_require__(2); // EXTERNAL MODULE: ./src/js/tryRequireThemeJsonEditor.js\n\n\n        var tryRequireThemeJsonEditor = __webpack_require__(19); // CONCATENATED MODULE: ./src/js/textmode.js\n\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"textModeMixins\", function () {\n          return textModeMixins;\n        });\n\n        function _typeof(obj) {\n          if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n              return typeof obj;\n            };\n          } else {\n            _typeof = function _typeof(obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n          }\n\n          return _typeof(obj);\n        } // create a mixin with the functions for text mode\n\n\n        var textmode = {};\n        var DEFAULT_THEME = 'ace/theme/jsoneditor';\n        /**\n         * Create a text editor\n         * @param {Element} container\n         * @param {Object} [options]   Object with options. See docs for details.\n         * @private\n         */\n\n        textmode.create = function (container) {\n          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n          if (typeof options.statusBar === 'undefined') {\n            options.statusBar = true;\n          } // setting default for textmode\n\n\n          options.mainMenuBar = options.mainMenuBar !== false;\n          options.enableSort = options.enableSort !== false;\n          options.enableTransform = options.enableTransform !== false;\n          this.options = options; // indentation\n\n          if (options.indentation) {\n            this.indentation = Number(options.indentation);\n          } else {\n            this.indentation = 2; // number of spaces\n          } // grab ace from options if provided\n\n\n          var _ace = options.ace ? options.ace : ace_default.a; // TODO: make the option options.ace deprecated, it's not needed anymore (see #309)\n          // determine mode\n\n\n          this.mode = options.mode === 'code' ? 'code' : 'text';\n\n          if (this.mode === 'code') {\n            // verify whether Ace editor is available and supported\n            if (typeof _ace === 'undefined') {\n              this.mode = 'text';\n              console.warn('Failed to load Ace editor, falling back to plain text mode. Please use a JSONEditor bundle including Ace, or pass Ace as via the configuration option `ace`.');\n            }\n          } // determine theme\n\n\n          this.theme = options.theme || DEFAULT_THEME;\n\n          if (this.theme === DEFAULT_THEME && _ace) {\n            Object(tryRequireThemeJsonEditor[\"tryRequireThemeJsonEditor\"])();\n          }\n\n          if (options.onTextSelectionChange) {\n            this.onTextSelectionChange(options.onTextSelectionChange);\n          }\n\n          var me = this;\n          this.container = container;\n          this.dom = {};\n          this.aceEditor = undefined; // ace code editor\n\n          this.textarea = undefined; // plain text editor (fallback when Ace is not available)\n\n          this.validateSchema = null;\n          this.annotations = []; // create a debounced validate function\n\n          this._debouncedValidate = Object(util[\"debounce\"])(this.validate.bind(this), this.DEBOUNCE_INTERVAL);\n          this.width = container.clientWidth;\n          this.height = container.clientHeight;\n          this.frame = document.createElement('div');\n          this.frame.className = 'jsoneditor jsoneditor-mode-' + this.options.mode;\n\n          this.frame.onclick = function (event) {\n            // prevent default submit action when the editor is located inside a form\n            event.preventDefault();\n          };\n\n          this.frame.onkeydown = function (event) {\n            me._onKeyDown(event);\n          };\n\n          this.content = document.createElement('div');\n          this.content.className = 'jsoneditor-outer';\n\n          if (this.options.mainMenuBar) {\n            Object(util[\"addClassName\"])(this.content, 'has-main-menu-bar'); // create menu\n\n            this.menu = document.createElement('div');\n            this.menu.className = 'jsoneditor-menu';\n            this.frame.appendChild(this.menu); // create format button\n\n            var buttonFormat = document.createElement('button');\n            buttonFormat.type = 'button';\n            buttonFormat.className = 'jsoneditor-format';\n            buttonFormat.title = 'Format JSON data, with proper indentation and line feeds (Ctrl+\\\\)';\n            this.menu.appendChild(buttonFormat);\n\n            buttonFormat.onclick = function () {\n              try {\n                me.format();\n\n                me._onChange();\n              } catch (err) {\n                me._onError(err);\n              }\n            }; // create compact button\n\n\n            var buttonCompact = document.createElement('button');\n            buttonCompact.type = 'button';\n            buttonCompact.className = 'jsoneditor-compact';\n            buttonCompact.title = 'Compact JSON data, remove all whitespaces (Ctrl+Shift+\\\\)';\n            this.menu.appendChild(buttonCompact);\n\n            buttonCompact.onclick = function () {\n              try {\n                me.compact();\n\n                me._onChange();\n              } catch (err) {\n                me._onError(err);\n              }\n            }; // create sort button\n\n\n            if (this.options.enableSort) {\n              var _sort = document.createElement('button');\n\n              _sort.type = 'button';\n              _sort.className = 'jsoneditor-sort';\n              _sort.title = Object(i18n[\"c\"\n              /* translate */\n              ])('sortTitleShort');\n\n              _sort.onclick = function () {\n                me._showSortModal();\n              };\n\n              this.menu.appendChild(_sort);\n            } // create transform button\n\n\n            if (this.options.enableTransform) {\n              var transform = document.createElement('button');\n              transform.type = 'button';\n              transform.title = Object(i18n[\"c\"\n              /* translate */\n              ])('transformTitleShort');\n              transform.className = 'jsoneditor-transform';\n\n              transform.onclick = function () {\n                me._showTransformModal();\n              };\n\n              this.menu.appendChild(transform);\n            } // create repair button\n\n\n            var buttonRepair = document.createElement('button');\n            buttonRepair.type = 'button';\n            buttonRepair.className = 'jsoneditor-repair';\n            buttonRepair.title = 'Repair JSON: fix quotes and escape characters, remove comments and JSONP notation, turn JavaScript objects into JSON.';\n            this.menu.appendChild(buttonRepair);\n\n            buttonRepair.onclick = function () {\n              try {\n                me.repair();\n\n                me._onChange();\n              } catch (err) {\n                me._onError(err);\n              }\n            }; // create mode box\n\n\n            if (this.options && this.options.modes && this.options.modes.length) {\n              this.modeSwitcher = new ModeSwitcher[\"a\"\n              /* ModeSwitcher */\n              ](this.menu, this.options.modes, this.options.mode, function onSwitch(mode) {\n                // switch mode and restore focus\n                me.setMode(mode);\n                me.modeSwitcher.focus();\n              });\n            }\n\n            if (this.mode === 'code') {\n              var poweredBy = document.createElement('a');\n              poweredBy.appendChild(document.createTextNode('powered by ace'));\n              poweredBy.href = 'http://ace.ajax.org';\n              poweredBy.target = '_blank';\n              poweredBy.className = 'jsoneditor-poweredBy';\n\n              poweredBy.onclick = function () {\n                // TODO: this anchor falls below the margin of the content,\n                // therefore the normal a.href does not work. We use a click event\n                // for now, but this should be fixed.\n                window.open(poweredBy.href, poweredBy.target);\n              };\n\n              this.menu.appendChild(poweredBy);\n            }\n          }\n\n          var emptyNode = {};\n          var isReadOnly = this.options.onEditable && _typeof(this.options.onEditable === 'function') && !this.options.onEditable(emptyNode);\n          this.frame.appendChild(this.content);\n          this.container.appendChild(this.frame);\n\n          if (this.mode === 'code') {\n            this.editorDom = document.createElement('div');\n            this.editorDom.style.height = '100%'; // TODO: move to css\n\n            this.editorDom.style.width = '100%'; // TODO: move to css\n\n            this.content.appendChild(this.editorDom);\n\n            var aceEditor = _ace.edit(this.editorDom);\n\n            var aceSession = aceEditor.getSession();\n            aceEditor.$blockScrolling = Infinity;\n            aceEditor.setTheme(this.theme);\n            aceEditor.setOptions({\n              readOnly: isReadOnly\n            });\n            aceEditor.setShowPrintMargin(false);\n            aceEditor.setFontSize('13px');\n            aceSession.setMode('ace/mode/json');\n            aceSession.setTabSize(this.indentation);\n            aceSession.setUseSoftTabs(true);\n            aceSession.setUseWrapMode(true); // replace ace setAnnotations with custom function that also covers jsoneditor annotations\n\n            var originalSetAnnotations = aceSession.setAnnotations;\n\n            aceSession.setAnnotations = function (annotations) {\n              originalSetAnnotations.call(this, annotations && annotations.length ? annotations : me.annotations);\n            };\n\n            aceEditor.commands.bindKey('Ctrl-L', null); // disable Ctrl+L (is used by the browser to select the address bar)\n\n            aceEditor.commands.bindKey('Command-L', null); // disable Ctrl+L (is used by the browser to select the address bar)\n\n            this.aceEditor = aceEditor; // register onchange event\n\n            aceEditor.on('change', this._onChange.bind(this));\n            aceEditor.on('changeSelection', this._onSelect.bind(this));\n          } else {\n            // load a plain text textarea\n            var textarea = document.createElement('textarea');\n            textarea.className = 'jsoneditor-text';\n            textarea.spellcheck = false;\n            this.content.appendChild(textarea);\n            this.textarea = textarea;\n            this.textarea.readOnly = isReadOnly; // register onchange event\n\n            if (this.textarea.oninput === null) {\n              this.textarea.oninput = this._onChange.bind(this);\n            } else {\n              // oninput is undefined. For IE8-\n              this.textarea.onchange = this._onChange.bind(this);\n            }\n\n            textarea.onselect = this._onSelect.bind(this);\n            textarea.onmousedown = this._onMouseDown.bind(this);\n            textarea.onblur = this._onBlur.bind(this);\n          }\n\n          this.errorTable = new ErrorTable[\"a\"\n          /* ErrorTable */\n          ]({\n            errorTableVisible: this.mode === 'text',\n            onToggleVisibility: function onToggleVisibility() {\n              me.validate();\n            },\n            onFocusLine: function onFocusLine(line) {\n              me.isFocused = true;\n\n              if (!isNaN(line)) {\n                me.setTextSelection({\n                  row: line,\n                  column: 1\n                }, {\n                  row: line,\n                  column: 1000\n                });\n              }\n            },\n            onChangeHeight: function onChangeHeight(height) {\n              // TODO: change CSS to using flex box, remove setting height using JavaScript\n              var statusBarHeight = me.dom.statusBar ? me.dom.statusBar.clientHeight : 0;\n              var totalHeight = height + statusBarHeight + 1;\n              me.content.style.marginBottom = -totalHeight + 'px';\n              me.content.style.paddingBottom = totalHeight + 'px';\n            }\n          });\n          this.frame.appendChild(this.errorTable.getErrorTable());\n\n          if (options.statusBar) {\n            Object(util[\"addClassName\"])(this.content, 'has-status-bar');\n            this.curserInfoElements = {};\n            var statusBar = document.createElement('div');\n            this.dom.statusBar = statusBar;\n            statusBar.className = 'jsoneditor-statusbar';\n            this.frame.appendChild(statusBar);\n            var lnLabel = document.createElement('span');\n            lnLabel.className = 'jsoneditor-curserinfo-label';\n            lnLabel.innerText = 'Ln:';\n            var lnVal = document.createElement('span');\n            lnVal.className = 'jsoneditor-curserinfo-val';\n            lnVal.innerText = '1';\n            statusBar.appendChild(lnLabel);\n            statusBar.appendChild(lnVal);\n            var colLabel = document.createElement('span');\n            colLabel.className = 'jsoneditor-curserinfo-label';\n            colLabel.innerText = 'Col:';\n            var colVal = document.createElement('span');\n            colVal.className = 'jsoneditor-curserinfo-val';\n            colVal.innerText = '1';\n            statusBar.appendChild(colLabel);\n            statusBar.appendChild(colVal);\n            this.curserInfoElements.colVal = colVal;\n            this.curserInfoElements.lnVal = lnVal;\n            var countLabel = document.createElement('span');\n            countLabel.className = 'jsoneditor-curserinfo-label';\n            countLabel.innerText = 'characters selected';\n            countLabel.style.display = 'none';\n            var countVal = document.createElement('span');\n            countVal.className = 'jsoneditor-curserinfo-count';\n            countVal.innerText = '0';\n            countVal.style.display = 'none';\n            this.curserInfoElements.countLabel = countLabel;\n            this.curserInfoElements.countVal = countVal;\n            statusBar.appendChild(countVal);\n            statusBar.appendChild(countLabel);\n            statusBar.appendChild(this.errorTable.getErrorCounter());\n            statusBar.appendChild(this.errorTable.getWarningIcon());\n            statusBar.appendChild(this.errorTable.getErrorIcon());\n          }\n\n          this.setSchema(this.options.schema, this.options.schemaRefs);\n        };\n        /**\n         * Handle a change:\n         * - Validate JSON schema\n         * - Send a callback to the onChange listener if provided\n         * @private\n         */\n\n\n        textmode._onChange = function () {\n          if (this.onChangeDisabled) {\n            return;\n          } // validate JSON schema (if configured)\n\n\n          this._debouncedValidate(); // trigger the onChange callback\n\n\n          if (this.options.onChange) {\n            try {\n              this.options.onChange();\n            } catch (err) {\n              console.error('Error in onChange callback: ', err);\n            }\n          } // trigger the onChangeText callback\n\n\n          if (this.options.onChangeText) {\n            try {\n              this.options.onChangeText(this.getText());\n            } catch (err) {\n              console.error('Error in onChangeText callback: ', err);\n            }\n          }\n        };\n        /**\n         * Open a sort modal\n         * @private\n         */\n\n\n        textmode._showSortModal = function () {\n          var me = this;\n          var container = this.options.modalAnchor || constants[\"a\"\n          /* DEFAULT_MODAL_ANCHOR */\n          ];\n          var json = this.get();\n\n          function onSort(sortedBy) {\n            if (Array.isArray(json)) {\n              var sortedJson = Object(util[\"sort\"])(json, sortedBy.path, sortedBy.direction);\n              me.sortedBy = sortedBy;\n              me.set(sortedJson);\n            }\n\n            if (Object(util[\"isObject\"])(json)) {\n              var _sortedJson = Object(util[\"sortObjectKeys\"])(json, sortedBy.direction);\n\n              me.sortedBy = sortedBy;\n              me.set(_sortedJson);\n            }\n          }\n\n          Object(showSortModal[\"a\"\n          /* showSortModal */\n          ])(container, json, onSort, me.sortedBy);\n        };\n        /**\n         * Open a transform modal\n         * @private\n         */\n\n\n        textmode._showTransformModal = function () {\n          var me = this;\n          var anchor = this.options.modalAnchor || constants[\"a\"\n          /* DEFAULT_MODAL_ANCHOR */\n          ];\n          var json = this.get();\n          Object(showTransformModal[\"a\"\n          /* showTransformModal */\n          ])(anchor, json, function (query) {\n            var updatedJson = jmespath_default.a.search(json, query);\n            me.set(updatedJson);\n          });\n        };\n        /**\n         * Handle text selection\n         * Calculates the cursor position and selection range and updates menu\n         * @private\n         */\n\n\n        textmode._onSelect = function () {\n          this._updateCursorInfo();\n\n          this._emitSelectionChange();\n        };\n        /**\n         * Event handler for keydown. Handles shortcut keys\n         * @param {Event} event\n         * @private\n         */\n\n\n        textmode._onKeyDown = function (event) {\n          var keynum = event.which || event.keyCode;\n          var handled = false;\n\n          if (keynum === 220 && event.ctrlKey) {\n            if (event.shiftKey) {\n              // Ctrl+Shift+\\\n              this.compact();\n\n              this._onChange();\n            } else {\n              // Ctrl+\\\n              this.format();\n\n              this._onChange();\n            }\n\n            handled = true;\n          }\n\n          if (handled) {\n            event.preventDefault();\n            event.stopPropagation();\n          }\n\n          this._updateCursorInfo();\n\n          this._emitSelectionChange();\n        };\n        /**\n         * Event handler for mousedown.\n         * @private\n         */\n\n\n        textmode._onMouseDown = function () {\n          this._updateCursorInfo();\n\n          this._emitSelectionChange();\n        };\n        /**\n         * Event handler for blur.\n         * @private\n         */\n\n\n        textmode._onBlur = function () {\n          var me = this; // this allows to avoid blur when clicking inner elements (like the errors panel)\n          // just make sure to set the isFocused to true on the inner element onclick callback\n\n          setTimeout(function () {\n            if (!me.isFocused) {\n              me._updateCursorInfo();\n\n              me._emitSelectionChange();\n            }\n\n            me.isFocused = false;\n          });\n        };\n        /**\n         * Update the cursor info and the status bar, if presented\n         */\n\n\n        textmode._updateCursorInfo = function () {\n          var me = this;\n          var line, col, count;\n\n          if (this.textarea) {\n            setTimeout(function () {\n              // this to verify we get the most updated textarea cursor selection\n              var selectionRange = Object(util[\"getInputSelection\"])(me.textarea);\n\n              if (selectionRange.startIndex !== selectionRange.endIndex) {\n                count = selectionRange.endIndex - selectionRange.startIndex;\n              }\n\n              if (count && me.cursorInfo && me.cursorInfo.line === selectionRange.end.row && me.cursorInfo.column === selectionRange.end.column) {\n                line = selectionRange.start.row;\n                col = selectionRange.start.column;\n              } else {\n                line = selectionRange.end.row;\n                col = selectionRange.end.column;\n              }\n\n              me.cursorInfo = {\n                line: line,\n                column: col,\n                count: count\n              };\n\n              if (me.options.statusBar) {\n                updateDisplay();\n              }\n            }, 0);\n          } else if (this.aceEditor && this.curserInfoElements) {\n            var curserPos = this.aceEditor.getCursorPosition();\n            var selectedText = this.aceEditor.getSelectedText();\n            line = curserPos.row + 1;\n            col = curserPos.column + 1;\n            count = selectedText.length;\n            me.cursorInfo = {\n              line: line,\n              column: col,\n              count: count\n            };\n\n            if (this.options.statusBar) {\n              updateDisplay();\n            }\n          }\n\n          function updateDisplay() {\n            if (me.curserInfoElements.countVal.innerText !== count) {\n              me.curserInfoElements.countVal.innerText = count;\n              me.curserInfoElements.countVal.style.display = count ? 'inline' : 'none';\n              me.curserInfoElements.countLabel.style.display = count ? 'inline' : 'none';\n            }\n\n            me.curserInfoElements.lnVal.innerText = line;\n            me.curserInfoElements.colVal.innerText = col;\n          }\n        };\n        /**\n         * emits selection change callback, if given\n         * @private\n         */\n\n\n        textmode._emitSelectionChange = function () {\n          if (this._selectionChangedHandler) {\n            var currentSelection = this.getTextSelection();\n\n            this._selectionChangedHandler(currentSelection.start, currentSelection.end, currentSelection.text);\n          }\n        };\n        /**\n         * refresh ERROR annotations state\n         * error annotations are handled by the ace json mode (ace/mode/json)\n         * validation annotations are handled by this mode\n         * therefore in order to refresh we send only the annotations of error type in order to maintain its state\n         * @private\n         */\n\n\n        textmode._refreshAnnotations = function () {\n          var session = this.aceEditor && this.aceEditor.getSession();\n\n          if (session) {\n            var errEnnotations = session.getAnnotations().filter(function (annotation) {\n              return annotation.type === 'error';\n            });\n            session.setAnnotations(errEnnotations);\n          }\n        };\n        /**\n         * Destroy the editor. Clean up DOM, event listeners, and web workers.\n         */\n\n\n        textmode.destroy = function () {\n          // remove old ace editor\n          if (this.aceEditor) {\n            this.aceEditor.destroy();\n            this.aceEditor = null;\n          }\n\n          if (this.frame && this.container && this.frame.parentNode === this.container) {\n            this.container.removeChild(this.frame);\n          }\n\n          if (this.modeSwitcher) {\n            this.modeSwitcher.destroy();\n            this.modeSwitcher = null;\n          }\n\n          this.textarea = null;\n          this._debouncedValidate = null;\n        };\n        /**\n         * Compact the code in the text editor\n         */\n\n\n        textmode.compact = function () {\n          var json = this.get();\n          var text = JSON.stringify(json);\n\n          this._setText(text, false);\n        };\n        /**\n         * Format the code in the text editor\n         */\n\n\n        textmode.format = function () {\n          var json = this.get();\n          var text = JSON.stringify(json, null, this.indentation);\n\n          this._setText(text, false);\n        };\n        /**\n         * Repair the code in the text editor\n         */\n\n\n        textmode.repair = function () {\n          var text = this.getText();\n          var repairedText = Object(util[\"repair\"])(text);\n\n          this._setText(repairedText, false);\n        };\n        /**\n         * Set focus to the formatter\n         */\n\n\n        textmode.focus = function () {\n          if (this.textarea) {\n            this.textarea.focus();\n          }\n\n          if (this.aceEditor) {\n            this.aceEditor.focus();\n          }\n        };\n        /**\n         * Resize the formatter\n         */\n\n\n        textmode.resize = function () {\n          if (this.aceEditor) {\n            var force = false;\n            this.aceEditor.resize(force);\n          }\n        };\n        /**\n         * Set json data in the formatter\n         * @param {*} json\n         */\n\n\n        textmode.set = function (json) {\n          this.setText(JSON.stringify(json, null, this.indentation));\n        };\n        /**\n         * Update data. Same as calling `set` in text/code mode.\n         * @param {*} json\n         */\n\n\n        textmode.update = function (json) {\n          this.updateText(JSON.stringify(json, null, this.indentation));\n        };\n        /**\n         * Get json data from the formatter\n         * @return {*} json\n         */\n\n\n        textmode.get = function () {\n          var text = this.getText();\n          return Object(util[\"parse\"])(text); // this can throw an error\n        };\n        /**\n         * Get the text contents of the editor\n         * @return {String} jsonText\n         */\n\n\n        textmode.getText = function () {\n          if (this.textarea) {\n            return this.textarea.value;\n          }\n\n          if (this.aceEditor) {\n            return this.aceEditor.getValue();\n          }\n\n          return '';\n        };\n        /**\n         * Set the text contents of the editor and optionally clear the history\n         * @param {String} jsonText\n         * @param {boolean} clearHistory   Only applicable for mode 'code'\n         * @private\n         */\n\n\n        textmode._setText = function (jsonText, clearHistory) {\n          var text = this.options.escapeUnicode === true ? Object(util[\"escapeUnicodeChars\"])(jsonText) : jsonText;\n\n          if (this.textarea) {\n            this.textarea.value = text;\n          }\n\n          if (this.aceEditor) {\n            // prevent emitting onChange events while setting new text\n            this.onChangeDisabled = true;\n            this.aceEditor.setValue(text, -1);\n            this.onChangeDisabled = false;\n\n            if (clearHistory) {\n              // prevent initial undo action clearing the initial contents\n              var me = this;\n              setTimeout(function () {\n                if (me.aceEditor) {\n                  me.aceEditor.session.getUndoManager().reset();\n                }\n              }, 0);\n            }\n          } // validate JSON schema\n\n\n          this._debouncedValidate();\n        };\n        /**\n         * Set the text contents of the editor\n         * @param {String} jsonText\n         */\n\n\n        textmode.setText = function (jsonText) {\n          this._setText(jsonText, true);\n        };\n        /**\n         * Update the text contents\n         * @param {string} jsonText\n         */\n\n\n        textmode.updateText = function (jsonText) {\n          // don't update if there are no changes\n          if (this.getText() === jsonText) {\n            return;\n          }\n\n          this._setText(jsonText, false);\n        };\n        /**\n         * Validate current JSON object against the configured JSON schema\n         * Throws an exception when no JSON schema is configured\n         */\n\n\n        textmode.validate = function () {\n          var schemaErrors = [];\n          var parseErrors = [];\n          var json;\n\n          try {\n            json = this.get(); // this can fail when there is no valid json\n            // execute JSON schema validation (ajv)\n\n            if (this.validateSchema) {\n              var valid = this.validateSchema(json);\n\n              if (!valid) {\n                schemaErrors = this.validateSchema.errors.map(function (error) {\n                  error.type = 'validation';\n                  return Object(util[\"improveSchemaError\"])(error);\n                });\n              }\n            } // execute custom validation and after than merge and render all errors\n            // TODO: implement a better mechanism for only using the last validation action\n\n\n            this.validationSequence = (this.validationSequence || 0) + 1;\n            var me = this;\n            var seq = this.validationSequence;\n            validateCustom(json, this.options.onValidate).then(function (customValidationErrors) {\n              // only apply when there was no other validation started whilst resolving async results\n              if (seq === me.validationSequence) {\n                var errors = schemaErrors.concat(parseErrors).concat(customValidationErrors);\n\n                me._renderErrors(errors);\n              }\n            })[\"catch\"](function (err) {\n              console.error('Custom validation function did throw an error', err);\n            });\n          } catch (err) {\n            if (this.getText()) {\n              // try to extract the line number from the jsonlint error message\n              var match = /\\w*line\\s*(\\d+)\\w*/g.exec(err.message);\n              var line;\n\n              if (match) {\n                line = +match[1];\n              }\n\n              parseErrors = [{\n                type: 'error',\n                message: err.message.replace(/\\n/g, '<br>'),\n                line: line\n              }];\n            }\n\n            this._renderErrors(parseErrors);\n          }\n        };\n\n        textmode._renderErrors = function (errors) {\n          var jsonText = this.getText();\n          var errorPaths = [];\n          errors.reduce(function (acc, curr) {\n            if (acc.indexOf(curr.dataPath) === -1) {\n              acc.push(curr.dataPath);\n            }\n\n            return acc;\n          }, errorPaths);\n          var errorLocations = Object(util[\"getPositionForPath\"])(jsonText, errorPaths); // render annotations in Ace Editor (if any)\n\n          if (this.aceEditor) {\n            this.annotations = errorLocations.map(function (errLoc) {\n              var validationErrors = errors.filter(function (err) {\n                return err.dataPath === errLoc.path;\n              });\n              var message = validationErrors.map(function (err) {\n                return err.message;\n              }).join('\\n');\n\n              if (message) {\n                return {\n                  row: errLoc.line,\n                  column: errLoc.column,\n                  text: 'Schema validation error' + (validationErrors.length !== 1 ? 's' : '') + ': \\n' + message,\n                  type: 'warning',\n                  source: 'jsoneditor'\n                };\n              }\n\n              return {};\n            });\n\n            this._refreshAnnotations();\n          } // render errors in the errors table (if any)\n\n\n          this.errorTable.setErrors(errors, errorLocations); // update the height of the ace editor\n\n          if (this.aceEditor) {\n            var force = false;\n            this.aceEditor.resize(force);\n          }\n        };\n        /**\n         * Get the selection details\n         * @returns {{start:{row:Number, column:Number},end:{row:Number, column:Number},text:String}}\n         */\n\n\n        textmode.getTextSelection = function () {\n          var selection = {};\n\n          if (this.textarea) {\n            var selectionRange = Object(util[\"getInputSelection\"])(this.textarea);\n\n            if (this.cursorInfo && this.cursorInfo.line === selectionRange.end.row && this.cursorInfo.column === selectionRange.end.column) {\n              // selection direction is bottom => up\n              selection.start = selectionRange.end;\n              selection.end = selectionRange.start;\n            } else {\n              selection = selectionRange;\n            }\n\n            return {\n              start: selection.start,\n              end: selection.end,\n              text: this.textarea.value.substring(selectionRange.startIndex, selectionRange.endIndex)\n            };\n          }\n\n          if (this.aceEditor) {\n            var aceSelection = this.aceEditor.getSelection();\n            var selectedText = this.aceEditor.getSelectedText();\n            var range = aceSelection.getRange();\n            var lead = aceSelection.getSelectionLead();\n\n            if (lead.row === range.end.row && lead.column === range.end.column) {\n              selection = range;\n            } else {\n              // selection direction is bottom => up\n              selection.start = range.end;\n              selection.end = range.start;\n            }\n\n            return {\n              start: {\n                row: selection.start.row + 1,\n                column: selection.start.column + 1\n              },\n              end: {\n                row: selection.end.row + 1,\n                column: selection.end.column + 1\n              },\n              text: selectedText\n            };\n          }\n        };\n        /**\n         * Callback registration for selection change\n         * @param {selectionCallback} callback\n         *\n         * @callback selectionCallback\n         */\n\n\n        textmode.onTextSelectionChange = function (callback) {\n          if (typeof callback === 'function') {\n            this._selectionChangedHandler = Object(util[\"debounce\"])(callback, this.DEBOUNCE_INTERVAL);\n          }\n        };\n        /**\n         * Set selection on editor's text\n         * @param {{row:Number, column:Number}} startPos selection start position\n         * @param {{row:Number, column:Number}} endPos selected end position\n         */\n\n\n        textmode.setTextSelection = function (startPos, endPos) {\n          if (!startPos || !endPos) return;\n\n          if (this.textarea) {\n            var startIndex = Object(util[\"getIndexForPosition\"])(this.textarea, startPos.row, startPos.column);\n            var endIndex = Object(util[\"getIndexForPosition\"])(this.textarea, endPos.row, endPos.column);\n\n            if (startIndex > -1 && endIndex > -1) {\n              if (this.textarea.setSelectionRange) {\n                this.textarea.focus();\n                this.textarea.setSelectionRange(startIndex, endIndex);\n              } else if (this.textarea.createTextRange) {\n                // IE < 9\n                var range = this.textarea.createTextRange();\n                range.collapse(true);\n                range.moveEnd('character', endIndex);\n                range.moveStart('character', startIndex);\n                range.select();\n              }\n\n              var rows = (this.textarea.value.match(/\\n/g) || []).length + 1;\n              var lineHeight = this.textarea.scrollHeight / rows;\n              var selectionScrollPos = startPos.row * lineHeight;\n              this.textarea.scrollTop = selectionScrollPos > this.textarea.clientHeight ? selectionScrollPos - this.textarea.clientHeight / 2 : 0;\n            }\n          } else if (this.aceEditor) {\n            var _range = {\n              start: {\n                row: startPos.row - 1,\n                column: startPos.column - 1\n              },\n              end: {\n                row: endPos.row - 1,\n                column: endPos.column - 1\n              }\n            };\n            this.aceEditor.selection.setRange(_range);\n            this.aceEditor.scrollToLine(startPos.row - 1, true);\n          }\n        };\n\n        function load() {\n          try {\n            this.format();\n          } catch (err) {// in case of an error, just move on, failing formatting is not a big deal\n          }\n        } // define modes\n\n\n        var textModeMixins = [{\n          mode: 'text',\n          mixin: textmode,\n          data: 'text',\n          load: load\n        }, {\n          mode: 'code',\n          mixin: textmode,\n          data: 'text',\n          load: load\n        }];\n        /***/\n      },\n      /* 16 */\n\n      /***/\n      function (module, exports, __webpack_require__) {\n        /* Jison generated parser */\n        var jsonlint = function () {\n          var parser = {\n            trace: function trace() {},\n            yy: {},\n            symbols_: {\n              \"error\": 2,\n              \"JSONString\": 3,\n              \"STRING\": 4,\n              \"JSONNumber\": 5,\n              \"NUMBER\": 6,\n              \"JSONNullLiteral\": 7,\n              \"NULL\": 8,\n              \"JSONBooleanLiteral\": 9,\n              \"TRUE\": 10,\n              \"FALSE\": 11,\n              \"JSONText\": 12,\n              \"JSONValue\": 13,\n              \"EOF\": 14,\n              \"JSONObject\": 15,\n              \"JSONArray\": 16,\n              \"{\": 17,\n              \"}\": 18,\n              \"JSONMemberList\": 19,\n              \"JSONMember\": 20,\n              \":\": 21,\n              \",\": 22,\n              \"[\": 23,\n              \"]\": 24,\n              \"JSONElementList\": 25,\n              \"$accept\": 0,\n              \"$end\": 1\n            },\n            terminals_: {\n              2: \"error\",\n              4: \"STRING\",\n              6: \"NUMBER\",\n              8: \"NULL\",\n              10: \"TRUE\",\n              11: \"FALSE\",\n              14: \"EOF\",\n              17: \"{\",\n              18: \"}\",\n              21: \":\",\n              22: \",\",\n              23: \"[\",\n              24: \"]\"\n            },\n            productions_: [0, [3, 1], [5, 1], [7, 1], [9, 1], [9, 1], [12, 2], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [15, 2], [15, 3], [20, 3], [19, 1], [19, 3], [16, 2], [16, 3], [25, 1], [25, 3]],\n            performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {\n              var $0 = $$.length - 1;\n\n              switch (yystate) {\n                case 1:\n                  // replace escaped characters with actual character\n                  this.$ = yytext.replace(/\\\\(\\\\|\")/g, \"$\" + \"1\").replace(/\\\\n/g, '\\n').replace(/\\\\r/g, '\\r').replace(/\\\\t/g, '\\t').replace(/\\\\v/g, '\\v').replace(/\\\\f/g, '\\f').replace(/\\\\b/g, '\\b');\n                  break;\n\n                case 2:\n                  this.$ = Number(yytext);\n                  break;\n\n                case 3:\n                  this.$ = null;\n                  break;\n\n                case 4:\n                  this.$ = true;\n                  break;\n\n                case 5:\n                  this.$ = false;\n                  break;\n\n                case 6:\n                  return this.$ = $$[$0 - 1];\n                  break;\n\n                case 13:\n                  this.$ = {};\n                  break;\n\n                case 14:\n                  this.$ = $$[$0 - 1];\n                  break;\n\n                case 15:\n                  this.$ = [$$[$0 - 2], $$[$0]];\n                  break;\n\n                case 16:\n                  this.$ = {};\n                  this.$[$$[$0][0]] = $$[$0][1];\n                  break;\n\n                case 17:\n                  this.$ = $$[$0 - 2];\n                  $$[$0 - 2][$$[$0][0]] = $$[$0][1];\n                  break;\n\n                case 18:\n                  this.$ = [];\n                  break;\n\n                case 19:\n                  this.$ = $$[$0 - 1];\n                  break;\n\n                case 20:\n                  this.$ = [$$[$0]];\n                  break;\n\n                case 21:\n                  this.$ = $$[$0 - 2];\n                  $$[$0 - 2].push($$[$0]);\n                  break;\n              }\n            },\n            table: [{\n              3: 5,\n              4: [1, 12],\n              5: 6,\n              6: [1, 13],\n              7: 3,\n              8: [1, 9],\n              9: 4,\n              10: [1, 10],\n              11: [1, 11],\n              12: 1,\n              13: 2,\n              15: 7,\n              16: 8,\n              17: [1, 14],\n              23: [1, 15]\n            }, {\n              1: [3]\n            }, {\n              14: [1, 16]\n            }, {\n              14: [2, 7],\n              18: [2, 7],\n              22: [2, 7],\n              24: [2, 7]\n            }, {\n              14: [2, 8],\n              18: [2, 8],\n              22: [2, 8],\n              24: [2, 8]\n            }, {\n              14: [2, 9],\n              18: [2, 9],\n              22: [2, 9],\n              24: [2, 9]\n            }, {\n              14: [2, 10],\n              18: [2, 10],\n              22: [2, 10],\n              24: [2, 10]\n            }, {\n              14: [2, 11],\n              18: [2, 11],\n              22: [2, 11],\n              24: [2, 11]\n            }, {\n              14: [2, 12],\n              18: [2, 12],\n              22: [2, 12],\n              24: [2, 12]\n            }, {\n              14: [2, 3],\n              18: [2, 3],\n              22: [2, 3],\n              24: [2, 3]\n            }, {\n              14: [2, 4],\n              18: [2, 4],\n              22: [2, 4],\n              24: [2, 4]\n            }, {\n              14: [2, 5],\n              18: [2, 5],\n              22: [2, 5],\n              24: [2, 5]\n            }, {\n              14: [2, 1],\n              18: [2, 1],\n              21: [2, 1],\n              22: [2, 1],\n              24: [2, 1]\n            }, {\n              14: [2, 2],\n              18: [2, 2],\n              22: [2, 2],\n              24: [2, 2]\n            }, {\n              3: 20,\n              4: [1, 12],\n              18: [1, 17],\n              19: 18,\n              20: 19\n            }, {\n              3: 5,\n              4: [1, 12],\n              5: 6,\n              6: [1, 13],\n              7: 3,\n              8: [1, 9],\n              9: 4,\n              10: [1, 10],\n              11: [1, 11],\n              13: 23,\n              15: 7,\n              16: 8,\n              17: [1, 14],\n              23: [1, 15],\n              24: [1, 21],\n              25: 22\n            }, {\n              1: [2, 6]\n            }, {\n              14: [2, 13],\n              18: [2, 13],\n              22: [2, 13],\n              24: [2, 13]\n            }, {\n              18: [1, 24],\n              22: [1, 25]\n            }, {\n              18: [2, 16],\n              22: [2, 16]\n            }, {\n              21: [1, 26]\n            }, {\n              14: [2, 18],\n              18: [2, 18],\n              22: [2, 18],\n              24: [2, 18]\n            }, {\n              22: [1, 28],\n              24: [1, 27]\n            }, {\n              22: [2, 20],\n              24: [2, 20]\n            }, {\n              14: [2, 14],\n              18: [2, 14],\n              22: [2, 14],\n              24: [2, 14]\n            }, {\n              3: 20,\n              4: [1, 12],\n              20: 29\n            }, {\n              3: 5,\n              4: [1, 12],\n              5: 6,\n              6: [1, 13],\n              7: 3,\n              8: [1, 9],\n              9: 4,\n              10: [1, 10],\n              11: [1, 11],\n              13: 30,\n              15: 7,\n              16: 8,\n              17: [1, 14],\n              23: [1, 15]\n            }, {\n              14: [2, 19],\n              18: [2, 19],\n              22: [2, 19],\n              24: [2, 19]\n            }, {\n              3: 5,\n              4: [1, 12],\n              5: 6,\n              6: [1, 13],\n              7: 3,\n              8: [1, 9],\n              9: 4,\n              10: [1, 10],\n              11: [1, 11],\n              13: 31,\n              15: 7,\n              16: 8,\n              17: [1, 14],\n              23: [1, 15]\n            }, {\n              18: [2, 17],\n              22: [2, 17]\n            }, {\n              18: [2, 15],\n              22: [2, 15]\n            }, {\n              22: [2, 21],\n              24: [2, 21]\n            }],\n            defaultActions: {\n              16: [2, 6]\n            },\n            parseError: function parseError(str, hash) {\n              throw new Error(str);\n            },\n            parse: function parse(input) {\n              var self = this,\n                  stack = [0],\n                  vstack = [null],\n                  // semantic value stack\n              lstack = [],\n                  // location stack\n              table = this.table,\n                  yytext = '',\n                  yylineno = 0,\n                  yyleng = 0,\n                  recovering = 0,\n                  TERROR = 2,\n                  EOF = 1; //this.reductionCount = this.shiftCount = 0;\n\n              this.lexer.setInput(input);\n              this.lexer.yy = this.yy;\n              this.yy.lexer = this.lexer;\n              if (typeof this.lexer.yylloc == 'undefined') this.lexer.yylloc = {};\n              var yyloc = this.lexer.yylloc;\n              lstack.push(yyloc);\n              if (typeof this.yy.parseError === 'function') this.parseError = this.yy.parseError;\n\n              function popStack(n) {\n                stack.length = stack.length - 2 * n;\n                vstack.length = vstack.length - n;\n                lstack.length = lstack.length - n;\n              }\n\n              function lex() {\n                var token;\n                token = self.lexer.lex() || 1; // $end = 1\n                // if token isn't its numeric value, convert\n\n                if (typeof token !== 'number') {\n                  token = self.symbols_[token] || token;\n                }\n\n                return token;\n              }\n\n              var symbol,\n                  preErrorSymbol,\n                  state,\n                  action,\n                  r,\n                  yyval = {},\n                  p,\n                  len,\n                  newState,\n                  expected;\n\n              while (true) {\n                // retreive state number from top of stack\n                state = stack[stack.length - 1]; // use default actions if available\n\n                if (this.defaultActions[state]) {\n                  action = this.defaultActions[state];\n                } else {\n                  if (symbol == null) symbol = lex(); // read action for current state and first input\n\n                  action = table[state] && table[state][symbol];\n                } // handle parse error\n\n\n                _handle_error: if (typeof action === 'undefined' || !action.length || !action[0]) {\n                  if (!recovering) {\n                    // Report error\n                    expected = [];\n\n                    for (p in table[state]) {\n                      if (this.terminals_[p] && p > 2) {\n                        expected.push(\"'\" + this.terminals_[p] + \"'\");\n                      }\n                    }\n\n                    var errStr = '';\n\n                    if (this.lexer.showPosition) {\n                      errStr = 'Parse error on line ' + (yylineno + 1) + \":\\n\" + this.lexer.showPosition() + \"\\nExpecting \" + expected.join(', ') + \", got '\" + this.terminals_[symbol] + \"'\";\n                    } else {\n                      errStr = 'Parse error on line ' + (yylineno + 1) + \": Unexpected \" + (symbol == 1\n                      /*EOF*/\n                      ? \"end of input\" : \"'\" + (this.terminals_[symbol] || symbol) + \"'\");\n                    }\n\n                    this.parseError(errStr, {\n                      text: this.lexer.match,\n                      token: this.terminals_[symbol] || symbol,\n                      line: this.lexer.yylineno,\n                      loc: yyloc,\n                      expected: expected\n                    });\n                  } // just recovered from another error\n\n\n                  if (recovering == 3) {\n                    if (symbol == EOF) {\n                      throw new Error(errStr || 'Parsing halted.');\n                    } // discard current lookahead and grab another\n\n\n                    yyleng = this.lexer.yyleng;\n                    yytext = this.lexer.yytext;\n                    yylineno = this.lexer.yylineno;\n                    yyloc = this.lexer.yylloc;\n                    symbol = lex();\n                  } // try to recover from error\n\n\n                  while (1) {\n                    // check for error recovery rule in this state\n                    if (TERROR.toString() in table[state]) {\n                      break;\n                    }\n\n                    if (state == 0) {\n                      throw new Error(errStr || 'Parsing halted.');\n                    }\n\n                    popStack(1);\n                    state = stack[stack.length - 1];\n                  }\n\n                  preErrorSymbol = symbol; // save the lookahead token\n\n                  symbol = TERROR; // insert generic error symbol as new lookahead\n\n                  state = stack[stack.length - 1];\n                  action = table[state] && table[state][TERROR];\n                  recovering = 3; // allow 3 real symbols to be shifted before reporting a new error\n                } // this shouldn't happen, unless resolve defaults are off\n\n\n                if (action[0] instanceof Array && action.length > 1) {\n                  throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n                }\n\n                switch (action[0]) {\n                  case 1:\n                    // shift\n                    //this.shiftCount++;\n                    stack.push(symbol);\n                    vstack.push(this.lexer.yytext);\n                    lstack.push(this.lexer.yylloc);\n                    stack.push(action[1]); // push state\n\n                    symbol = null;\n\n                    if (!preErrorSymbol) {\n                      // normal execution/no error\n                      yyleng = this.lexer.yyleng;\n                      yytext = this.lexer.yytext;\n                      yylineno = this.lexer.yylineno;\n                      yyloc = this.lexer.yylloc;\n                      if (recovering > 0) recovering--;\n                    } else {\n                      // error just occurred, resume old lookahead f/ before error\n                      symbol = preErrorSymbol;\n                      preErrorSymbol = null;\n                    }\n\n                    break;\n\n                  case 2:\n                    // reduce\n                    //this.reductionCount++;\n                    len = this.productions_[action[1]][1]; // perform semantic action\n\n                    yyval.$ = vstack[vstack.length - len]; // default to $$ = $1\n                    // default location, uses first token for firsts, last for lasts\n\n                    yyval._$ = {\n                      first_line: lstack[lstack.length - (len || 1)].first_line,\n                      last_line: lstack[lstack.length - 1].last_line,\n                      first_column: lstack[lstack.length - (len || 1)].first_column,\n                      last_column: lstack[lstack.length - 1].last_column\n                    };\n                    r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);\n\n                    if (typeof r !== 'undefined') {\n                      return r;\n                    } // pop off stack\n\n\n                    if (len) {\n                      stack = stack.slice(0, -1 * len * 2);\n                      vstack = vstack.slice(0, -1 * len);\n                      lstack = lstack.slice(0, -1 * len);\n                    }\n\n                    stack.push(this.productions_[action[1]][0]); // push nonterminal (reduce)\n\n                    vstack.push(yyval.$);\n                    lstack.push(yyval._$); // goto new state = table[STATE][NONTERMINAL]\n\n                    newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n                    stack.push(newState);\n                    break;\n\n                  case 3:\n                    // accept\n                    return true;\n                }\n              }\n\n              return true;\n            }\n          };\n          /* Jison generated lexer */\n\n          var lexer = function () {\n            var lexer = {\n              EOF: 1,\n              parseError: function parseError(str, hash) {\n                if (this.yy.parseError) {\n                  this.yy.parseError(str, hash);\n                } else {\n                  throw new Error(str);\n                }\n              },\n              setInput: function setInput(input) {\n                this._input = input;\n                this._more = this._less = this.done = false;\n                this.yylineno = this.yyleng = 0;\n                this.yytext = this.matched = this.match = '';\n                this.conditionStack = ['INITIAL'];\n                this.yylloc = {\n                  first_line: 1,\n                  first_column: 0,\n                  last_line: 1,\n                  last_column: 0\n                };\n                return this;\n              },\n              input: function input() {\n                var ch = this._input[0];\n                this.yytext += ch;\n                this.yyleng++;\n                this.match += ch;\n                this.matched += ch;\n                var lines = ch.match(/\\n/);\n                if (lines) this.yylineno++;\n                this._input = this._input.slice(1);\n                return ch;\n              },\n              unput: function unput(ch) {\n                this._input = ch + this._input;\n                return this;\n              },\n              more: function more() {\n                this._more = true;\n                return this;\n              },\n              less: function less(n) {\n                this._input = this.match.slice(n) + this._input;\n              },\n              pastInput: function pastInput() {\n                var past = this.matched.substr(0, this.matched.length - this.match.length);\n                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\\n/g, \"\");\n              },\n              upcomingInput: function upcomingInput() {\n                var next = this.match;\n\n                if (next.length < 20) {\n                  next += this._input.substr(0, 20 - next.length);\n                }\n\n                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n              },\n              showPosition: function showPosition() {\n                var pre = this.pastInput();\n                var c = new Array(pre.length + 1).join(\"-\");\n                return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n              },\n              next: function next() {\n                if (this.done) {\n                  return this.EOF;\n                }\n\n                if (!this._input) this.done = true;\n                var token, match, tempMatch, index, lines;\n\n                if (!this._more) {\n                  this.yytext = '';\n                  this.match = '';\n                }\n\n                var rules = this._currentRules();\n\n                for (var i = 0; i < rules.length; i++) {\n                  tempMatch = this._input.match(this.rules[rules[i]]);\n\n                  if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                    match = tempMatch;\n                    index = i;\n                    if (!this.options.flex) break;\n                  }\n                }\n\n                if (match) {\n                  lines = match[0].match(/\\n.*/g);\n                  if (lines) this.yylineno += lines.length;\n                  this.yylloc = {\n                    first_line: this.yylloc.last_line,\n                    last_line: this.yylineno + 1,\n                    first_column: this.yylloc.last_column,\n                    last_column: lines ? lines[lines.length - 1].length - 1 : this.yylloc.last_column + match[0].length\n                  };\n                  this.yytext += match[0];\n                  this.match += match[0];\n                  this.yyleng = this.yytext.length;\n                  this._more = false;\n                  this._input = this._input.slice(match[0].length);\n                  this.matched += match[0];\n                  token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);\n                  if (this.done && this._input) this.done = false;\n                  if (token) return token;else return;\n                }\n\n                if (this._input === \"\") {\n                  return this.EOF;\n                } else {\n                  this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                    text: \"\",\n                    token: null,\n                    line: this.yylineno\n                  });\n                }\n              },\n              lex: function lex() {\n                var r = this.next();\n\n                if (typeof r !== 'undefined') {\n                  return r;\n                } else {\n                  return this.lex();\n                }\n              },\n              begin: function begin(condition) {\n                this.conditionStack.push(condition);\n              },\n              popState: function popState() {\n                return this.conditionStack.pop();\n              },\n              _currentRules: function _currentRules() {\n                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n              },\n              topState: function topState() {\n                return this.conditionStack[this.conditionStack.length - 2];\n              },\n              pushState: function begin(condition) {\n                this.begin(condition);\n              }\n            };\n            lexer.options = {};\n\n            lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {\n              switch ($avoiding_name_collisions) {\n                case 0:\n                  /* skip whitespace */\n                  break;\n\n                case 1:\n                  return 6;\n                  break;\n\n                case 2:\n                  yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2);\n                  return 4;\n                  break;\n\n                case 3:\n                  return 17;\n                  break;\n\n                case 4:\n                  return 18;\n                  break;\n\n                case 5:\n                  return 23;\n                  break;\n\n                case 6:\n                  return 24;\n                  break;\n\n                case 7:\n                  return 22;\n                  break;\n\n                case 8:\n                  return 21;\n                  break;\n\n                case 9:\n                  return 10;\n                  break;\n\n                case 10:\n                  return 11;\n                  break;\n\n                case 11:\n                  return 8;\n                  break;\n\n                case 12:\n                  return 14;\n                  break;\n\n                case 13:\n                  return 'INVALID';\n                  break;\n              }\n            };\n\n            lexer.rules = [/^(?:\\s+)/, /^(?:(-?([0-9]|[1-9][0-9]+))(\\.[0-9]+)?([eE][-+]?[0-9]+)?\\b)/, /^(?:\"(?:\\\\[\\\\\"bfnrt/]|\\\\u[a-fA-F0-9]{4}|[^\\\\\\0-\\x09\\x0a-\\x1f\"])*\")/, /^(?:\\{)/, /^(?:\\})/, /^(?:\\[)/, /^(?:\\])/, /^(?:,)/, /^(?::)/, /^(?:true\\b)/, /^(?:false\\b)/, /^(?:null\\b)/, /^(?:$)/, /^(?:.)/];\n            lexer.conditions = {\n              \"INITIAL\": {\n                \"rules\": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],\n                \"inclusive\": true\n              }\n            };\n            return lexer;\n          }();\n\n          parser.lexer = lexer;\n          return parser;\n        }();\n\n        {\n          exports.parser = jsonlint;\n          exports.parse = jsonlint.parse.bind(jsonlint);\n        }\n        /***/\n      },\n      /* 17 */\n\n      /***/\n      function (module, exports) {\n        if (typeof Element !== 'undefined') {\n          // Polyfill for array remove\n          (function () {\n            function polyfill(item) {\n              if ('remove' in item) {\n                return;\n              }\n\n              Object.defineProperty(item, 'remove', {\n                configurable: true,\n                enumerable: true,\n                writable: true,\n                value: function remove() {\n                  if (this.parentNode !== undefined) {\n                    this.parentNode.removeChild(this);\n                  }\n                }\n              });\n            }\n\n            if (typeof window.Element !== 'undefined') {\n              polyfill(window.Element.prototype);\n            }\n\n            if (typeof window.CharacterData !== 'undefined') {\n              polyfill(window.CharacterData.prototype);\n            }\n\n            if (typeof window.DocumentType !== 'undefined') {\n              polyfill(window.DocumentType.prototype);\n            }\n          })();\n        } // Polyfill for Array.find\n\n\n        if (!Array.prototype.find) {\n          // eslint-disable-next-line no-extend-native\n          Array.prototype.find = function (callback) {\n            for (var i = 0; i < this.length; i++) {\n              var element = this[i];\n\n              if (callback.call(this, element, i, this)) {\n                return element;\n              }\n            }\n          };\n        } // Polyfill for String.trim\n\n\n        if (!String.prototype.trim) {\n          // eslint-disable-next-line no-extend-native\n          String.prototype.trim = function () {\n            return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n          };\n        }\n        /***/\n\n      },\n      /* 18 */\n\n      /***/\n      function (module, exports, __webpack_require__) {\n        var escapedChars = {\n          'b': '\\b',\n          'f': '\\f',\n          'n': '\\n',\n          'r': '\\r',\n          't': '\\t',\n          '\"': '\"',\n          '/': '/',\n          '\\\\': '\\\\'\n        };\n        var A_CODE = 'a'.charCodeAt();\n\n        exports.parse = function (source, _, options) {\n          var pointers = {};\n          var line = 0;\n          var column = 0;\n          var pos = 0;\n          var bigint = options && options.bigint && typeof BigInt != 'undefined';\n          return {\n            data: _parse('', true),\n            pointers: pointers\n          };\n\n          function _parse(ptr, topLevel) {\n            whitespace();\n            var data;\n            map(ptr, 'value');\n            var char = getChar();\n\n            switch (char) {\n              case 't':\n                read('rue');\n                data = true;\n                break;\n\n              case 'f':\n                read('alse');\n                data = false;\n                break;\n\n              case 'n':\n                read('ull');\n                data = null;\n                break;\n\n              case '\"':\n                data = parseString();\n                break;\n\n              case '[':\n                data = parseArray(ptr);\n                break;\n\n              case '{':\n                data = parseObject(ptr);\n                break;\n\n              default:\n                backChar();\n                if ('-0123456789'.indexOf(char) >= 0) data = parseNumber();else unexpectedToken();\n            }\n\n            map(ptr, 'valueEnd');\n            whitespace();\n            if (topLevel && pos < source.length) unexpectedToken();\n            return data;\n          }\n\n          function whitespace() {\n            loop: while (pos < source.length) {\n              switch (source[pos]) {\n                case ' ':\n                  column++;\n                  break;\n\n                case '\\t':\n                  column += 4;\n                  break;\n\n                case '\\r':\n                  column = 0;\n                  break;\n\n                case '\\n':\n                  column = 0;\n                  line++;\n                  break;\n\n                default:\n                  break loop;\n              }\n\n              pos++;\n            }\n          }\n\n          function parseString() {\n            var str = '';\n            var char;\n\n            while (true) {\n              char = getChar();\n\n              if (char == '\"') {\n                break;\n              } else if (char == '\\\\') {\n                char = getChar();\n                if (char in escapedChars) str += escapedChars[char];else if (char == 'u') str += getCharCode();else wasUnexpectedToken();\n              } else {\n                str += char;\n              }\n            }\n\n            return str;\n          }\n\n          function parseNumber() {\n            var numStr = '';\n            var integer = true;\n            if (source[pos] == '-') numStr += getChar();\n            numStr += source[pos] == '0' ? getChar() : getDigits();\n\n            if (source[pos] == '.') {\n              numStr += getChar() + getDigits();\n              integer = false;\n            }\n\n            if (source[pos] == 'e' || source[pos] == 'E') {\n              numStr += getChar();\n              if (source[pos] == '+' || source[pos] == '-') numStr += getChar();\n              numStr += getDigits();\n              integer = false;\n            }\n\n            var result = +numStr;\n            return bigint && integer && (result > Number.MAX_SAFE_INTEGER || result < Number.MIN_SAFE_INTEGER) ? BigInt(numStr) : result;\n          }\n\n          function parseArray(ptr) {\n            whitespace();\n            var arr = [];\n            var i = 0;\n            if (getChar() == ']') return arr;\n            backChar();\n\n            while (true) {\n              var itemPtr = ptr + '/' + i;\n              arr.push(_parse(itemPtr));\n              whitespace();\n              var char = getChar();\n              if (char == ']') break;\n              if (char != ',') wasUnexpectedToken();\n              whitespace();\n              i++;\n            }\n\n            return arr;\n          }\n\n          function parseObject(ptr) {\n            whitespace();\n            var obj = {};\n            if (getChar() == '}') return obj;\n            backChar();\n\n            while (true) {\n              var loc = getLoc();\n              if (getChar() != '\"') wasUnexpectedToken();\n              var key = parseString();\n              var propPtr = ptr + '/' + escapeJsonPointer(key);\n              mapLoc(propPtr, 'key', loc);\n              map(propPtr, 'keyEnd');\n              whitespace();\n              if (getChar() != ':') wasUnexpectedToken();\n              whitespace();\n              obj[key] = _parse(propPtr);\n              whitespace();\n              var char = getChar();\n              if (char == '}') break;\n              if (char != ',') wasUnexpectedToken();\n              whitespace();\n            }\n\n            return obj;\n          }\n\n          function read(str) {\n            for (var i = 0; i < str.length; i++) if (getChar() !== str[i]) wasUnexpectedToken();\n          }\n\n          function getChar() {\n            checkUnexpectedEnd();\n            var char = source[pos];\n            pos++;\n            column++; // new line?\n\n            return char;\n          }\n\n          function backChar() {\n            pos--;\n            column--;\n          }\n\n          function getCharCode() {\n            var count = 4;\n            var code = 0;\n\n            while (count--) {\n              code <<= 4;\n              var char = getChar().toLowerCase();\n              if (char >= 'a' && char <= 'f') code += char.charCodeAt() - A_CODE + 10;else if (char >= '0' && char <= '9') code += +char;else wasUnexpectedToken();\n            }\n\n            return String.fromCharCode(code);\n          }\n\n          function getDigits() {\n            var digits = '';\n\n            while (source[pos] >= '0' && source[pos] <= '9') digits += getChar();\n\n            if (digits.length) return digits;\n            checkUnexpectedEnd();\n            unexpectedToken();\n          }\n\n          function map(ptr, prop) {\n            mapLoc(ptr, prop, getLoc());\n          }\n\n          function mapLoc(ptr, prop, loc) {\n            pointers[ptr] = pointers[ptr] || {};\n            pointers[ptr][prop] = loc;\n          }\n\n          function getLoc() {\n            return {\n              line: line,\n              column: column,\n              pos: pos\n            };\n          }\n\n          function unexpectedToken() {\n            throw new SyntaxError('Unexpected token ' + source[pos] + ' in JSON at position ' + pos);\n          }\n\n          function wasUnexpectedToken() {\n            backChar();\n            unexpectedToken();\n          }\n\n          function checkUnexpectedEnd() {\n            if (pos >= source.length) throw new SyntaxError('Unexpected end of JSON input');\n          }\n        };\n\n        exports.stringify = function (data, _, options) {\n          if (!validType(data)) return;\n          var wsLine = 0;\n          var wsPos, wsColumn;\n          var whitespace = typeof options == 'object' ? options.space : options;\n\n          switch (typeof whitespace) {\n            case 'number':\n              var len = whitespace > 10 ? 10 : whitespace < 0 ? 0 : Math.floor(whitespace);\n              whitespace = len && repeat(len, ' ');\n              wsPos = len;\n              wsColumn = len;\n              break;\n\n            case 'string':\n              whitespace = whitespace.slice(0, 10);\n              wsPos = 0;\n              wsColumn = 0;\n\n              for (var j = 0; j < whitespace.length; j++) {\n                var char = whitespace[j];\n\n                switch (char) {\n                  case ' ':\n                    wsColumn++;\n                    break;\n\n                  case '\\t':\n                    wsColumn += 4;\n                    break;\n\n                  case '\\r':\n                    wsColumn = 0;\n                    break;\n\n                  case '\\n':\n                    wsColumn = 0;\n                    wsLine++;\n                    break;\n\n                  default:\n                    throw new Error('whitespace characters not allowed in JSON');\n                }\n\n                wsPos++;\n              }\n\n              break;\n\n            default:\n              whitespace = undefined;\n          }\n\n          var json = '';\n          var pointers = {};\n          var line = 0;\n          var column = 0;\n          var pos = 0;\n          var es6 = options && options.es6 && typeof Map == 'function';\n\n          _stringify(data, 0, '');\n\n          return {\n            json: json,\n            pointers: pointers\n          };\n\n          function _stringify(_data, lvl, ptr) {\n            map(ptr, 'value');\n\n            switch (typeof _data) {\n              case 'number':\n              case 'bigint':\n              case 'boolean':\n                out('' + _data);\n                break;\n\n              case 'string':\n                out(quoted(_data));\n                break;\n\n              case 'object':\n                if (_data === null) {\n                  out('null');\n                } else if (typeof _data.toJSON == 'function') {\n                  out(quoted(_data.toJSON()));\n                } else if (Array.isArray(_data)) {\n                  stringifyArray();\n                } else if (es6) {\n                  if (_data.constructor.BYTES_PER_ELEMENT) stringifyArray();else if (_data instanceof Map) stringifyMapSet();else if (_data instanceof Set) stringifyMapSet(true);else stringifyObject();\n                } else {\n                  stringifyObject();\n                }\n\n            }\n\n            map(ptr, 'valueEnd');\n\n            function stringifyArray() {\n              if (_data.length) {\n                out('[');\n                var itemLvl = lvl + 1;\n\n                for (var i = 0; i < _data.length; i++) {\n                  if (i) out(',');\n                  indent(itemLvl);\n                  var item = validType(_data[i]) ? _data[i] : null;\n                  var itemPtr = ptr + '/' + i;\n\n                  _stringify(item, itemLvl, itemPtr);\n                }\n\n                indent(lvl);\n                out(']');\n              } else {\n                out('[]');\n              }\n            }\n\n            function stringifyObject() {\n              var keys = Object.keys(_data);\n\n              if (keys.length) {\n                out('{');\n                var propLvl = lvl + 1;\n\n                for (var i = 0; i < keys.length; i++) {\n                  var key = keys[i];\n                  var value = _data[key];\n\n                  if (validType(value)) {\n                    if (i) out(',');\n                    var propPtr = ptr + '/' + escapeJsonPointer(key);\n                    indent(propLvl);\n                    map(propPtr, 'key');\n                    out(quoted(key));\n                    map(propPtr, 'keyEnd');\n                    out(':');\n                    if (whitespace) out(' ');\n\n                    _stringify(value, propLvl, propPtr);\n                  }\n                }\n\n                indent(lvl);\n                out('}');\n              } else {\n                out('{}');\n              }\n            }\n\n            function stringifyMapSet(isSet) {\n              if (_data.size) {\n                out('{');\n                var propLvl = lvl + 1;\n                var first = true;\n\n                var entries = _data.entries();\n\n                var entry = entries.next();\n\n                while (!entry.done) {\n                  var item = entry.value;\n                  var key = item[0];\n                  var value = isSet ? true : item[1];\n\n                  if (validType(value)) {\n                    if (!first) out(',');\n                    first = false;\n                    var propPtr = ptr + '/' + escapeJsonPointer(key);\n                    indent(propLvl);\n                    map(propPtr, 'key');\n                    out(quoted(key));\n                    map(propPtr, 'keyEnd');\n                    out(':');\n                    if (whitespace) out(' ');\n\n                    _stringify(value, propLvl, propPtr);\n                  }\n\n                  entry = entries.next();\n                }\n\n                indent(lvl);\n                out('}');\n              } else {\n                out('{}');\n              }\n            }\n          }\n\n          function out(str) {\n            column += str.length;\n            pos += str.length;\n            json += str;\n          }\n\n          function indent(lvl) {\n            if (whitespace) {\n              json += '\\n' + repeat(lvl, whitespace);\n              line++;\n              column = 0;\n\n              while (lvl--) {\n                if (wsLine) {\n                  line += wsLine;\n                  column = wsColumn;\n                } else {\n                  column += wsColumn;\n                }\n\n                pos += wsPos;\n              }\n\n              pos += 1; // \\n character\n            }\n          }\n\n          function map(ptr, prop) {\n            pointers[ptr] = pointers[ptr] || {};\n            pointers[ptr][prop] = {\n              line: line,\n              column: column,\n              pos: pos\n            };\n          }\n\n          function repeat(n, str) {\n            return Array(n + 1).join(str);\n          }\n        };\n\n        var VALID_TYPES = ['number', 'bigint', 'boolean', 'string', 'object'];\n\n        function validType(data) {\n          return VALID_TYPES.indexOf(typeof data) >= 0;\n        }\n\n        var ESC_QUOTE = /\"|\\\\/g;\n        var ESC_B = /[\\b]/g;\n        var ESC_F = /\\f/g;\n        var ESC_N = /\\n/g;\n        var ESC_R = /\\r/g;\n        var ESC_T = /\\t/g;\n\n        function quoted(str) {\n          str = str.replace(ESC_QUOTE, '\\\\$&').replace(ESC_F, '\\\\f').replace(ESC_B, '\\\\b').replace(ESC_N, '\\\\n').replace(ESC_R, '\\\\r').replace(ESC_T, '\\\\t');\n          return '\"' + str + '\"';\n        }\n\n        var ESC_0 = /~/g;\n        var ESC_1 = /\\//g;\n\n        function escapeJsonPointer(str) {\n          return str.replace(ESC_0, '~0').replace(ESC_1, '~1');\n        }\n        /***/\n\n      },\n      /* 19 */\n\n      /***/\n      function (module, exports, __webpack_require__) {\n        exports.tryRequireThemeJsonEditor = function () {\n          try {\n            __webpack_require__(21);\n          } catch (err) {\n            console.error(err);\n          }\n        };\n        /***/\n\n      },\n      /* 20 */\n\n      /***/\n      function (module, exports, __webpack_require__) {\n        var ace = __webpack_require__(14); // may be undefined in case of minimalist bundle\n\n\n        var VanillaPicker = __webpack_require__(11); // may be undefined in case of minimalist bundle\n\n\n        var _require = __webpack_require__(23),\n            treeModeMixins = _require.treeModeMixins;\n\n        var _require2 = __webpack_require__(15),\n            textModeMixins = _require2.textModeMixins;\n\n        var _require3 = __webpack_require__(24),\n            previewModeMixins = _require3.previewModeMixins;\n\n        var _require4 = __webpack_require__(0),\n            clear = _require4.clear,\n            extend = _require4.extend,\n            getInternetExplorerVersion = _require4.getInternetExplorerVersion,\n            parse = _require4.parse;\n\n        var _require5 = __webpack_require__(22),\n            tryRequireAjv = _require5.tryRequireAjv;\n\n        var Ajv = tryRequireAjv();\n\n        if (typeof Promise === 'undefined') {\n          console.error('Promise undefined. Please load a Promise polyfill in the browser in order to use JSONEditor');\n        }\n        /**\n         * @constructor JSONEditor\n         * @param {Element} container    Container element\n         * @param {Object}  [options]    Object with options. available options:\n         *                               {String} mode        Editor mode. Available values:\n         *                                                    'tree' (default), 'view',\n         *                                                    'form', 'text', and 'code'.\n         *                               {function} onChange  Callback method, triggered\n         *                                                    on change of contents.\n         *                                                    Does not pass the contents itself.\n         *                                                    See also `onChangeJSON` and\n         *                                                    `onChangeText`.\n         *                               {function} onChangeJSON  Callback method, triggered\n         *                                                        in modes on change of contents,\n         *                                                        passing the changed contents\n         *                                                        as JSON.\n         *                                                        Only applicable for modes\n         *                                                        'tree', 'view', and 'form'.\n         *                               {function} onChangeText  Callback method, triggered\n         *                                                        in modes on change of contents,\n         *                                                        passing the changed contents\n         *                                                        as stringified JSON.\n         *                               {function} onError   Callback method, triggered\n         *                                                    when an error occurs\n         *                               {Boolean} search     Enable search box.\n         *                                                    True by default\n         *                                                    Only applicable for modes\n         *                                                    'tree', 'view', and 'form'\n         *                               {Boolean} history    Enable history (undo/redo).\n         *                                                    True by default\n         *                                                    Only applicable for modes\n         *                                                    'tree', 'view', and 'form'\n         *                               {String} name        Field name for the root node.\n         *                                                    Only applicable for modes\n         *                                                    'tree', 'view', and 'form'\n         *                               {Number} indentation     Number of indentation\n         *                                                        spaces. 4 by default.\n         *                                                        Only applicable for\n         *                                                        modes 'text' and 'code'\n         *                               {boolean} escapeUnicode  If true, unicode\n         *                                                        characters are escaped.\n         *                                                        false by default.\n         *                               {boolean} sortObjectKeys If true, object keys are\n         *                                                        sorted before display.\n         *                                                        false by default.\n         *                               {function} onSelectionChange Callback method,\n         *                                                            triggered on node selection change\n         *                                                            Only applicable for modes\n         *                                                            'tree', 'view', and 'form'\n         *                               {function} onTextSelectionChange Callback method,\n         *                                                                triggered on text selection change\n         *                                                                Only applicable for modes\n         *                               {HTMLElement} modalAnchor        The anchor element to apply an\n         *                                                                overlay and display the modals in a\n         *                                                                centered location.\n         *                                                                Defaults to document.body\n         *                                                                'text' and 'code'\n         *                               {function} onEvent Callback method, triggered\n         *                                                  when an event occurs in\n         *                                                  a JSON field or value.\n         *                                                  Only applicable for\n         *                                                  modes 'form', 'tree' and\n         *                                                  'view'\n         *                               {function} onClassName Callback method, triggered\n         *                                                  when a Node DOM is rendered. Function returns\n         *                                                  a css class name to be set on a node.\n         *                                                  Only applicable for\n         *                                                  modes 'form', 'tree' and\n         *                                                  'view'\n         *                               {Number} maxVisibleChilds Number of children allowed for a node\n         *                                                         in 'tree', 'view', or 'form' mode before\n         *                                                         the \"show more/show all\" buttons appear.\n         *                                                         100 by default.\n         *\n         * @param {Object | undefined} json JSON object\n         */\n\n\n        function JSONEditor(container, options, json) {\n          if (!(this instanceof JSONEditor)) {\n            throw new Error('JSONEditor constructor called without \"new\".');\n          } // check for unsupported browser (IE8 and older)\n\n\n          var ieVersion = getInternetExplorerVersion();\n\n          if (ieVersion !== -1 && ieVersion < 9) {\n            throw new Error('Unsupported browser, IE9 or newer required. ' + 'Please install the newest version of your browser.');\n          }\n\n          if (options) {\n            // check for deprecated options\n            if (options.error) {\n              console.warn('Option \"error\" has been renamed to \"onError\"');\n              options.onError = options.error;\n              delete options.error;\n            }\n\n            if (options.change) {\n              console.warn('Option \"change\" has been renamed to \"onChange\"');\n              options.onChange = options.change;\n              delete options.change;\n            }\n\n            if (options.editable) {\n              console.warn('Option \"editable\" has been renamed to \"onEditable\"');\n              options.onEditable = options.editable;\n              delete options.editable;\n            } // warn if onChangeJSON is used when mode can be `text` or `code`\n\n\n            if (options.onChangeJSON) {\n              if (options.mode === 'text' || options.mode === 'code' || options.modes && (options.modes.indexOf('text') !== -1 || options.modes.indexOf('code') !== -1)) {\n                console.warn('Option \"onChangeJSON\" is not applicable to modes \"text\" and \"code\". ' + 'Use \"onChangeText\" or \"onChange\" instead.');\n              }\n            } // validate options\n\n\n            if (options) {\n              Object.keys(options).forEach(function (option) {\n                if (JSONEditor.VALID_OPTIONS.indexOf(option) === -1) {\n                  console.warn('Unknown option \"' + option + '\". This option will be ignored');\n                }\n              });\n            }\n          }\n\n          if (arguments.length) {\n            this._create(container, options, json);\n          }\n        }\n        /**\n         * Configuration for all registered modes. Example:\n         * {\n         *     tree: {\n         *         mixin: TreeEditor,\n         *         data: 'json'\n         *     },\n         *     text: {\n         *         mixin: TextEditor,\n         *         data: 'text'\n         *     }\n         * }\n         *\n         * @type { Object.<String, {mixin: Object, data: String} > }\n         */\n\n\n        JSONEditor.modes = {}; // debounce interval for JSON schema vaidation in milliseconds\n\n        JSONEditor.prototype.DEBOUNCE_INTERVAL = 150;\n        JSONEditor.VALID_OPTIONS = ['ajv', 'schema', 'schemaRefs', 'templates', 'ace', 'theme', 'autocomplete', 'onChange', 'onChangeJSON', 'onChangeText', 'onEditable', 'onError', 'onEvent', 'onModeChange', 'onNodeName', 'onValidate', 'onCreateMenu', 'onSelectionChange', 'onTextSelectionChange', 'onClassName', 'colorPicker', 'onColorPicker', 'timestampTag', 'escapeUnicode', 'history', 'search', 'mode', 'modes', 'name', 'indentation', 'sortObjectKeys', 'navigationBar', 'statusBar', 'mainMenuBar', 'languages', 'language', 'enableSort', 'enableTransform', 'maxVisibleChilds'];\n        /**\n         * Create the JSONEditor\n         * @param {Element} container    Container element\n         * @param {Object}  [options]    See description in constructor\n         * @param {Object | undefined} json JSON object\n         * @private\n         */\n\n        JSONEditor.prototype._create = function (container, options, json) {\n          this.container = container;\n          this.options = options || {};\n          this.json = json || {};\n          var mode = this.options.mode || this.options.modes && this.options.modes[0] || 'tree';\n          this.setMode(mode);\n        };\n        /**\n         * Destroy the editor. Clean up DOM, event listeners, and web workers.\n         */\n\n\n        JSONEditor.prototype.destroy = function () {};\n        /**\n         * Set JSON object in editor\n         * @param {Object | undefined} json      JSON data\n         */\n\n\n        JSONEditor.prototype.set = function (json) {\n          this.json = json;\n        };\n        /**\n         * Get JSON from the editor\n         * @returns {Object} json\n         */\n\n\n        JSONEditor.prototype.get = function () {\n          return this.json;\n        };\n        /**\n         * Set string containing JSON for the editor\n         * @param {String | undefined} jsonText\n         */\n\n\n        JSONEditor.prototype.setText = function (jsonText) {\n          this.json = parse(jsonText);\n        };\n        /**\n         * Get stringified JSON contents from the editor\n         * @returns {String} jsonText\n         */\n\n\n        JSONEditor.prototype.getText = function () {\n          return JSON.stringify(this.json);\n        };\n        /**\n         * Set a field name for the root node.\n         * @param {String | undefined} name\n         */\n\n\n        JSONEditor.prototype.setName = function (name) {\n          if (!this.options) {\n            this.options = {};\n          }\n\n          this.options.name = name;\n        };\n        /**\n         * Get the field name for the root node.\n         * @return {String | undefined} name\n         */\n\n\n        JSONEditor.prototype.getName = function () {\n          return this.options && this.options.name;\n        };\n        /**\n         * Change the mode of the editor.\n         * JSONEditor will be extended with all methods needed for the chosen mode.\n         * @param {String} mode     Available modes: 'tree' (default), 'view', 'form',\n         *                          'text', and 'code'.\n         */\n\n\n        JSONEditor.prototype.setMode = function (mode) {\n          // if the mode is the same as current mode (and it's not the first time), do nothing.\n          if (mode === this.options.mode && this.create) {\n            return;\n          }\n\n          var container = this.container;\n          var options = extend({}, this.options);\n          var oldMode = options.mode;\n          var data;\n          var name;\n          options.mode = mode;\n          var config = JSONEditor.modes[mode];\n\n          if (config) {\n            try {\n              var asText = config.data === 'text';\n              name = this.getName();\n              data = this[asText ? 'getText' : 'get'](); // get text or json\n\n              this.destroy();\n              clear(this);\n              extend(this, config.mixin);\n              this.create(container, options);\n              this.setName(name);\n              this[asText ? 'setText' : 'set'](data); // set text or json\n\n              if (typeof config.load === 'function') {\n                try {\n                  config.load.call(this);\n                } catch (err) {\n                  console.error(err);\n                }\n              }\n\n              if (typeof options.onModeChange === 'function' && mode !== oldMode) {\n                try {\n                  options.onModeChange(mode, oldMode);\n                } catch (err) {\n                  console.error(err);\n                }\n              }\n            } catch (err) {\n              this._onError(err);\n            }\n          } else {\n            throw new Error('Unknown mode \"' + options.mode + '\"');\n          }\n        };\n        /**\n         * Get the current mode\n         * @return {string}\n         */\n\n\n        JSONEditor.prototype.getMode = function () {\n          return this.options.mode;\n        };\n        /**\n         * Throw an error. If an error callback is configured in options.error, this\n         * callback will be invoked. Else, a regular error is thrown.\n         * @param {Error} err\n         * @private\n         */\n\n\n        JSONEditor.prototype._onError = function (err) {\n          if (this.options && typeof this.options.onError === 'function') {\n            this.options.onError(err);\n          } else {\n            throw err;\n          }\n        };\n        /**\n         * Set a JSON schema for validation of the JSON object.\n         * To remove the schema, call JSONEditor.setSchema(null)\n         * @param {Object | null} schema\n         * @param {Object.<string, Object>=} schemaRefs Schemas that are referenced using the `$ref` property from the JSON schema that are set in the `schema` option,\n         +  the object structure in the form of `{reference_key: schemaObject}`\n         */\n\n\n        JSONEditor.prototype.setSchema = function (schema, schemaRefs) {\n          // compile a JSON schema validator if a JSON schema is provided\n          if (schema) {\n            var ajv;\n\n            try {\n              // grab ajv from options if provided, else create a new instance\n              if (this.options.ajv) {\n                ajv = this.options.ajv;\n              } else {\n                ajv = Ajv({\n                  allErrors: true,\n                  verbose: true,\n                  schemaId: 'auto',\n                  $data: true\n                }); // support both draft-04 and draft-06 alongside the latest draft-07\n\n                ajv.addMetaSchema(__webpack_require__(!function webpackMissingModule() {\n                  var e = new Error(\"Cannot find module 'ajv/lib/refs/json-schema-draft-04.json'\");\n                  e.code = 'MODULE_NOT_FOUND';\n                  throw e;\n                }()));\n                ajv.addMetaSchema(__webpack_require__(!function webpackMissingModule() {\n                  var e = new Error(\"Cannot find module 'ajv/lib/refs/json-schema-draft-06.json'\");\n                  e.code = 'MODULE_NOT_FOUND';\n                  throw e;\n                }()));\n              }\n            } catch (err) {\n              console.warn('Failed to create an instance of Ajv, JSON Schema validation is not available. Please use a JSONEditor bundle including Ajv, or pass an instance of Ajv as via the configuration option `ajv`.');\n            }\n\n            if (ajv) {\n              if (schemaRefs) {\n                for (var ref in schemaRefs) {\n                  ajv.removeSchema(ref); // When updating a schema - old refs has to be removed first\n\n                  if (schemaRefs[ref]) {\n                    ajv.addSchema(schemaRefs[ref], ref);\n                  }\n                }\n\n                this.options.schemaRefs = schemaRefs;\n              }\n\n              this.validateSchema = ajv.compile(schema); // add schema to the options, so that when switching to an other mode,\n              // the set schema is not lost\n\n              this.options.schema = schema; // validate now\n\n              this.validate();\n            }\n\n            this.refresh(); // update DOM\n          } else {\n            // remove current schema\n            this.validateSchema = null;\n            this.options.schema = null;\n            this.options.schemaRefs = null;\n            this.validate(); // to clear current error messages\n\n            this.refresh(); // update DOM\n          }\n        };\n        /**\n         * Validate current JSON object against the configured JSON schema\n         * Throws an exception when no JSON schema is configured\n         */\n\n\n        JSONEditor.prototype.validate = function () {} // must be implemented by treemode and textmode\n\n        /**\n         * Refresh the rendered contents\n         */\n        ;\n\n        JSONEditor.prototype.refresh = function () {} // can be implemented by treemode and textmode\n\n        /**\n         * Register a plugin with one ore multiple modes for the JSON Editor.\n         *\n         * A mode is described as an object with properties:\n         *\n         * - `mode: String`           The name of the mode.\n         * - `mixin: Object`          An object containing the mixin functions which\n         *                            will be added to the JSONEditor. Must contain functions\n         *                            create, get, getText, set, and setText. May have\n         *                            additional functions.\n         *                            When the JSONEditor switches to a mixin, all mixin\n         *                            functions are added to the JSONEditor, and then\n         *                            the function `create(container, options)` is executed.\n         * - `data: 'text' | 'json'`  The type of data that will be used to load the mixin.\n         * - `[load: function]`       An optional function called after the mixin\n         *                            has been loaded.\n         *\n         * @param {Object | Array} mode  A mode object or an array with multiple mode objects.\n         */\n        ;\n\n        JSONEditor.registerMode = function (mode) {\n          var i, prop;\n\n          if (Array.isArray(mode)) {\n            // multiple modes\n            for (i = 0; i < mode.length; i++) {\n              JSONEditor.registerMode(mode[i]);\n            }\n          } else {\n            // validate the new mode\n            if (!('mode' in mode)) throw new Error('Property \"mode\" missing');\n            if (!('mixin' in mode)) throw new Error('Property \"mixin\" missing');\n            if (!('data' in mode)) throw new Error('Property \"data\" missing');\n            var name = mode.mode;\n\n            if (name in JSONEditor.modes) {\n              throw new Error('Mode \"' + name + '\" already registered');\n            } // validate the mixin\n\n\n            if (typeof mode.mixin.create !== 'function') {\n              throw new Error('Required function \"create\" missing on mixin');\n            }\n\n            var reserved = ['setMode', 'registerMode', 'modes'];\n\n            for (i = 0; i < reserved.length; i++) {\n              prop = reserved[i];\n\n              if (prop in mode.mixin) {\n                throw new Error('Reserved property \"' + prop + '\" not allowed in mixin');\n              }\n            }\n\n            JSONEditor.modes[name] = mode;\n          }\n        }; // register tree, text, and preview modes\n\n\n        JSONEditor.registerMode(treeModeMixins);\n        JSONEditor.registerMode(textModeMixins);\n        JSONEditor.registerMode(previewModeMixins); // expose some of the libraries that can be used customized\n\n        JSONEditor.ace = ace;\n        JSONEditor.Ajv = Ajv;\n        JSONEditor.VanillaPicker = VanillaPicker; // default export for TypeScript ES6 projects\n\n        JSONEditor[\"default\"] = JSONEditor;\n        module.exports = JSONEditor;\n        /***/\n      },\n      /* 21 */\n\n      /***/\n      function (module, exports) {\n        /* ***** BEGIN LICENSE BLOCK *****\n         * Distributed under the BSD license:\n         *\n         * Copyright (c) 2010, Ajax.org B.V.\n         * All rights reserved.\n         *\n         * Redistribution and use in source and binary forms, with or without\n         * modification, are permitted provided that the following conditions are met:\n         *     * Redistributions of source code must retain the above copyright\n         *       notice, this list of conditions and the following disclaimer.\n         *     * Redistributions in binary form must reproduce the above copyright\n         *       notice, this list of conditions and the following disclaimer in the\n         *       documentation and/or other materials provided with the distribution.\n         *     * Neither the name of Ajax.org B.V. nor the\n         *       names of its contributors may be used to endorse or promote products\n         *       derived from this software without specific prior written permission.\n         *\n         * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n         * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n         * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n         * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\n         * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n         * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n         * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n         * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n         * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n         * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n         *\n         * ***** END LICENSE BLOCK ***** */\n        window.ace.define('ace/theme/jsoneditor', ['require', 'exports', 'module', 'ace/lib/dom'], function (acequire, exports, module) {\n          exports.isDark = false;\n          exports.cssClass = 'ace-jsoneditor';\n          exports.cssText = \".ace-jsoneditor .ace_gutter {\\nbackground: #ebebeb;\\ncolor: #333\\n}\\n\\n.ace-jsoneditor.ace_editor {\\nfont-family: \\\"dejavu sans mono\\\", \\\"droid sans mono\\\", consolas, monaco, \\\"lucida console\\\", \\\"courier new\\\", courier, monospace, sans-serif;\\nline-height: 1.3;\\nbackground-color: #fff;\\n}\\n.ace-jsoneditor .ace_print-margin {\\nwidth: 1px;\\nbackground: #e8e8e8\\n}\\n.ace-jsoneditor .ace_scroller {\\nbackground-color: #FFFFFF\\n}\\n.ace-jsoneditor .ace_text-layer {\\ncolor: gray\\n}\\n.ace-jsoneditor .ace_variable {\\ncolor: #1a1a1a\\n}\\n.ace-jsoneditor .ace_cursor {\\nborder-left: 2px solid #000000\\n}\\n.ace-jsoneditor .ace_overwrite-cursors .ace_cursor {\\nborder-left: 0px;\\nborder-bottom: 1px solid #000000\\n}\\n.ace-jsoneditor .ace_marker-layer .ace_selection {\\nbackground: lightgray\\n}\\n.ace-jsoneditor.ace_multiselect .ace_selection.ace_start {\\nbox-shadow: 0 0 3px 0px #FFFFFF;\\nborder-radius: 2px\\n}\\n.ace-jsoneditor .ace_marker-layer .ace_step {\\nbackground: rgb(255, 255, 0)\\n}\\n.ace-jsoneditor .ace_marker-layer .ace_bracket {\\nmargin: -1px 0 0 -1px;\\nborder: 1px solid #BFBFBF\\n}\\n.ace-jsoneditor .ace_marker-layer .ace_active-line {\\nbackground: #FFFBD1\\n}\\n.ace-jsoneditor .ace_gutter-active-line {\\nbackground-color : #dcdcdc\\n}\\n.ace-jsoneditor .ace_marker-layer .ace_selected-word {\\nborder: 1px solid lightgray\\n}\\n.ace-jsoneditor .ace_invisible {\\ncolor: #BFBFBF\\n}\\n.ace-jsoneditor .ace_keyword,\\n.ace-jsoneditor .ace_meta,\\n.ace-jsoneditor .ace_support.ace_constant.ace_property-value {\\ncolor: #AF956F\\n}\\n.ace-jsoneditor .ace_keyword.ace_operator {\\ncolor: #484848\\n}\\n.ace-jsoneditor .ace_keyword.ace_other.ace_unit {\\ncolor: #96DC5F\\n}\\n.ace-jsoneditor .ace_constant.ace_language {\\ncolor: darkorange\\n}\\n.ace-jsoneditor .ace_constant.ace_numeric {\\ncolor: red\\n}\\n.ace-jsoneditor .ace_constant.ace_character.ace_entity {\\ncolor: #BF78CC\\n}\\n.ace-jsoneditor .ace_invalid {\\ncolor: #FFFFFF;\\nbackground-color: #FF002A;\\n}\\n.ace-jsoneditor .ace_fold {\\nbackground-color: #AF956F;\\nborder-color: #000000\\n}\\n.ace-jsoneditor .ace_storage,\\n.ace-jsoneditor .ace_support.ace_class,\\n.ace-jsoneditor .ace_support.ace_function,\\n.ace-jsoneditor .ace_support.ace_other,\\n.ace-jsoneditor .ace_support.ace_type {\\ncolor: #C52727\\n}\\n.ace-jsoneditor .ace_string {\\ncolor: green\\n}\\n.ace-jsoneditor .ace_comment {\\ncolor: #BCC8BA\\n}\\n.ace-jsoneditor .ace_entity.ace_name.ace_tag,\\n.ace-jsoneditor .ace_entity.ace_other.ace_attribute-name {\\ncolor: #606060\\n}\\n.ace-jsoneditor .ace_markup.ace_underline {\\ntext-decoration: underline\\n}\\n.ace-jsoneditor .ace_indent-guide {\\nbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\\\") right repeat-y\\n}\";\n          var dom = acequire('../lib/dom');\n          dom.importCssString(exports.cssText, exports.cssClass);\n        });\n        /***/\n      },\n      /* 22 */\n\n      /***/\n      function (module, exports, __webpack_require__) {\n        exports.tryRequireAjv = function () {\n          try {\n            return __webpack_require__(!function webpackMissingModule() {\n              var e = new Error(\"Cannot find module 'ajv'\");\n              e.code = 'MODULE_NOT_FOUND';\n              throw e;\n            }());\n          } catch (err) {// no problem... when we need Ajv we will throw a neat exception\n          }\n        };\n        /***/\n\n      },\n      /* 23 */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        __webpack_require__.r(__webpack_exports__); // EXTERNAL MODULE: ./src/js/vanilla-picker/index.js\n\n\n        var vanilla_picker = __webpack_require__(11);\n\n        var vanilla_picker_default =\n        /*#__PURE__*/\n        __webpack_require__.n(vanilla_picker); // CONCATENATED MODULE: ./src/js/Highlighter.js\n\n        /**\n         * The highlighter can highlight/unhighlight a node, and\n         * animate the visibility of a context menu.\n         * @constructor Highlighter\n         */\n\n\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        function _defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        function _createClass(Constructor, protoProps, staticProps) {\n          if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) _defineProperties(Constructor, staticProps);\n          return Constructor;\n        }\n\n        var Highlighter =\n        /*#__PURE__*/\n        function () {\n          function Highlighter() {\n            _classCallCheck(this, Highlighter);\n\n            this.locked = false;\n          }\n          /**\n           * Hightlight given node and its childs\n           * @param {Node} node\n           */\n\n\n          _createClass(Highlighter, [{\n            key: \"highlight\",\n            value: function highlight(node) {\n              if (this.locked) {\n                return;\n              }\n\n              if (this.node !== node) {\n                // unhighlight current node\n                if (this.node) {\n                  this.node.setHighlight(false);\n                } // highlight new node\n\n\n                this.node = node;\n                this.node.setHighlight(true);\n              } // cancel any current timeout\n\n\n              this._cancelUnhighlight();\n            }\n            /**\n             * Unhighlight currently highlighted node.\n             * Will be done after a delay\n             */\n\n          }, {\n            key: \"unhighlight\",\n            value: function unhighlight() {\n              if (this.locked) {\n                return;\n              }\n\n              var me = this;\n\n              if (this.node) {\n                this._cancelUnhighlight(); // do the unhighlighting after a small delay, to prevent re-highlighting\n                // the same node when moving from the drag-icon to the contextmenu-icon\n                // or vice versa.\n\n\n                this.unhighlightTimer = setTimeout(function () {\n                  me.node.setHighlight(false);\n                  me.node = undefined;\n                  me.unhighlightTimer = undefined;\n                }, 0);\n              }\n            }\n            /**\n             * Cancel an unhighlight action (if before the timeout of the unhighlight action)\n             * @private\n             */\n\n          }, {\n            key: \"_cancelUnhighlight\",\n            value: function _cancelUnhighlight() {\n              if (this.unhighlightTimer) {\n                clearTimeout(this.unhighlightTimer);\n                this.unhighlightTimer = undefined;\n              }\n            }\n            /**\n             * Lock highlighting or unhighlighting nodes.\n             * methods highlight and unhighlight do not work while locked.\n             */\n\n          }, {\n            key: \"lock\",\n            value: function lock() {\n              this.locked = true;\n            }\n            /**\n             * Unlock highlighting or unhighlighting nodes\n             */\n\n          }, {\n            key: \"unlock\",\n            value: function unlock() {\n              this.locked = false;\n            }\n          }]);\n\n          return Highlighter;\n        }(); // EXTERNAL MODULE: ./src/js/util.js\n\n\n        var util = __webpack_require__(0); // CONCATENATED MODULE: ./src/js/NodeHistory.js\n\n\n        function NodeHistory_classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        function NodeHistory_defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        function NodeHistory_createClass(Constructor, protoProps, staticProps) {\n          if (protoProps) NodeHistory_defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) NodeHistory_defineProperties(Constructor, staticProps);\n          return Constructor;\n        }\n        /**\n         * @constructor History\n         * Store action history, enables undo and redo\n         * @param {JSONEditor} editor\n         */\n\n\n        var NodeHistory_NodeHistory =\n        /*#__PURE__*/\n        function () {\n          function NodeHistory(editor) {\n            NodeHistory_classCallCheck(this, NodeHistory);\n            this.editor = editor;\n            this.history = [];\n            this.index = -1;\n            this.clear(); // helper function to find a Node from a path\n\n            function findNode(path) {\n              return editor.node.findNodeByInternalPath(path);\n            } // map with all supported actions\n\n\n            this.actions = {\n              editField: {\n                undo: function undo(params) {\n                  var parentNode = findNode(params.parentPath);\n                  var node = parentNode.childs[params.index];\n                  node.updateField(params.oldValue);\n                },\n                redo: function redo(params) {\n                  var parentNode = findNode(params.parentPath);\n                  var node = parentNode.childs[params.index];\n                  node.updateField(params.newValue);\n                }\n              },\n              editValue: {\n                undo: function undo(params) {\n                  findNode(params.path).updateValue(params.oldValue);\n                },\n                redo: function redo(params) {\n                  findNode(params.path).updateValue(params.newValue);\n                }\n              },\n              changeType: {\n                undo: function undo(params) {\n                  findNode(params.path).changeType(params.oldType);\n                },\n                redo: function redo(params) {\n                  findNode(params.path).changeType(params.newType);\n                }\n              },\n              appendNodes: {\n                undo: function undo(params) {\n                  var parentNode = findNode(params.parentPath);\n                  params.paths.map(findNode).forEach(function (node) {\n                    parentNode.removeChild(node);\n                  });\n                },\n                redo: function redo(params) {\n                  var parentNode = findNode(params.parentPath);\n                  params.nodes.forEach(function (node) {\n                    parentNode.appendChild(node);\n                  });\n                }\n              },\n              insertBeforeNodes: {\n                undo: function undo(params) {\n                  var parentNode = findNode(params.parentPath);\n                  params.paths.map(findNode).forEach(function (node) {\n                    parentNode.removeChild(node);\n                  });\n                },\n                redo: function redo(params) {\n                  var parentNode = findNode(params.parentPath);\n                  var beforeNode = findNode(params.beforePath);\n                  params.nodes.forEach(function (node) {\n                    parentNode.insertBefore(node, beforeNode);\n                  });\n                }\n              },\n              insertAfterNodes: {\n                undo: function undo(params) {\n                  var parentNode = findNode(params.parentPath);\n                  params.paths.map(findNode).forEach(function (node) {\n                    parentNode.removeChild(node);\n                  });\n                },\n                redo: function redo(params) {\n                  var parentNode = findNode(params.parentPath);\n                  var afterNode = findNode(params.afterPath);\n                  params.nodes.forEach(function (node) {\n                    parentNode.insertAfter(node, afterNode);\n                    afterNode = node;\n                  });\n                }\n              },\n              removeNodes: {\n                undo: function undo(params) {\n                  var parentNode = findNode(params.parentPath);\n                  var beforeNode = parentNode.childs[params.index] || parentNode.append;\n                  params.nodes.forEach(function (node) {\n                    parentNode.insertBefore(node, beforeNode);\n                  });\n                },\n                redo: function redo(params) {\n                  var parentNode = findNode(params.parentPath);\n                  params.paths.map(findNode).forEach(function (node) {\n                    parentNode.removeChild(node);\n                  });\n                }\n              },\n              duplicateNodes: {\n                undo: function undo(params) {\n                  var parentNode = findNode(params.parentPath);\n                  params.clonePaths.map(findNode).forEach(function (node) {\n                    parentNode.removeChild(node);\n                  });\n                },\n                redo: function redo(params) {\n                  var parentNode = findNode(params.parentPath);\n                  var afterNode = findNode(params.afterPath);\n                  var nodes = params.paths.map(findNode);\n                  nodes.forEach(function (node) {\n                    var clone = node.clone();\n\n                    if (parentNode.type === 'object') {\n                      var existingFieldNames = parentNode.getFieldNames();\n                      clone.field = Object(util[\"findUniqueName\"])(node.field, existingFieldNames);\n                    }\n\n                    parentNode.insertAfter(clone, afterNode);\n                    afterNode = clone;\n                  });\n                }\n              },\n              moveNodes: {\n                undo: function undo(params) {\n                  var oldParentNode = findNode(params.oldParentPath);\n                  var newParentNode = findNode(params.newParentPath);\n                  var oldBeforeNode = oldParentNode.childs[params.oldIndex] || oldParentNode.append; // first copy the nodes, then move them\n\n                  var nodes = newParentNode.childs.slice(params.newIndex, params.newIndex + params.count);\n                  nodes.forEach(function (node, index) {\n                    node.field = params.fieldNames[index];\n                    oldParentNode.moveBefore(node, oldBeforeNode);\n                  }); // This is a hack to work around an issue that we don't know tha original\n                  // path of the new parent after dragging, as the node is already moved at that time.\n\n                  if (params.newParentPathRedo === null) {\n                    params.newParentPathRedo = newParentNode.getInternalPath();\n                  }\n                },\n                redo: function redo(params) {\n                  var oldParentNode = findNode(params.oldParentPathRedo);\n                  var newParentNode = findNode(params.newParentPathRedo);\n                  var newBeforeNode = newParentNode.childs[params.newIndexRedo] || newParentNode.append; // first copy the nodes, then move them\n\n                  var nodes = oldParentNode.childs.slice(params.oldIndexRedo, params.oldIndexRedo + params.count);\n                  nodes.forEach(function (node, index) {\n                    node.field = params.fieldNames[index];\n                    newParentNode.moveBefore(node, newBeforeNode);\n                  });\n                }\n              },\n              sort: {\n                undo: function undo(params) {\n                  var node = findNode(params.path);\n                  node.hideChilds();\n                  node.childs = params.oldChilds;\n                  node.updateDom({\n                    updateIndexes: true\n                  });\n                  node.showChilds();\n                },\n                redo: function redo(params) {\n                  var node = findNode(params.path);\n                  node.hideChilds();\n                  node.childs = params.newChilds;\n                  node.updateDom({\n                    updateIndexes: true\n                  });\n                  node.showChilds();\n                }\n              },\n              transform: {\n                undo: function undo(params) {\n                  findNode(params.path).setInternalValue(params.oldValue); // TODO: would be nice to restore the state of the node and childs\n                },\n                redo: function redo(params) {\n                  findNode(params.path).setInternalValue(params.newValue); // TODO: would be nice to restore the state of the node and childs\n                }\n              } // TODO: restore the original caret position and selection with each undo\n              // TODO: implement history for actions \"expand\", \"collapse\", \"scroll\", \"setDocument\"\n\n            };\n          }\n          /**\n           * The method onChange is executed when the History is changed, and can\n           * be overloaded.\n           */\n\n\n          NodeHistory_createClass(NodeHistory, [{\n            key: \"onChange\",\n            value: function onChange() {}\n            /**\n             * Add a new action to the history\n             * @param {String} action  The executed action. Available actions: \"editField\",\n             *                         \"editValue\", \"changeType\", \"appendNode\",\n             *                         \"removeNode\", \"duplicateNode\", \"moveNode\"\n             * @param {Object} params  Object containing parameters describing the change.\n             *                         The parameters in params depend on the action (for\n             *                         example for \"editValue\" the Node, old value, and new\n             *                         value are provided). params contains all information\n             *                         needed to undo or redo the action.\n             */\n\n          }, {\n            key: \"add\",\n            value: function add(action, params) {\n              this.index++;\n              this.history[this.index] = {\n                action: action,\n                params: params,\n                timestamp: new Date()\n              }; // remove redo actions which are invalid now\n\n              if (this.index < this.history.length - 1) {\n                this.history.splice(this.index + 1, this.history.length - this.index - 1);\n              } // fire onchange event\n\n\n              this.onChange();\n            }\n            /**\n             * Clear history\n             */\n\n          }, {\n            key: \"clear\",\n            value: function clear() {\n              this.history = [];\n              this.index = -1; // fire onchange event\n\n              this.onChange();\n            }\n            /**\n             * Check if there is an action available for undo\n             * @return {Boolean} canUndo\n             */\n\n          }, {\n            key: \"canUndo\",\n            value: function canUndo() {\n              return this.index >= 0;\n            }\n            /**\n             * Check if there is an action available for redo\n             * @return {Boolean} canRedo\n             */\n\n          }, {\n            key: \"canRedo\",\n            value: function canRedo() {\n              return this.index < this.history.length - 1;\n            }\n            /**\n             * Undo the last action\n             */\n\n          }, {\n            key: \"undo\",\n            value: function undo() {\n              if (this.canUndo()) {\n                var obj = this.history[this.index];\n\n                if (obj) {\n                  var action = this.actions[obj.action];\n\n                  if (action && action.undo) {\n                    action.undo(obj.params);\n\n                    if (obj.params.oldSelection) {\n                      try {\n                        this.editor.setDomSelection(obj.params.oldSelection);\n                      } catch (err) {\n                        console.error(err);\n                      }\n                    }\n                  } else {\n                    console.error(new Error('unknown action \"' + obj.action + '\"'));\n                  }\n                }\n\n                this.index--; // fire onchange event\n\n                this.onChange();\n              }\n            }\n            /**\n             * Redo the last action\n             */\n\n          }, {\n            key: \"redo\",\n            value: function redo() {\n              if (this.canRedo()) {\n                this.index++;\n                var obj = this.history[this.index];\n\n                if (obj) {\n                  var action = this.actions[obj.action];\n\n                  if (action && action.redo) {\n                    action.redo(obj.params);\n\n                    if (obj.params.newSelection) {\n                      try {\n                        this.editor.setDomSelection(obj.params.newSelection);\n                      } catch (err) {\n                        console.error(err);\n                      }\n                    }\n                  } else {\n                    console.error(new Error('unknown action \"' + obj.action + '\"'));\n                  }\n                } // fire onchange event\n\n\n                this.onChange();\n              }\n            }\n            /**\n             * Destroy history\n             */\n\n          }, {\n            key: \"destroy\",\n            value: function destroy() {\n              this.editor = null;\n              this.history = [];\n              this.index = -1;\n            }\n          }]);\n          return NodeHistory;\n        }(); // CONCATENATED MODULE: ./src/js/SearchBox.js\n\n        /**\n         * @constructor SearchBox\n         * Create a search box in given HTML container\n         * @param {JSONEditor} editor    The JSON Editor to attach to\n         * @param {Element} container               HTML container element of where to\n         *                                          create the search box\n         */\n\n\n        function SearchBox_classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        function SearchBox_defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        function SearchBox_createClass(Constructor, protoProps, staticProps) {\n          if (protoProps) SearchBox_defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) SearchBox_defineProperties(Constructor, staticProps);\n          return Constructor;\n        }\n\n        var SearchBox =\n        /*#__PURE__*/\n        function () {\n          function SearchBox(editor, container) {\n            SearchBox_classCallCheck(this, SearchBox);\n            var searchBox = this;\n            this.editor = editor;\n            this.timeout = undefined;\n            this.delay = 200; // ms\n\n            this.lastText = undefined;\n            this.results = null;\n            this.dom = {};\n            this.dom.container = container;\n            var wrapper = document.createElement('div');\n            this.dom.wrapper = wrapper;\n            wrapper.className = 'jsoneditor-search';\n            container.appendChild(wrapper);\n            var results = document.createElement('div');\n            this.dom.results = results;\n            results.className = 'jsoneditor-results';\n            wrapper.appendChild(results);\n            var divInput = document.createElement('div');\n            this.dom.input = divInput;\n            divInput.className = 'jsoneditor-frame';\n            divInput.title = 'Search fields and values';\n            wrapper.appendChild(divInput);\n            var refreshSearch = document.createElement('button');\n            refreshSearch.type = 'button';\n            refreshSearch.className = 'jsoneditor-refresh';\n            divInput.appendChild(refreshSearch);\n            var search = document.createElement('input');\n            search.type = 'text';\n            this.dom.search = search;\n\n            search.oninput = function (event) {\n              searchBox._onDelayedSearch(event);\n            };\n\n            search.onchange = function (event) {\n              // For IE 9\n              searchBox._onSearch();\n            };\n\n            search.onkeydown = function (event) {\n              searchBox._onKeyDown(event);\n            };\n\n            search.onkeyup = function (event) {\n              searchBox._onKeyUp(event);\n            };\n\n            refreshSearch.onclick = function (event) {\n              search.select();\n            }; // TODO: ESC in FF restores the last input, is a FF bug, https://bugzilla.mozilla.org/show_bug.cgi?id=598819\n\n\n            divInput.appendChild(search);\n            var searchNext = document.createElement('button');\n            searchNext.type = 'button';\n            searchNext.title = 'Next result (Enter)';\n            searchNext.className = 'jsoneditor-next';\n\n            searchNext.onclick = function () {\n              searchBox.next();\n            };\n\n            divInput.appendChild(searchNext);\n            var searchPrevious = document.createElement('button');\n            searchPrevious.type = 'button';\n            searchPrevious.title = 'Previous result (Shift+Enter)';\n            searchPrevious.className = 'jsoneditor-previous';\n\n            searchPrevious.onclick = function () {\n              searchBox.previous();\n            };\n\n            divInput.appendChild(searchPrevious);\n          }\n          /**\n           * Go to the next search result\n           * @param {boolean} [focus]   If true, focus will be set to the next result\n           *                            focus is false by default.\n           */\n\n\n          SearchBox_createClass(SearchBox, [{\n            key: \"next\",\n            value: function next(focus) {\n              if (this.results) {\n                var index = this.resultIndex !== null ? this.resultIndex + 1 : 0;\n\n                if (index > this.results.length - 1) {\n                  index = 0;\n                }\n\n                this._setActiveResult(index, focus);\n              }\n            }\n            /**\n             * Go to the prevous search result\n             * @param {boolean} [focus]   If true, focus will be set to the next result\n             *                            focus is false by default.\n             */\n\n          }, {\n            key: \"previous\",\n            value: function previous(focus) {\n              if (this.results) {\n                var max = this.results.length - 1;\n                var index = this.resultIndex !== null ? this.resultIndex - 1 : max;\n\n                if (index < 0) {\n                  index = max;\n                }\n\n                this._setActiveResult(index, focus);\n              }\n            }\n            /**\n             * Set new value for the current active result\n             * @param {Number} index\n             * @param {boolean} [focus]   If true, focus will be set to the next result.\n             *                            focus is false by default.\n             * @private\n             */\n\n          }, {\n            key: \"_setActiveResult\",\n            value: function _setActiveResult(index, focus) {\n              // de-activate current active result\n              if (this.activeResult) {\n                var prevNode = this.activeResult.node;\n                var prevElem = this.activeResult.elem;\n\n                if (prevElem === 'field') {\n                  delete prevNode.searchFieldActive;\n                } else {\n                  delete prevNode.searchValueActive;\n                }\n\n                prevNode.updateDom();\n              }\n\n              if (!this.results || !this.results[index]) {\n                // out of range, set to undefined\n                this.resultIndex = undefined;\n                this.activeResult = undefined;\n                return;\n              }\n\n              this.resultIndex = index; // set new node active\n\n              var node = this.results[this.resultIndex].node;\n              var elem = this.results[this.resultIndex].elem;\n\n              if (elem === 'field') {\n                node.searchFieldActive = true;\n              } else {\n                node.searchValueActive = true;\n              }\n\n              this.activeResult = this.results[this.resultIndex];\n              node.updateDom(); // TODO: not so nice that the focus is only set after the animation is finished\n\n              node.scrollTo(function () {\n                if (focus) {\n                  node.focus(elem);\n                }\n              });\n            }\n            /**\n             * Cancel any running onDelayedSearch.\n             * @private\n             */\n\n          }, {\n            key: \"_clearDelay\",\n            value: function _clearDelay() {\n              if (this.timeout !== undefined) {\n                clearTimeout(this.timeout);\n                delete this.timeout;\n              }\n            }\n            /**\n             * Start a timer to execute a search after a short delay.\n             * Used for reducing the number of searches while typing.\n             * @param {Event} event\n             * @private\n             */\n\n          }, {\n            key: \"_onDelayedSearch\",\n            value: function _onDelayedSearch(event) {\n              // execute the search after a short delay (reduces the number of\n              // search actions while typing in the search text box)\n              this._clearDelay();\n\n              var searchBox = this;\n              this.timeout = setTimeout(function (event) {\n                searchBox._onSearch();\n              }, this.delay);\n            }\n            /**\n             * Handle onSearch event\n             * @param {boolean} [forceSearch]  If true, search will be executed again even\n             *                                 when the search text is not changed.\n             *                                 Default is false.\n             * @private\n             */\n\n          }, {\n            key: \"_onSearch\",\n            value: function _onSearch(forceSearch) {\n              this._clearDelay();\n\n              var value = this.dom.search.value;\n              var text = value.length > 0 ? value : undefined;\n\n              if (text !== this.lastText || forceSearch) {\n                // only search again when changed\n                this.lastText = text;\n                this.results = this.editor.search(text);\n                var MAX_SEARCH_RESULTS = this.results[0] ? this.results[0].node.MAX_SEARCH_RESULTS : Infinity; // try to maintain the current active result if this is still part of the new search results\n\n                var activeResultIndex = 0;\n\n                if (this.activeResult) {\n                  for (var i = 0; i < this.results.length; i++) {\n                    if (this.results[i].node === this.activeResult.node) {\n                      activeResultIndex = i;\n                      break;\n                    }\n                  }\n                }\n\n                this._setActiveResult(activeResultIndex, false); // display search results\n\n\n                if (text !== undefined) {\n                  var resultCount = this.results.length;\n\n                  if (resultCount === 0) {\n                    this.dom.results.innerHTML = 'no&nbsp;results';\n                  } else if (resultCount === 1) {\n                    this.dom.results.innerHTML = '1&nbsp;result';\n                  } else if (resultCount > MAX_SEARCH_RESULTS) {\n                    this.dom.results.innerHTML = MAX_SEARCH_RESULTS + '+&nbsp;results';\n                  } else {\n                    this.dom.results.innerHTML = resultCount + '&nbsp;results';\n                  }\n                } else {\n                  this.dom.results.innerHTML = '';\n                }\n              }\n            }\n            /**\n             * Handle onKeyDown event in the input box\n             * @param {Event} event\n             * @private\n             */\n\n          }, {\n            key: \"_onKeyDown\",\n            value: function _onKeyDown(event) {\n              var keynum = event.which;\n\n              if (keynum === 27) {\n                // ESC\n                this.dom.search.value = ''; // clear search\n\n                this._onSearch();\n\n                event.preventDefault();\n                event.stopPropagation();\n              } else if (keynum === 13) {\n                // Enter\n                if (event.ctrlKey) {\n                  // force to search again\n                  this._onSearch(true);\n                } else if (event.shiftKey) {\n                  // move to the previous search result\n                  this.previous();\n                } else {\n                  // move to the next search result\n                  this.next();\n                }\n\n                event.preventDefault();\n                event.stopPropagation();\n              }\n            }\n            /**\n             * Handle onKeyUp event in the input box\n             * @param {Event} event\n             * @private\n             */\n\n          }, {\n            key: \"_onKeyUp\",\n            value: function _onKeyUp(event) {\n              var keynum = event.keyCode;\n\n              if (keynum !== 27 && keynum !== 13) {\n                // !show and !Enter\n                this._onDelayedSearch(event); // For IE 9\n\n              }\n            }\n            /**\n             * Clear the search results\n             */\n\n          }, {\n            key: \"clear\",\n            value: function clear() {\n              this.dom.search.value = '';\n\n              this._onSearch();\n            }\n            /**\n             * Refresh searchResults if there is a search value\n             */\n\n          }, {\n            key: \"forceSearch\",\n            value: function forceSearch() {\n              this._onSearch(true);\n            }\n            /**\n             * Test whether the search box value is empty\n             * @returns {boolean} Returns true when empty.\n             */\n\n          }, {\n            key: \"isEmpty\",\n            value: function isEmpty() {\n              return this.dom.search.value === '';\n            }\n            /**\n             * Destroy the search box\n             */\n\n          }, {\n            key: \"destroy\",\n            value: function destroy() {\n              this.editor = null;\n              this.dom.container.removeChild(this.dom.wrapper);\n              this.dom = null;\n              this.results = null;\n              this.activeResult = null;\n\n              this._clearDelay();\n            }\n          }]);\n          return SearchBox;\n        }(); // EXTERNAL MODULE: ./src/js/ContextMenu.js\n\n\n        var ContextMenu = __webpack_require__(3); // EXTERNAL MODULE: ./src/js/i18n.js\n\n\n        var i18n = __webpack_require__(1); // CONCATENATED MODULE: ./src/js/TreePath.js\n\n\n        function TreePath_classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        function TreePath_defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        function TreePath_createClass(Constructor, protoProps, staticProps) {\n          if (protoProps) TreePath_defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) TreePath_defineProperties(Constructor, staticProps);\n          return Constructor;\n        }\n        /**\n         * Creates a component that visualize path selection in tree based editors\n         * @param {HTMLElement} container\n         * @param {HTMLElement} root\n         * @constructor\n         */\n\n\n        var TreePath_TreePath =\n        /*#__PURE__*/\n        function () {\n          function TreePath(container, root) {\n            TreePath_classCallCheck(this, TreePath);\n\n            if (container) {\n              this.root = root;\n              this.path = document.createElement('div');\n              this.path.className = 'jsoneditor-treepath';\n              this.path.setAttribute('tabindex', 0);\n              this.contentMenuClicked = false;\n              container.appendChild(this.path);\n              this.reset();\n            }\n          }\n          /**\n           * Reset component to initial status\n           */\n\n\n          TreePath_createClass(TreePath, [{\n            key: \"reset\",\n            value: function reset() {\n              this.path.innerHTML = Object(i18n[\"c\"\n              /* translate */\n              ])('selectNode');\n            }\n            /**\n             * Renders the component UI according to a given path objects\n             * @param {Array<{name: String, childs: Array}>} pathObjs a list of path objects\n             *\n             */\n\n          }, {\n            key: \"setPath\",\n            value: function setPath(pathObjs) {\n              var me = this;\n              this.path.innerHTML = '';\n\n              if (pathObjs && pathObjs.length) {\n                pathObjs.forEach(function (pathObj, idx) {\n                  var pathEl = document.createElement('span');\n                  var sepEl;\n                  pathEl.className = 'jsoneditor-treepath-element';\n                  pathEl.innerText = pathObj.name;\n                  pathEl.onclick = _onSegmentClick.bind(me, pathObj);\n                  me.path.appendChild(pathEl);\n\n                  if (pathObj.children.length) {\n                    sepEl = document.createElement('span');\n                    sepEl.className = 'jsoneditor-treepath-seperator';\n                    sepEl.innerHTML = '&#9658;';\n\n                    sepEl.onclick = function () {\n                      me.contentMenuClicked = true;\n                      var items = [];\n                      pathObj.children.forEach(function (child) {\n                        items.push({\n                          text: child.name,\n                          className: 'jsoneditor-type-modes' + (pathObjs[idx + 1] + 1 && pathObjs[idx + 1].name === child.name ? ' jsoneditor-selected' : ''),\n                          click: _onContextMenuItemClick.bind(me, pathObj, child.name)\n                        });\n                      });\n                      var menu = new ContextMenu[\"a\"\n                      /* ContextMenu */\n                      ](items);\n                      menu.show(sepEl, me.root, true);\n                    };\n\n                    me.path.appendChild(sepEl);\n                  }\n\n                  if (idx === pathObjs.length - 1) {\n                    var leftRectPos = (sepEl || pathEl).getBoundingClientRect().right;\n\n                    if (me.path.offsetWidth < leftRectPos) {\n                      me.path.scrollLeft = leftRectPos;\n                    }\n\n                    if (me.path.scrollLeft) {\n                      var showAllBtn = document.createElement('span');\n                      showAllBtn.className = 'jsoneditor-treepath-show-all-btn';\n                      showAllBtn.title = 'show all path';\n                      showAllBtn.innerHTML = '...';\n                      showAllBtn.onclick = _onShowAllClick.bind(me, pathObjs);\n                      me.path.insertBefore(showAllBtn, me.path.firstChild);\n                    }\n                  }\n                });\n              }\n\n              function _onShowAllClick(pathObjs) {\n                me.contentMenuClicked = false;\n                Object(util[\"addClassName\"])(me.path, 'show-all');\n                me.path.style.width = me.path.parentNode.getBoundingClientRect().width - 10 + 'px';\n\n                me.path.onblur = function () {\n                  if (me.contentMenuClicked) {\n                    me.contentMenuClicked = false;\n                    me.path.focus();\n                    return;\n                  }\n\n                  Object(util[\"removeClassName\"])(me.path, 'show-all');\n                  me.path.onblur = undefined;\n                  me.path.style.width = '';\n                  me.setPath(pathObjs);\n                };\n              }\n\n              function _onSegmentClick(pathObj) {\n                if (this.selectionCallback) {\n                  this.selectionCallback(pathObj);\n                }\n              }\n\n              function _onContextMenuItemClick(pathObj, selection) {\n                if (this.contextMenuCallback) {\n                  this.contextMenuCallback(pathObj, selection);\n                }\n              }\n            }\n            /**\n             * set a callback function for selection of path section\n             * @param {Function} callback function to invoke when section is selected\n             */\n\n          }, {\n            key: \"onSectionSelected\",\n            value: function onSectionSelected(callback) {\n              if (typeof callback === 'function') {\n                this.selectionCallback = callback;\n              }\n            }\n            /**\n             * set a callback function for selection of path section\n             * @param {Function} callback function to invoke when section is selected\n             */\n\n          }, {\n            key: \"onContextMenuItemSelected\",\n            value: function onContextMenuItemSelected(callback) {\n              if (typeof callback === 'function') {\n                this.contextMenuCallback = callback;\n              }\n            }\n          }]);\n          return TreePath;\n        }(); // EXTERNAL MODULE: ./node_modules/jmespath/jmespath.js\n\n\n        var jmespath = __webpack_require__(4);\n\n        var jmespath_default =\n        /*#__PURE__*/\n        __webpack_require__.n(jmespath); // EXTERNAL MODULE: ./node_modules/javascript-natural-sort/naturalSort.js\n\n\n        var naturalSort = __webpack_require__(9);\n\n        var naturalSort_default =\n        /*#__PURE__*/\n        __webpack_require__.n(naturalSort); // EXTERNAL MODULE: ./src/js/createAbsoluteAnchor.js\n\n\n        var createAbsoluteAnchor = __webpack_require__(10); // CONCATENATED MODULE: ./src/js/appendNodeFactory.js\n\n        /**\n         * A factory function to create an AppendNode, which depends on a Node\n         * @param {Node} Node\n         */\n\n\n        function appendNodeFactory(Node) {\n          /**\n           * @constructor AppendNode\n           * @extends Node\n           * @param {TreeEditor} editor\n           * Create a new AppendNode. This is a special node which is created at the\n           * end of the list with childs for an object or array\n           */\n          function AppendNode(editor) {\n            /** @type {TreeEditor} */\n            this.editor = editor;\n            this.dom = {};\n          }\n\n          AppendNode.prototype = new Node();\n          /**\n           * Return a table row with an append button.\n           * @return {Element} dom   TR element\n           */\n\n          AppendNode.prototype.getDom = function () {\n            // TODO: implement a new solution for the append node\n            var dom = this.dom;\n\n            if (dom.tr) {\n              return dom.tr;\n            }\n\n            this._updateEditability(); // a row for the append button\n\n\n            var trAppend = document.createElement('tr');\n            trAppend.className = 'jsoneditor-append';\n            trAppend.node = this;\n            dom.tr = trAppend; // TODO: consistent naming\n\n            if (this.editor.options.mode === 'tree') {\n              // a cell for the dragarea column\n              dom.tdDrag = document.createElement('td'); // create context menu\n\n              var tdMenu = document.createElement('td');\n              dom.tdMenu = tdMenu;\n              var menu = document.createElement('button');\n              menu.type = 'button';\n              menu.className = 'jsoneditor-button jsoneditor-contextmenu';\n              menu.title = 'Click to open the actions menu (Ctrl+M)';\n              dom.menu = menu;\n              tdMenu.appendChild(dom.menu);\n            } // a cell for the contents (showing text 'empty')\n\n\n            var tdAppend = document.createElement('td');\n            var domText = document.createElement('div');\n            domText.innerHTML = '(' + Object(i18n[\"c\"\n            /* translate */\n            ])('empty') + ')';\n            domText.className = 'jsoneditor-readonly';\n            tdAppend.appendChild(domText);\n            dom.td = tdAppend;\n            dom.text = domText;\n            this.updateDom();\n            return trAppend;\n          };\n          /**\n           * Append node doesn't have a path\n           * @returns {null}\n           */\n\n\n          AppendNode.prototype.getPath = function () {\n            return null;\n          };\n          /**\n           * Append node doesn't have an index\n           * @returns {null}\n           */\n\n\n          AppendNode.prototype.getIndex = function () {\n            return null;\n          };\n          /**\n           * Update the HTML dom of the Node\n           */\n\n\n          AppendNode.prototype.updateDom = function (options) {\n            var dom = this.dom;\n            var tdAppend = dom.td;\n\n            if (tdAppend) {\n              tdAppend.style.paddingLeft = this.getLevel() * 24 + 26 + 'px'; // TODO: not so nice hard coded offset\n            }\n\n            var domText = dom.text;\n\n            if (domText) {\n              domText.innerHTML = '(' + Object(i18n[\"c\"\n              /* translate */\n              ])('empty') + ' ' + this.parent.type + ')';\n            } // attach or detach the contents of the append node:\n            // hide when the parent has childs, show when the parent has no childs\n\n\n            var trAppend = dom.tr;\n\n            if (!this.isVisible()) {\n              if (dom.tr.firstChild) {\n                if (dom.tdDrag) {\n                  trAppend.removeChild(dom.tdDrag);\n                }\n\n                if (dom.tdMenu) {\n                  trAppend.removeChild(dom.tdMenu);\n                }\n\n                trAppend.removeChild(tdAppend);\n              }\n            } else {\n              if (!dom.tr.firstChild) {\n                if (dom.tdDrag) {\n                  trAppend.appendChild(dom.tdDrag);\n                }\n\n                if (dom.tdMenu) {\n                  trAppend.appendChild(dom.tdMenu);\n                }\n\n                trAppend.appendChild(tdAppend);\n              }\n            }\n          };\n          /**\n           * Check whether the AppendNode is currently visible.\n           * the AppendNode is visible when its parent has no childs (i.e. is empty).\n           * @return {boolean} isVisible\n           */\n\n\n          AppendNode.prototype.isVisible = function () {\n            return this.parent.childs.length === 0;\n          };\n          /**\n           * Show a contextmenu for this node\n           * @param {HTMLElement} anchor   The element to attach the menu to.\n           * @param {function} [onClose]   Callback method called when the context menu\n           *                               is being closed.\n           */\n\n\n          AppendNode.prototype.showContextMenu = function (anchor, onClose) {\n            var node = this;\n            var titles = Node.TYPE_TITLES;\n            var appendSubmenu = [{\n              text: Object(i18n[\"c\"\n              /* translate */\n              ])('auto'),\n              className: 'jsoneditor-type-auto',\n              title: titles.auto,\n              click: function click() {\n                node._onAppend('', '', 'auto');\n              }\n            }, {\n              text: Object(i18n[\"c\"\n              /* translate */\n              ])('array'),\n              className: 'jsoneditor-type-array',\n              title: titles.array,\n              click: function click() {\n                node._onAppend('', []);\n              }\n            }, {\n              text: Object(i18n[\"c\"\n              /* translate */\n              ])('object'),\n              className: 'jsoneditor-type-object',\n              title: titles.object,\n              click: function click() {\n                node._onAppend('', {});\n              }\n            }, {\n              text: Object(i18n[\"c\"\n              /* translate */\n              ])('string'),\n              className: 'jsoneditor-type-string',\n              title: titles.string,\n              click: function click() {\n                node._onAppend('', '', 'string');\n              }\n            }];\n            node.addTemplates(appendSubmenu, true);\n            var items = [// create append button\n            {\n              text: Object(i18n[\"c\"\n              /* translate */\n              ])('appendText'),\n              title: Object(i18n[\"c\"\n              /* translate */\n              ])('appendTitleAuto'),\n              submenuTitle: Object(i18n[\"c\"\n              /* translate */\n              ])('appendSubmenuTitle'),\n              className: 'jsoneditor-insert',\n              click: function click() {\n                node._onAppend('', '', 'auto');\n              },\n              submenu: appendSubmenu\n            }];\n\n            if (this.editor.options.onCreateMenu) {\n              var path = node.parent.getPath();\n              items = this.editor.options.onCreateMenu(items, {\n                type: 'append',\n                path: path,\n                paths: [path]\n              });\n            }\n\n            var menu = new ContextMenu[\"a\"\n            /* ContextMenu */\n            ](items, {\n              close: onClose\n            });\n            menu.show(anchor, this.editor.frame);\n          };\n          /**\n           * Handle an event. The event is caught centrally by the editor\n           * @param {Event} event\n           */\n\n\n          AppendNode.prototype.onEvent = function (event) {\n            var type = event.type;\n            var target = event.target || event.srcElement;\n            var dom = this.dom; // highlight the append nodes parent\n\n            var menu = dom.menu;\n\n            if (target === menu) {\n              if (type === 'mouseover') {\n                this.editor.highlighter.highlight(this.parent);\n              } else if (type === 'mouseout') {\n                this.editor.highlighter.unhighlight();\n              }\n            } // context menu events\n\n\n            if (type === 'click' && target === dom.menu) {\n              var highlighter = this.editor.highlighter;\n              highlighter.highlight(this.parent);\n              highlighter.lock();\n              Object(util[\"addClassName\"])(dom.menu, 'jsoneditor-selected');\n              this.showContextMenu(dom.menu, function () {\n                Object(util[\"removeClassName\"])(dom.menu, 'jsoneditor-selected');\n                highlighter.unlock();\n                highlighter.unhighlight();\n              });\n            }\n\n            if (type === 'keydown') {\n              this.onKeyDown(event);\n            }\n          };\n\n          return AppendNode;\n        } // CONCATENATED MODULE: ./src/js/showMoreNodeFactory.js\n\n        /**\n         * A factory function to create an ShowMoreNode, which depends on a Node\n         * @param {function} Node\n         */\n\n\n        function showMoreNodeFactory(Node) {\n          /**\n           * @constructor ShowMoreNode\n           * @extends Node\n           * @param {TreeEditor} editor\n           * @param {Node} parent\n           * Create a new ShowMoreNode. This is a special node which is created\n           * for arrays or objects having more than 100 items\n           */\n          function ShowMoreNode(editor, parent) {\n            /** @type {TreeEditor} */\n            this.editor = editor;\n            this.parent = parent;\n            this.dom = {};\n          }\n\n          ShowMoreNode.prototype = new Node();\n          /**\n           * Return a table row with an append button.\n           * @return {Element} dom   TR element\n           */\n\n          ShowMoreNode.prototype.getDom = function () {\n            if (this.dom.tr) {\n              return this.dom.tr;\n            }\n\n            this._updateEditability(); // display \"show more\"\n\n\n            if (!this.dom.tr) {\n              var me = this;\n              var parent = this.parent;\n              var showMoreButton = document.createElement('a');\n              showMoreButton.appendChild(document.createTextNode(Object(i18n[\"c\"\n              /* translate */\n              ])('showMore')));\n              showMoreButton.href = '#';\n\n              showMoreButton.onclick = function (event) {\n                // TODO: use callback instead of accessing a method of the parent\n                parent.visibleChilds = Math.floor(parent.visibleChilds / parent.getMaxVisibleChilds() + 1) * parent.getMaxVisibleChilds();\n                me.updateDom();\n                parent.showChilds();\n                event.preventDefault();\n                return false;\n              };\n\n              var showAllButton = document.createElement('a');\n              showAllButton.appendChild(document.createTextNode(Object(i18n[\"c\"\n              /* translate */\n              ])('showAll')));\n              showAllButton.href = '#';\n\n              showAllButton.onclick = function (event) {\n                // TODO: use callback instead of accessing a method of the parent\n                parent.visibleChilds = Infinity;\n                me.updateDom();\n                parent.showChilds();\n                event.preventDefault();\n                return false;\n              };\n\n              var moreContents = document.createElement('div');\n              var moreText = document.createTextNode(this._getShowMoreText());\n              moreContents.className = 'jsoneditor-show-more';\n              moreContents.appendChild(moreText);\n              moreContents.appendChild(showMoreButton);\n              moreContents.appendChild(document.createTextNode('. '));\n              moreContents.appendChild(showAllButton);\n              moreContents.appendChild(document.createTextNode('. '));\n              var tdContents = document.createElement('td');\n              tdContents.appendChild(moreContents);\n              var moreTr = document.createElement('tr');\n\n              if (this.editor.options.mode === 'tree') {\n                moreTr.appendChild(document.createElement('td'));\n                moreTr.appendChild(document.createElement('td'));\n              }\n\n              moreTr.appendChild(tdContents);\n              moreTr.className = 'jsoneditor-show-more';\n              this.dom.tr = moreTr;\n              this.dom.moreContents = moreContents;\n              this.dom.moreText = moreText;\n            }\n\n            this.updateDom();\n            return this.dom.tr;\n          };\n          /**\n           * Update the HTML dom of the Node\n           */\n\n\n          ShowMoreNode.prototype.updateDom = function (options) {\n            if (this.isVisible()) {\n              // attach to the right child node (the first non-visible child)\n              this.dom.tr.node = this.parent.childs[this.parent.visibleChilds];\n\n              if (!this.dom.tr.parentNode) {\n                var nextTr = this.parent._getNextTr();\n\n                if (nextTr) {\n                  nextTr.parentNode.insertBefore(this.dom.tr, nextTr);\n                }\n              } // update the counts in the text\n\n\n              this.dom.moreText.nodeValue = this._getShowMoreText(); // update left margin\n\n              this.dom.moreContents.style.marginLeft = (this.getLevel() + 1) * 24 + 'px';\n            } else {\n              if (this.dom.tr && this.dom.tr.parentNode) {\n                this.dom.tr.parentNode.removeChild(this.dom.tr);\n              }\n            }\n          };\n\n          ShowMoreNode.prototype._getShowMoreText = function () {\n            return Object(i18n[\"c\"\n            /* translate */\n            ])('showMoreStatus', {\n              visibleChilds: this.parent.visibleChilds,\n              totalChilds: this.parent.childs.length\n            }) + ' ';\n          };\n          /**\n           * Check whether the ShowMoreNode is currently visible.\n           * the ShowMoreNode is visible when it's parent has more childs than\n           * the current visibleChilds\n           * @return {boolean} isVisible\n           */\n\n\n          ShowMoreNode.prototype.isVisible = function () {\n            return this.parent.expanded && this.parent.childs.length > this.parent.visibleChilds;\n          };\n          /**\n           * Handle an event. The event is caught centrally by the editor\n           * @param {Event} event\n           */\n\n\n          ShowMoreNode.prototype.onEvent = function (event) {\n            var type = event.type;\n\n            if (type === 'keydown') {\n              this.onKeyDown(event);\n            }\n          };\n\n          return ShowMoreNode;\n        } // EXTERNAL MODULE: ./src/js/showSortModal.js\n\n\n        var js_showSortModal = __webpack_require__(5); // EXTERNAL MODULE: ./src/js/showTransformModal.js + 1 modules\n\n\n        var js_showTransformModal = __webpack_require__(7); // EXTERNAL MODULE: ./src/js/constants.js\n\n\n        var constants = __webpack_require__(2); // CONCATENATED MODULE: ./src/js/Node.js\n\n\n        function _typeof(obj) {\n          if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n              return typeof obj;\n            };\n          } else {\n            _typeof = function _typeof(obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n          }\n\n          return _typeof(obj);\n        }\n\n        function Node_classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        function Node_defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        function Node_createClass(Constructor, protoProps, staticProps) {\n          if (protoProps) Node_defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) Node_defineProperties(Constructor, staticProps);\n          return Constructor;\n        }\n\n        var YEAR_2000 = 946684800000;\n        /**\n         * @constructor Node\n         * Create a new Node\n         * @param {./treemode} editor\n         * @param {Object} [params] Can contain parameters:\n         *                          {string}  field\n         *                          {boolean} fieldEditable\n         *                          {*}       value\n         *                          {String}  type  Can have values 'auto', 'array',\n         *                                          'object', or 'string'.\n         */\n\n        var Node_Node =\n        /*#__PURE__*/\n        function () {\n          function Node(editor, params) {\n            Node_classCallCheck(this, Node);\n            /** @type {./treemode} */\n\n            this.editor = editor;\n            this.dom = {};\n            this.expanded = false;\n\n            if (params && params instanceof Object) {\n              this.setField(params.field, params.fieldEditable);\n\n              if ('value' in params) {\n                this.setValue(params.value, params.type);\n              }\n\n              if ('internalValue' in params) {\n                this.setInternalValue(params.internalValue);\n              }\n            } else {\n              this.setField('');\n              this.setValue(null);\n            }\n\n            this._debouncedOnChangeValue = Object(util[\"debounce\"])(this._onChangeValue.bind(this), Node.prototype.DEBOUNCE_INTERVAL);\n            this._debouncedOnChangeField = Object(util[\"debounce\"])(this._onChangeField.bind(this), Node.prototype.DEBOUNCE_INTERVAL); // starting value for visible children\n\n            this.visibleChilds = this.getMaxVisibleChilds();\n          }\n\n          Node_createClass(Node, [{\n            key: \"getMaxVisibleChilds\",\n            value: function getMaxVisibleChilds() {\n              return this.editor && this.editor.options && this.editor.options.maxVisibleChilds ? this.editor.options.maxVisibleChilds : DEFAULT_MAX_VISIBLE_CHILDS;\n            }\n            /**\n             * Determine whether the field and/or value of this node are editable\n             * @private\n             */\n\n          }, {\n            key: \"_updateEditability\",\n            value: function _updateEditability() {\n              this.editable = {\n                field: true,\n                value: true\n              };\n\n              if (this.editor) {\n                this.editable.field = this.editor.options.mode === 'tree';\n                this.editable.value = this.editor.options.mode !== 'view';\n\n                if ((this.editor.options.mode === 'tree' || this.editor.options.mode === 'form') && typeof this.editor.options.onEditable === 'function') {\n                  var editable = this.editor.options.onEditable({\n                    field: this.field,\n                    value: this.value,\n                    path: this.getPath()\n                  });\n\n                  if (typeof editable === 'boolean') {\n                    this.editable.field = editable;\n                    this.editable.value = editable;\n                  } else {\n                    if (typeof editable.field === 'boolean') this.editable.field = editable.field;\n                    if (typeof editable.value === 'boolean') this.editable.value = editable.value;\n                  }\n                }\n              }\n            }\n            /**\n             * Get the path of this node\n             * @return {{string|number}[]} Array containing the path to this node.\n             * Element is a number if is the index of an array, a string otherwise.\n             */\n\n          }, {\n            key: \"getPath\",\n            value: function getPath() {\n              var node = this;\n              var path = [];\n\n              while (node) {\n                var field = node.getName();\n\n                if (field !== undefined) {\n                  path.unshift(field);\n                }\n\n                node = node.parent;\n              }\n\n              return path;\n            }\n            /**\n             * Get the internal path of this node, a list with the child indexes.\n             * @return {String[]} Array containing the internal path to this node\n             */\n\n          }, {\n            key: \"getInternalPath\",\n            value: function getInternalPath() {\n              var node = this;\n              var internalPath = [];\n\n              while (node) {\n                if (node.parent) {\n                  internalPath.unshift(node.getIndex());\n                }\n\n                node = node.parent;\n              }\n\n              return internalPath;\n            }\n            /**\n             * Get node serializable name\n             * @returns {String|Number}\n             */\n\n          }, {\n            key: \"getName\",\n            value: function getName() {\n              return !this.parent ? undefined // do not add an (optional) field name of the root node\n              : this.parent.type !== 'array' ? this.field : this.index;\n            }\n            /**\n             * Find child node by serializable path\n             * @param {Array<String>} path\n             */\n\n          }, {\n            key: \"findNodeByPath\",\n            value: function findNodeByPath(path) {\n              if (!path) {\n                return;\n              }\n\n              if (path.length === 0) {\n                return this;\n              }\n\n              if (path.length && this.childs && this.childs.length) {\n                for (var i = 0; i < this.childs.length; ++i) {\n                  if ('' + path[0] === '' + this.childs[i].getName()) {\n                    return this.childs[i].findNodeByPath(path.slice(1));\n                  }\n                }\n              }\n            }\n            /**\n             * Find child node by an internal path: the indexes of the childs nodes\n             * @param {Array<String>} internalPath\n             * @return {Node | undefined} Returns the node if the path exists.\n             *                            Returns undefined otherwise.\n             */\n\n          }, {\n            key: \"findNodeByInternalPath\",\n            value: function findNodeByInternalPath(internalPath) {\n              if (!internalPath) {\n                return undefined;\n              }\n\n              var node = this;\n\n              for (var i = 0; i < internalPath.length && node; i++) {\n                var childIndex = internalPath[i];\n                node = node.childs[childIndex];\n              }\n\n              return node;\n            }\n            /**\n             * @typedef {{value: String|Object|Number|Boolean, path: Array.<String|Number>}} SerializableNode\n             *\n             * Returns serializable representation for the node\n             * @return {SerializableNode}\n             */\n\n          }, {\n            key: \"serialize\",\n            value: function serialize() {\n              return {\n                value: this.getValue(),\n                path: this.getPath()\n              };\n            }\n            /**\n             * Find a Node from a JSON path like '.items[3].name'\n             * @param {string} jsonPath\n             * @return {Node | null} Returns the Node when found, returns null if not found\n             */\n\n          }, {\n            key: \"findNode\",\n            value: function findNode(jsonPath) {\n              var path = Object(util[\"parsePath\"])(jsonPath);\n              var node = this;\n\n              var _loop = function _loop() {\n                var prop = path.shift();\n\n                if (typeof prop === 'number') {\n                  if (node.type !== 'array') {\n                    throw new Error('Cannot get child node at index ' + prop + ': node is no array');\n                  }\n\n                  node = node.childs[prop];\n                } else {\n                  // string\n                  if (node.type !== 'object') {\n                    throw new Error('Cannot get child node ' + prop + ': node is no object');\n                  }\n\n                  node = node.childs.filter(function (child) {\n                    return child.field === prop;\n                  })[0];\n                }\n              };\n\n              while (node && path.length > 0) {\n                _loop();\n              }\n\n              return node;\n            }\n            /**\n             * Find all parents of this node. The parents are ordered from root node towards\n             * the original node.\n             * @return {Array.<Node>}\n             */\n\n          }, {\n            key: \"findParents\",\n            value: function findParents() {\n              var parents = [];\n              var parent = this.parent;\n\n              while (parent) {\n                parents.unshift(parent);\n                parent = parent.parent;\n              }\n\n              return parents;\n            }\n            /**\n             *\n             * @param {{dataPath: string, keyword: string, message: string, params: Object, schemaPath: string} | null} error\n             * @param {Node} [child]  When this is the error of a parent node, pointing\n             *                        to an invalid child node, the child node itself\n             *                        can be provided. If provided, clicking the error\n             *                        icon will set focus to the invalid child node.\n             */\n\n          }, {\n            key: \"setError\",\n            value: function setError(error, child) {\n              this.error = error;\n              this.errorChild = child;\n\n              if (this.dom && this.dom.tr) {\n                this.updateError();\n              }\n            }\n            /**\n             * Render the error\n             */\n\n          }, {\n            key: \"updateError\",\n            value: function updateError() {\n              var _this = this;\n\n              var error = this.fieldError || this.valueError || this.error;\n              var tdError = this.dom.tdError;\n\n              if (error && this.dom && this.dom.tr) {\n                Object(util[\"addClassName\"])(this.dom.tr, 'jsoneditor-validation-error');\n\n                if (!tdError) {\n                  tdError = document.createElement('td');\n                  this.dom.tdError = tdError;\n                  this.dom.tdValue.parentNode.appendChild(tdError);\n                }\n\n                var button = document.createElement('button');\n                button.type = 'button';\n                button.className = 'jsoneditor-button jsoneditor-schema-error';\n\n                var destroy = function destroy() {\n                  if (_this.dom.popupAnchor) {\n                    _this.dom.popupAnchor.destroy(); // this will trigger the onDestroy callback\n\n                  }\n                };\n\n                var onDestroy = function onDestroy() {\n                  delete _this.dom.popupAnchor;\n                };\n\n                var createPopup = function createPopup(destroyOnMouseOut) {\n                  var frame = _this.editor.frame;\n                  _this.dom.popupAnchor = Object(createAbsoluteAnchor[\"a\"\n                  /* createAbsoluteAnchor */\n                  ])(button, frame, onDestroy, destroyOnMouseOut);\n                  var popupWidth = 200; // must correspond to what's configured in the CSS\n\n                  var buttonRect = button.getBoundingClientRect();\n                  var frameRect = frame.getBoundingClientRect();\n                  var position = frameRect.width - buttonRect.x > popupWidth / 2 + 20 ? 'jsoneditor-above' : 'jsoneditor-left';\n                  var popover = document.createElement('div');\n                  popover.className = 'jsoneditor-popover ' + position;\n                  popover.appendChild(document.createTextNode(error.message));\n\n                  _this.dom.popupAnchor.appendChild(popover);\n                };\n\n                button.onmouseover = function () {\n                  if (!_this.dom.popupAnchor) {\n                    createPopup(true);\n                  }\n                };\n\n                button.onfocus = function () {\n                  destroy();\n                  createPopup(false);\n                };\n\n                button.onblur = function () {\n                  destroy();\n                }; // when clicking the error icon, expand all nodes towards the invalid\n                // child node, and set focus to the child node\n\n\n                var child = this.errorChild;\n\n                if (child) {\n                  button.onclick = function showInvalidNode() {\n                    child.findParents().forEach(function (parent) {\n                      parent.expand(false);\n                    });\n                    child.scrollTo(function () {\n                      child.focus();\n                    });\n                  };\n                } // apply the error message to the node\n\n\n                while (tdError.firstChild) {\n                  tdError.removeChild(tdError.firstChild);\n                }\n\n                tdError.appendChild(button);\n              } else {\n                if (this.dom.tr) {\n                  Object(util[\"removeClassName\"])(this.dom.tr, 'jsoneditor-validation-error');\n                }\n\n                if (tdError) {\n                  this.dom.tdError.parentNode.removeChild(this.dom.tdError);\n                  delete this.dom.tdError;\n                }\n              }\n            }\n            /**\n             * Get the index of this node: the index in the list of childs where this\n             * node is part of\n             * @return {number | null} Returns the index, or null if this is the root node\n             */\n\n          }, {\n            key: \"getIndex\",\n            value: function getIndex() {\n              if (this.parent) {\n                var index = this.parent.childs.indexOf(this);\n                return index !== -1 ? index : null;\n              } else {\n                return -1;\n              }\n            }\n            /**\n             * Set parent node\n             * @param {Node} parent\n             */\n\n          }, {\n            key: \"setParent\",\n            value: function setParent(parent) {\n              this.parent = parent;\n            }\n            /**\n             * Set field\n             * @param {String}  field\n             * @param {boolean} [fieldEditable]\n             */\n\n          }, {\n            key: \"setField\",\n            value: function setField(field, fieldEditable) {\n              this.field = field;\n              this.previousField = field;\n              this.fieldEditable = fieldEditable === true;\n            }\n            /**\n             * Get field\n             * @return {String}\n             */\n\n          }, {\n            key: \"getField\",\n            value: function getField() {\n              if (this.field === undefined) {\n                this._getDomField();\n              }\n\n              return this.field;\n            }\n            /**\n             * Set value. Value is a JSON structure or an element String, Boolean, etc.\n             * @param {*} value\n             * @param {String} [type]  Specify the type of the value. Can be 'auto',\n             *                         'array', 'object', or 'string'\n             */\n\n          }, {\n            key: \"setValue\",\n            value: function setValue(value, type) {\n              var childValue, child, visible;\n              var i, j;\n              var notUpdateDom = false;\n              var previousChilds = this.childs;\n              this.type = this._getType(value); // check if type corresponds with the provided type\n\n              if (type && type !== this.type) {\n                if (type === 'string' && this.type === 'auto') {\n                  this.type = type;\n                } else {\n                  throw new Error('Type mismatch: ' + 'cannot cast value of type \"' + this.type + ' to the specified type \"' + type + '\"');\n                }\n              }\n\n              if (this.type === 'array') {\n                // array\n                if (!this.childs) {\n                  this.childs = [];\n                }\n\n                for (i = 0; i < value.length; i++) {\n                  childValue = value[i];\n\n                  if (childValue !== undefined && !(childValue instanceof Function)) {\n                    if (i < this.childs.length) {\n                      // reuse existing child, keep its state\n                      child = this.childs[i];\n                      child.fieldEditable = false;\n                      child.index = i;\n                      child.setValue(childValue);\n                    } else {\n                      // create a new child\n                      child = new Node(this.editor, {\n                        value: childValue\n                      });\n                      visible = i < this.getMaxVisibleChilds();\n                      this.appendChild(child, visible, notUpdateDom);\n                    }\n                  }\n                } // cleanup redundant childs\n                // we loop backward to prevent issues with shifting index numbers\n\n\n                for (j = this.childs.length; j >= value.length; j--) {\n                  this.removeChild(this.childs[j], notUpdateDom);\n                }\n              } else if (this.type === 'object') {\n                // object\n                if (!this.childs) {\n                  this.childs = [];\n                } // cleanup redundant childs\n                // we loop backward to prevent issues with shifting index numbers\n\n\n                for (j = this.childs.length - 1; j >= 0; j--) {\n                  if (!Node_hasOwnProperty(value, this.childs[j].field)) {\n                    this.removeChild(this.childs[j], notUpdateDom);\n                  }\n                }\n\n                i = 0;\n\n                for (var childField in value) {\n                  if (Node_hasOwnProperty(value, childField)) {\n                    childValue = value[childField];\n\n                    if (childValue !== undefined && !(childValue instanceof Function)) {\n                      child = this.findChildByProperty(childField);\n\n                      if (child) {\n                        // reuse existing child, keep its state\n                        child.setField(childField, true);\n                        child.setValue(childValue);\n                      } else {\n                        // create a new child\n                        child = new Node(this.editor, {\n                          field: childField,\n                          value: childValue\n                        });\n                        visible = i < this.getMaxVisibleChilds();\n                        this.appendChild(child, visible, notUpdateDom);\n                      }\n                    }\n\n                    i++;\n                  }\n                }\n\n                this.value = ''; // sort object keys\n\n                if (this.editor.options.sortObjectKeys === true) {\n                  this.sort([], 'asc');\n                }\n              } else {\n                // value\n                this.hideChilds();\n                delete this.append;\n                delete this.showMore;\n                delete this.expanded;\n                delete this.childs;\n                this.value = value;\n              } // recreate the DOM if switching from an object/array to auto/string or vice versa\n              // needed to recreated the expand button for example\n\n\n              if (Array.isArray(previousChilds) !== Array.isArray(this.childs)) {\n                this.recreateDom();\n              }\n\n              this.updateDom({\n                updateIndexes: true\n              });\n              this.previousValue = this.value; // used only to check for changes in DOM vs JS model\n            }\n            /**\n             * Set internal value\n             * @param {*} internalValue  Internal value structure keeping type,\n             *                           order and duplicates in objects\n             */\n\n          }, {\n            key: \"setInternalValue\",\n            value: function setInternalValue(internalValue) {\n              var childValue, child, visible;\n              var i, j;\n              var notUpdateDom = false;\n              var previousChilds = this.childs;\n              this.type = internalValue.type;\n\n              if (internalValue.type === 'array') {\n                // array\n                if (!this.childs) {\n                  this.childs = [];\n                }\n\n                for (i = 0; i < internalValue.childs.length; i++) {\n                  childValue = internalValue.childs[i];\n\n                  if (childValue !== undefined && !(childValue instanceof Function)) {\n                    if (i < this.childs.length) {\n                      // reuse existing child, keep its state\n                      child = this.childs[i];\n                      child.fieldEditable = false;\n                      child.index = i;\n                      child.setInternalValue(childValue);\n                    } else {\n                      // create a new child\n                      child = new Node(this.editor, {\n                        internalValue: childValue\n                      });\n                      visible = i < this.getMaxVisibleChilds();\n                      this.appendChild(child, visible, notUpdateDom);\n                    }\n                  }\n                } // cleanup redundant childs\n                // we loop backward to prevent issues with shifting index numbers\n\n\n                for (j = this.childs.length; j >= internalValue.childs.length; j--) {\n                  this.removeChild(this.childs[j], notUpdateDom);\n                }\n              } else if (internalValue.type === 'object') {\n                // object\n                if (!this.childs) {\n                  this.childs = [];\n                }\n\n                for (i = 0; i < internalValue.childs.length; i++) {\n                  childValue = internalValue.childs[i];\n\n                  if (childValue !== undefined && !(childValue instanceof Function)) {\n                    if (i < this.childs.length) {\n                      // reuse existing child, keep its state\n                      child = this.childs[i];\n                      delete child.index;\n                      child.setField(childValue.field, true);\n                      child.setInternalValue(childValue.value);\n                    } else {\n                      // create a new child\n                      child = new Node(this.editor, {\n                        field: childValue.field,\n                        internalValue: childValue.value\n                      });\n                      visible = i < this.getMaxVisibleChilds();\n                      this.appendChild(child, visible, notUpdateDom);\n                    }\n                  }\n                } // cleanup redundant childs\n                // we loop backward to prevent issues with shifting index numbers\n\n\n                for (j = this.childs.length; j >= internalValue.childs.length; j--) {\n                  this.removeChild(this.childs[j], notUpdateDom);\n                }\n              } else {\n                // value\n                this.hideChilds();\n                delete this.append;\n                delete this.showMore;\n                delete this.expanded;\n                delete this.childs;\n                this.value = internalValue.value;\n              } // recreate the DOM if switching from an object/array to auto/string or vice versa\n              // needed to recreated the expand button for example\n\n\n              if (Array.isArray(previousChilds) !== Array.isArray(this.childs)) {\n                this.recreateDom();\n              }\n\n              this.updateDom({\n                updateIndexes: true\n              });\n              this.previousValue = this.value; // used only to check for changes in DOM vs JS model\n            }\n            /**\n             * Remove the DOM of this node and it's childs and recreate it again\n             */\n\n          }, {\n            key: \"recreateDom\",\n            value: function recreateDom() {\n              if (this.dom && this.dom.tr && this.dom.tr.parentNode) {\n                var domAnchor = this._detachFromDom();\n\n                this.clearDom();\n\n                this._attachToDom(domAnchor);\n              } else {\n                this.clearDom();\n              }\n            }\n            /**\n             * Get value. Value is a JSON structure\n             * @return {*} value\n             */\n\n          }, {\n            key: \"getValue\",\n            value: function getValue() {\n              if (this.type === 'array') {\n                var arr = [];\n                this.childs.forEach(function (child) {\n                  arr.push(child.getValue());\n                });\n                return arr;\n              } else if (this.type === 'object') {\n                var obj = {};\n                this.childs.forEach(function (child) {\n                  obj[child.getField()] = child.getValue();\n                });\n                return obj;\n              } else {\n                if (this.value === undefined) {\n                  this._getDomValue();\n                }\n\n                return this.value;\n              }\n            }\n            /**\n             * Get internal value, a structure which maintains ordering and duplicates in objects\n             * @return {*} value\n             */\n\n          }, {\n            key: \"getInternalValue\",\n            value: function getInternalValue() {\n              if (this.type === 'array') {\n                return {\n                  type: this.type,\n                  childs: this.childs.map(function (child) {\n                    return child.getInternalValue();\n                  })\n                };\n              } else if (this.type === 'object') {\n                return {\n                  type: this.type,\n                  childs: this.childs.map(function (child) {\n                    return {\n                      field: child.getField(),\n                      value: child.getInternalValue()\n                    };\n                  })\n                };\n              } else {\n                if (this.value === undefined) {\n                  this._getDomValue();\n                }\n\n                return {\n                  type: this.type,\n                  value: this.value\n                };\n              }\n            }\n            /**\n             * Get the nesting level of this node\n             * @return {Number} level\n             */\n\n          }, {\n            key: \"getLevel\",\n            value: function getLevel() {\n              return this.parent ? this.parent.getLevel() + 1 : 0;\n            }\n            /**\n             * Get jsonpath of the current node\n             * @return {Node[]} Returns an array with nodes\n             */\n\n          }, {\n            key: \"getNodePath\",\n            value: function getNodePath() {\n              var path = this.parent ? this.parent.getNodePath() : [];\n              path.push(this);\n              return path;\n            }\n            /**\n             * Create a clone of a node\n             * The complete state of a clone is copied, including whether it is expanded or\n             * not. The DOM elements are not cloned.\n             * @return {Node} clone\n             */\n\n          }, {\n            key: \"clone\",\n            value: function clone() {\n              var clone = new Node(this.editor);\n              clone.type = this.type;\n              clone.field = this.field;\n              clone.fieldInnerText = this.fieldInnerText;\n              clone.fieldEditable = this.fieldEditable;\n              clone.previousField = this.previousField;\n              clone.value = this.value;\n              clone.valueInnerText = this.valueInnerText;\n              clone.previousValue = this.previousValue;\n              clone.expanded = this.expanded;\n              clone.visibleChilds = this.visibleChilds;\n\n              if (this.childs) {\n                // an object or array\n                var cloneChilds = [];\n                this.childs.forEach(function (child) {\n                  var childClone = child.clone();\n                  childClone.setParent(clone);\n                  cloneChilds.push(childClone);\n                });\n                clone.childs = cloneChilds;\n              } else {\n                // a value\n                clone.childs = undefined;\n              }\n\n              return clone;\n            }\n            /**\n             * Expand this node and optionally its childs.\n             * @param {boolean} [recurse] Optional recursion, true by default. When\n             *                            true, all childs will be expanded recursively\n             */\n\n          }, {\n            key: \"expand\",\n            value: function expand(recurse) {\n              if (!this.childs) {\n                return;\n              } // set this node expanded\n\n\n              this.expanded = true;\n\n              if (this.dom.expand) {\n                this.dom.expand.className = 'jsoneditor-button jsoneditor-expanded';\n              }\n\n              this.showChilds();\n\n              if (recurse !== false) {\n                this.childs.forEach(function (child) {\n                  child.expand(recurse);\n                });\n              }\n            }\n            /**\n             * Collapse this node and optionally its childs.\n             * @param {boolean} [recurse] Optional recursion, true by default. When\n             *                            true, all childs will be collapsed recursively\n             */\n\n          }, {\n            key: \"collapse\",\n            value: function collapse(recurse) {\n              if (!this.childs) {\n                return;\n              }\n\n              this.hideChilds(); // collapse childs in case of recurse\n\n              if (recurse !== false) {\n                this.childs.forEach(function (child) {\n                  child.collapse(recurse);\n                });\n              } // make this node collapsed\n\n\n              if (this.dom.expand) {\n                this.dom.expand.className = 'jsoneditor-button jsoneditor-collapsed';\n              }\n\n              this.expanded = false;\n            }\n            /**\n             * Recursively show all childs when they are expanded\n             */\n\n          }, {\n            key: \"showChilds\",\n            value: function showChilds() {\n              var childs = this.childs;\n\n              if (!childs) {\n                return;\n              }\n\n              if (!this.expanded) {\n                return;\n              }\n\n              var tr = this.dom.tr;\n              var nextTr;\n              var table = tr ? tr.parentNode : undefined;\n\n              if (table) {\n                // show row with append button\n                var append = this.getAppendDom();\n\n                if (!append.parentNode) {\n                  nextTr = tr.nextSibling;\n\n                  if (nextTr) {\n                    table.insertBefore(append, nextTr);\n                  } else {\n                    table.appendChild(append);\n                  }\n                } // show childs\n\n\n                var iMax = Math.min(this.childs.length, this.visibleChilds);\n                nextTr = this._getNextTr();\n\n                for (var i = 0; i < iMax; i++) {\n                  var child = this.childs[i];\n\n                  if (!child.getDom().parentNode) {\n                    table.insertBefore(child.getDom(), nextTr);\n                  }\n\n                  child.showChilds();\n                } // show \"show more childs\" if limited\n\n\n                var showMore = this.getShowMoreDom();\n                nextTr = this._getNextTr();\n\n                if (!showMore.parentNode) {\n                  table.insertBefore(showMore, nextTr);\n                }\n\n                this.showMore.updateDom(); // to update the counter\n              }\n            }\n          }, {\n            key: \"_getNextTr\",\n            value: function _getNextTr() {\n              if (this.showMore && this.showMore.getDom().parentNode) {\n                return this.showMore.getDom();\n              }\n\n              if (this.append && this.append.getDom().parentNode) {\n                return this.append.getDom();\n              }\n            }\n            /**\n             * Hide the node with all its childs\n             * @param {{resetVisibleChilds: boolean}} [options]\n             */\n\n          }, {\n            key: \"hide\",\n            value: function hide(options) {\n              var tr = this.dom.tr;\n              var table = tr ? tr.parentNode : undefined;\n\n              if (table) {\n                table.removeChild(tr);\n              }\n\n              if (this.dom.popupAnchor) {\n                this.dom.popupAnchor.destroy();\n              }\n\n              this.hideChilds(options);\n            }\n            /**\n             * Recursively hide all childs\n             * @param {{resetVisibleChilds: boolean}} [options]\n             */\n\n          }, {\n            key: \"hideChilds\",\n            value: function hideChilds(options) {\n              var childs = this.childs;\n\n              if (!childs) {\n                return;\n              }\n\n              if (!this.expanded) {\n                return;\n              } // hide append row\n\n\n              var append = this.getAppendDom();\n\n              if (append.parentNode) {\n                append.parentNode.removeChild(append);\n              } // hide childs\n\n\n              this.childs.forEach(function (child) {\n                child.hide();\n              }); // hide \"show more\" row\n\n              var showMore = this.getShowMoreDom();\n\n              if (showMore.parentNode) {\n                showMore.parentNode.removeChild(showMore);\n              } // reset max visible childs\n\n\n              if (!options || options.resetVisibleChilds) {\n                this.visibleChilds = this.getMaxVisibleChilds();\n              }\n            }\n            /**\n             * set custom css classes on a node\n             */\n\n          }, {\n            key: \"_updateCssClassName\",\n            value: function _updateCssClassName() {\n              if (this.dom.field && this.editor && this.editor.options && typeof this.editor.options.onClassName === 'function' && this.dom.tree) {\n                Object(util[\"removeAllClassNames\"])(this.dom.tree);\n                var addClasses = this.editor.options.onClassName({\n                  path: this.getPath(),\n                  field: this.field,\n                  value: this.value\n                }) || '';\n                Object(util[\"addClassName\"])(this.dom.tree, 'jsoneditor-values ' + addClasses);\n              }\n            }\n          }, {\n            key: \"recursivelyUpdateCssClassesOnNodes\",\n            value: function recursivelyUpdateCssClassesOnNodes() {\n              this._updateCssClassName();\n\n              if (Array.isArray(this.childs)) {\n                for (var i = 0; i < this.childs.length; i++) {\n                  this.childs[i].recursivelyUpdateCssClassesOnNodes();\n                }\n              }\n            }\n            /**\n             * Goes through the path from the node to the root and ensures that it is expanded\n             */\n\n          }, {\n            key: \"expandTo\",\n            value: function expandTo() {\n              var currentNode = this.parent;\n\n              while (currentNode) {\n                if (!currentNode.expanded) {\n                  currentNode.expand();\n                }\n\n                currentNode = currentNode.parent;\n              }\n            }\n            /**\n             * Add a new child to the node.\n             * Only applicable when Node value is of type array or object\n             * @param {Node} node\n             * @param {boolean} [visible] If true (default), the child will be rendered\n             * @param {boolean} [updateDom]  If true (default), the DOM of both parent\n             *                               node and appended node will be updated\n             *                               (child count, indexes)\n             */\n\n          }, {\n            key: \"appendChild\",\n            value: function appendChild(node, visible, updateDom) {\n              if (this._hasChilds()) {\n                // adjust the link to the parent\n                node.setParent(this);\n                node.fieldEditable = this.type === 'object';\n\n                if (this.type === 'array') {\n                  node.index = this.childs.length;\n                }\n\n                if (this.type === 'object' && node.field === undefined) {\n                  // initialize field value if needed\n                  node.setField('');\n                }\n\n                this.childs.push(node);\n\n                if (this.expanded && visible !== false) {\n                  // insert into the DOM, before the appendRow\n                  var newTr = node.getDom();\n\n                  var nextTr = this._getNextTr();\n\n                  var table = nextTr ? nextTr.parentNode : undefined;\n\n                  if (nextTr && table) {\n                    table.insertBefore(newTr, nextTr);\n                  }\n\n                  node.showChilds();\n                  this.visibleChilds++;\n                }\n\n                if (updateDom !== false) {\n                  this.updateDom({\n                    updateIndexes: true\n                  });\n                  node.updateDom({\n                    recurse: true\n                  });\n                }\n              }\n            }\n            /**\n             * Move a node from its current parent to this node\n             * Only applicable when Node value is of type array or object\n             * @param {Node} node\n             * @param {Node} beforeNode\n             */\n\n          }, {\n            key: \"moveBefore\",\n            value: function moveBefore(node, beforeNode) {\n              if (this._hasChilds()) {\n                // create a temporary row, to prevent the scroll position from jumping\n                // when removing the node\n                var tbody = this.dom.tr ? this.dom.tr.parentNode : undefined;\n\n                if (tbody) {\n                  var trTemp = document.createElement('tr');\n                  trTemp.style.height = tbody.clientHeight + 'px';\n                  tbody.appendChild(trTemp);\n                }\n\n                if (node.parent) {\n                  node.parent.removeChild(node);\n                }\n\n                if (beforeNode instanceof Node_AppendNode || !beforeNode) {\n                  // the this.childs.length + 1 is to reckon with the node that we're about to add\n                  if (this.childs.length + 1 > this.visibleChilds) {\n                    var lastVisibleNode = this.childs[this.visibleChilds - 1];\n                    this.insertBefore(node, lastVisibleNode);\n                  } else {\n                    this.appendChild(node);\n                  }\n                } else {\n                  this.insertBefore(node, beforeNode);\n                }\n\n                if (tbody) {\n                  tbody.removeChild(trTemp);\n                }\n              }\n            }\n            /**\n             * Insert a new child before a given node\n             * Only applicable when Node value is of type array or object\n             * @param {Node} node\n             * @param {Node} beforeNode\n             */\n\n          }, {\n            key: \"insertBefore\",\n            value: function insertBefore(node, beforeNode) {\n              if (this._hasChilds()) {\n                this.visibleChilds++; // initialize field value if needed\n\n                if (this.type === 'object' && node.field === undefined) {\n                  node.setField('');\n                }\n\n                if (beforeNode === this.append) {\n                  // append to the child nodes\n                  // adjust the link to the parent\n                  node.setParent(this);\n                  node.fieldEditable = this.type === 'object';\n                  this.childs.push(node);\n                } else {\n                  // insert before a child node\n                  var index = this.childs.indexOf(beforeNode);\n\n                  if (index === -1) {\n                    throw new Error('Node not found');\n                  } // adjust the link to the parent\n\n\n                  node.setParent(this);\n                  node.fieldEditable = this.type === 'object';\n                  this.childs.splice(index, 0, node);\n                }\n\n                if (this.expanded) {\n                  // insert into the DOM\n                  var newTr = node.getDom();\n                  var nextTr = beforeNode.getDom();\n                  var table = nextTr ? nextTr.parentNode : undefined;\n\n                  if (nextTr && table) {\n                    table.insertBefore(newTr, nextTr);\n                  }\n\n                  node.showChilds();\n                  this.showChilds();\n                }\n\n                this.updateDom({\n                  updateIndexes: true\n                });\n                node.updateDom({\n                  recurse: true\n                });\n              }\n            }\n            /**\n             * Insert a new child before a given node\n             * Only applicable when Node value is of type array or object\n             * @param {Node} node\n             * @param {Node} afterNode\n             */\n\n          }, {\n            key: \"insertAfter\",\n            value: function insertAfter(node, afterNode) {\n              if (this._hasChilds()) {\n                var index = this.childs.indexOf(afterNode);\n                var beforeNode = this.childs[index + 1];\n\n                if (beforeNode) {\n                  this.insertBefore(node, beforeNode);\n                } else {\n                  this.appendChild(node);\n                }\n              }\n            }\n            /**\n             * Search in this node\n             * Searches are case insensitive.\n             * @param {String} text\n             * @param {Node[]} [results] Array where search results will be added\n             *                           used to count and limit the results whilst iterating\n             * @return {Node[]} results  Array with nodes containing the search text\n             */\n\n          }, {\n            key: \"search\",\n            value: function search(text, results) {\n              if (!Array.isArray(results)) {\n                results = [];\n              }\n\n              var index;\n              var search = text ? text.toLowerCase() : undefined; // delete old search data\n\n              delete this.searchField;\n              delete this.searchValue; // search in field\n\n              if (this.field !== undefined && results.length <= this.MAX_SEARCH_RESULTS) {\n                var field = String(this.field).toLowerCase();\n                index = field.indexOf(search);\n\n                if (index !== -1) {\n                  this.searchField = true;\n                  results.push({\n                    node: this,\n                    elem: 'field'\n                  });\n                } // update dom\n\n\n                this._updateDomField();\n              } // search in value\n\n\n              if (this._hasChilds()) {\n                // array, object\n                // search the nodes childs\n                if (this.childs) {\n                  this.childs.forEach(function (child) {\n                    child.search(text, results);\n                  });\n                }\n              } else {\n                // string, auto\n                if (this.value !== undefined && results.length <= this.MAX_SEARCH_RESULTS) {\n                  var value = String(this.value).toLowerCase();\n                  index = value.indexOf(search);\n\n                  if (index !== -1) {\n                    this.searchValue = true;\n                    results.push({\n                      node: this,\n                      elem: 'value'\n                    });\n                  } // update dom\n\n\n                  this._updateDomValue();\n                }\n              }\n\n              return results;\n            }\n            /**\n             * Move the scroll position such that this node is in the visible area.\n             * The node will not get the focus\n             * @param {function(boolean)} [callback]\n             */\n\n          }, {\n            key: \"scrollTo\",\n            value: function scrollTo(callback) {\n              this.expandPathToNode();\n\n              if (this.dom.tr && this.dom.tr.parentNode) {\n                this.editor.scrollTo(this.dom.tr.offsetTop, callback);\n              }\n            }\n            /**\n             * if the node is not visible, expand its parents\n             */\n\n          }, {\n            key: \"expandPathToNode\",\n            value: function expandPathToNode() {\n              var node = this;\n              var recurse = false;\n\n              while (node && node.parent) {\n                // expand visible childs of the parent if needed\n                var index = node.parent.type === 'array' ? node.index : node.parent.childs.indexOf(node);\n\n                while (node.parent.visibleChilds < index + 1) {\n                  node.parent.visibleChilds += this.getMaxVisibleChilds();\n                } // expand the parent itself\n\n\n                node.parent.expand(recurse);\n                node = node.parent;\n              }\n            }\n            /**\n             * Set focus to this node\n             * @param {String} [elementName]  The field name of the element to get the\n             *                                focus available values: 'drag', 'menu',\n             *                                'expand', 'field', 'value' (default)\n             */\n\n          }, {\n            key: \"focus\",\n            value: function focus(elementName) {\n              Node.focusElement = elementName;\n\n              if (this.dom.tr && this.dom.tr.parentNode) {\n                var dom = this.dom;\n\n                switch (elementName) {\n                  case 'drag':\n                    if (dom.drag) {\n                      dom.drag.focus();\n                    } else {\n                      dom.menu.focus();\n                    }\n\n                    break;\n\n                  case 'menu':\n                    dom.menu.focus();\n                    break;\n\n                  case 'expand':\n                    if (this._hasChilds()) {\n                      dom.expand.focus();\n                    } else if (dom.field && this.fieldEditable) {\n                      dom.field.focus();\n                      Object(util[\"selectContentEditable\"])(dom.field);\n                    } else if (dom.value && !this._hasChilds()) {\n                      dom.value.focus();\n                      Object(util[\"selectContentEditable\"])(dom.value);\n                    } else {\n                      dom.menu.focus();\n                    }\n\n                    break;\n\n                  case 'field':\n                    if (dom.field && this.fieldEditable) {\n                      dom.field.focus();\n                      Object(util[\"selectContentEditable\"])(dom.field);\n                    } else if (dom.value && !this._hasChilds()) {\n                      dom.value.focus();\n                      Object(util[\"selectContentEditable\"])(dom.value);\n                    } else if (this._hasChilds()) {\n                      dom.expand.focus();\n                    } else {\n                      dom.menu.focus();\n                    }\n\n                    break;\n\n                  case 'value':\n                  default:\n                    if (dom.select) {\n                      // enum select box\n                      dom.select.focus();\n                    } else if (dom.value && !this._hasChilds()) {\n                      dom.value.focus();\n                      Object(util[\"selectContentEditable\"])(dom.value);\n                    } else if (dom.field && this.fieldEditable) {\n                      dom.field.focus();\n                      Object(util[\"selectContentEditable\"])(dom.field);\n                    } else if (this._hasChilds()) {\n                      dom.expand.focus();\n                    } else {\n                      dom.menu.focus();\n                    }\n\n                    break;\n                }\n              }\n            }\n            /**\n             * Check if given node is a child. The method will check recursively to find\n             * this node.\n             * @param {Node} node\n             * @return {boolean} containsNode\n             */\n\n          }, {\n            key: \"containsNode\",\n            value: function containsNode(node) {\n              if (this === node) {\n                return true;\n              }\n\n              var childs = this.childs;\n\n              if (childs) {\n                // TODO: use the js5 Array.some() here?\n                for (var i = 0, iMax = childs.length; i < iMax; i++) {\n                  if (childs[i].containsNode(node)) {\n                    return true;\n                  }\n                }\n              }\n\n              return false;\n            }\n            /**\n             * Remove a child from the node.\n             * Only applicable when Node value is of type array or object\n             * @param {Node} node   The child node to be removed;\n             * @param {boolean} [updateDom]  If true (default), the DOM of the parent\n             *                               node will be updated (like child count)\n             * @return {Node | undefined} node  The removed node on success,\n             *                                             else undefined\n             */\n\n          }, {\n            key: \"removeChild\",\n            value: function removeChild(node, updateDom) {\n              if (this.childs) {\n                var index = this.childs.indexOf(node);\n\n                if (index !== -1) {\n                  if (index < this.visibleChilds && this.expanded) {\n                    this.visibleChilds--;\n                  }\n\n                  node.hide(); // delete old search results\n\n                  delete node.searchField;\n                  delete node.searchValue;\n                  var removedNode = this.childs.splice(index, 1)[0];\n                  removedNode.parent = null;\n\n                  if (updateDom !== false) {\n                    this.updateDom({\n                      updateIndexes: true\n                    });\n                  }\n\n                  return removedNode;\n                }\n              }\n\n              return undefined;\n            }\n            /**\n             * Remove a child node node from this node\n             * This method is equal to Node.removeChild, except that _remove fire an\n             * onChange event.\n             * @param {Node} node\n             * @private\n             */\n\n          }, {\n            key: \"_remove\",\n            value: function _remove(node) {\n              this.removeChild(node);\n            }\n            /**\n             * Change the type of the value of this Node\n             * @param {String} newType\n             */\n\n          }, {\n            key: \"changeType\",\n            value: function changeType(newType) {\n              var oldType = this.type;\n\n              if (oldType === newType) {\n                // type is not changed\n                return;\n              }\n\n              if ((newType === 'string' || newType === 'auto') && (oldType === 'string' || oldType === 'auto')) {\n                // this is an easy change\n                this.type = newType;\n              } else {\n                // change from array to object, or from string/auto to object/array\n                var domAnchor = this._detachFromDom(); // delete the old DOM\n\n\n                this.clearDom(); // adjust the field and the value\n\n                this.type = newType; // adjust childs\n\n                if (newType === 'object') {\n                  if (!this.childs) {\n                    this.childs = [];\n                  }\n\n                  this.childs.forEach(function (child) {\n                    child.clearDom();\n                    delete child.index;\n                    child.fieldEditable = true;\n\n                    if (child.field === undefined) {\n                      child.field = '';\n                    }\n                  });\n\n                  if (oldType === 'string' || oldType === 'auto') {\n                    this.expanded = true;\n                  }\n                } else if (newType === 'array') {\n                  if (!this.childs) {\n                    this.childs = [];\n                  }\n\n                  this.childs.forEach(function (child, index) {\n                    child.clearDom();\n                    child.fieldEditable = false;\n                    child.index = index;\n                  });\n\n                  if (oldType === 'string' || oldType === 'auto') {\n                    this.expanded = true;\n                  }\n                } else {\n                  this.expanded = false;\n                }\n\n                this._attachToDom(domAnchor);\n              }\n\n              if (newType === 'auto' || newType === 'string') {\n                // cast value to the correct type\n                if (newType === 'string') {\n                  this.value = String(this.value);\n                } else {\n                  this.value = Object(util[\"parseString\"])(String(this.value));\n                }\n\n                this.focus();\n              }\n\n              this.updateDom({\n                updateIndexes: true\n              });\n            }\n            /**\n             * Test whether the JSON contents of this node are deep equal to provided JSON object.\n             * @param {*} json\n             */\n\n          }, {\n            key: \"deepEqual\",\n            value: function deepEqual(json) {\n              var i;\n\n              if (this.type === 'array') {\n                if (!Array.isArray(json)) {\n                  return false;\n                }\n\n                if (this.childs.length !== json.length) {\n                  return false;\n                }\n\n                for (i = 0; i < this.childs.length; i++) {\n                  if (!this.childs[i].deepEqual(json[i])) {\n                    return false;\n                  }\n                }\n              } else if (this.type === 'object') {\n                if (_typeof(json) !== 'object' || !json) {\n                  return false;\n                } // TODO: for better efficiency, we could create a property `isDuplicate` on all of the childs\n                // and keep that up to date. This should make deepEqual about 20% faster.\n\n\n                var props = {};\n                var propCount = 0;\n\n                for (i = 0; i < this.childs.length; i++) {\n                  var child = this.childs[i];\n\n                  if (!props[child.field]) {\n                    // We can have childs with duplicate field names.\n                    // We take the first, and ignore the others.\n                    props[child.field] = true;\n                    propCount++;\n\n                    if (!(child.field in json)) {\n                      return false;\n                    }\n\n                    if (!child.deepEqual(json[child.field])) {\n                      return false;\n                    }\n                  }\n                }\n\n                if (propCount !== Object.keys(json).length) {\n                  return false;\n                }\n              } else {\n                if (this.value !== json) {\n                  return false;\n                }\n              }\n\n              return true;\n            }\n            /**\n             * Retrieve value from DOM\n             * @private\n             */\n\n          }, {\n            key: \"_getDomValue\",\n            value: function _getDomValue() {\n              this._clearValueError();\n\n              if (this.dom.value && this.type !== 'array' && this.type !== 'object') {\n                this.valueInnerText = Object(util[\"getInnerText\"])(this.dom.value);\n              }\n\n              if (this.valueInnerText !== undefined) {\n                try {\n                  // retrieve the value\n                  var value;\n\n                  if (this.type === 'string') {\n                    value = this._unescapeHTML(this.valueInnerText);\n                  } else {\n                    var str = this._unescapeHTML(this.valueInnerText);\n\n                    value = Object(util[\"parseString\"])(str);\n                  }\n\n                  if (value !== this.value) {\n                    this.value = value;\n\n                    this._debouncedOnChangeValue();\n                  }\n                } catch (err) {\n                  // keep the previous value\n                  this._setValueError(Object(i18n[\"c\"\n                  /* translate */\n                  ])('cannotParseValueError'));\n                }\n              }\n            }\n            /**\n             * Show a local error in case of invalid value\n             * @param {string} message\n             * @private\n             */\n\n          }, {\n            key: \"_setValueError\",\n            value: function _setValueError(message) {\n              this.valueError = {\n                message: message\n              };\n              this.updateError();\n            }\n          }, {\n            key: \"_clearValueError\",\n            value: function _clearValueError() {\n              if (this.valueError) {\n                this.valueError = null;\n                this.updateError();\n              }\n            }\n            /**\n             * Show a local error in case of invalid or duplicate field\n             * @param {string} message\n             * @private\n             */\n\n          }, {\n            key: \"_setFieldError\",\n            value: function _setFieldError(message) {\n              this.fieldError = {\n                message: message\n              };\n              this.updateError();\n            }\n          }, {\n            key: \"_clearFieldError\",\n            value: function _clearFieldError() {\n              if (this.fieldError) {\n                this.fieldError = null;\n                this.updateError();\n              }\n            }\n            /**\n             * Handle a changed value\n             * @private\n             */\n\n          }, {\n            key: \"_onChangeValue\",\n            value: function _onChangeValue() {\n              // get current selection, then override the range such that we can select\n              // the added/removed text on undo/redo\n              var oldSelection = this.editor.getDomSelection();\n\n              if (oldSelection.range) {\n                var undoDiff = Object(util[\"textDiff\"])(String(this.value), String(this.previousValue));\n                oldSelection.range.startOffset = undoDiff.start;\n                oldSelection.range.endOffset = undoDiff.end;\n              }\n\n              var newSelection = this.editor.getDomSelection();\n\n              if (newSelection.range) {\n                var redoDiff = Object(util[\"textDiff\"])(String(this.previousValue), String(this.value));\n                newSelection.range.startOffset = redoDiff.start;\n                newSelection.range.endOffset = redoDiff.end;\n              }\n\n              this.editor._onAction('editValue', {\n                path: this.getInternalPath(),\n                oldValue: this.previousValue,\n                newValue: this.value,\n                oldSelection: oldSelection,\n                newSelection: newSelection\n              });\n\n              this.previousValue = this.value;\n            }\n            /**\n             * Handle a changed field\n             * @private\n             */\n\n          }, {\n            key: \"_onChangeField\",\n            value: function _onChangeField() {\n              // get current selection, then override the range such that we can select\n              // the added/removed text on undo/redo\n              var oldSelection = this.editor.getDomSelection();\n              var previous = this.previousField || '';\n\n              if (oldSelection.range) {\n                var undoDiff = Object(util[\"textDiff\"])(this.field, previous);\n                oldSelection.range.startOffset = undoDiff.start;\n                oldSelection.range.endOffset = undoDiff.end;\n              }\n\n              var newSelection = this.editor.getDomSelection();\n\n              if (newSelection.range) {\n                var redoDiff = Object(util[\"textDiff\"])(previous, this.field);\n                newSelection.range.startOffset = redoDiff.start;\n                newSelection.range.endOffset = redoDiff.end;\n              }\n\n              this.editor._onAction('editField', {\n                parentPath: this.parent.getInternalPath(),\n                index: this.getIndex(),\n                oldValue: this.previousField,\n                newValue: this.field,\n                oldSelection: oldSelection,\n                newSelection: newSelection\n              });\n\n              this.previousField = this.field;\n            }\n            /**\n             * Update dom value:\n             * - the text color of the value, depending on the type of the value\n             * - the height of the field, depending on the width\n             * - background color in case it is empty\n             * @private\n             */\n\n          }, {\n            key: \"_updateDomValue\",\n            value: function _updateDomValue() {\n              var domValue = this.dom.value;\n\n              if (domValue) {\n                var classNames = ['jsoneditor-value']; // set text color depending on value type\n\n                var value = this.value;\n                var valueType = this.type === 'auto' ? Object(util[\"getType\"])(value) : this.type;\n                var valueIsUrl = valueType === 'string' && Object(util[\"isUrl\"])(value);\n                classNames.push('jsoneditor-' + valueType);\n\n                if (valueIsUrl) {\n                  classNames.push('jsoneditor-url');\n                } // visual styling when empty\n\n\n                var isEmpty = String(this.value) === '' && this.type !== 'array' && this.type !== 'object';\n\n                if (isEmpty) {\n                  classNames.push('jsoneditor-empty');\n                } // highlight when there is a search result\n\n\n                if (this.searchValueActive) {\n                  classNames.push('jsoneditor-highlight-active');\n                }\n\n                if (this.searchValue) {\n                  classNames.push('jsoneditor-highlight');\n                }\n\n                domValue.className = classNames.join(' '); // update title\n\n                if (valueType === 'array' || valueType === 'object') {\n                  var count = this.childs ? this.childs.length : 0;\n                  domValue.title = this.type + ' containing ' + count + ' items';\n                } else if (valueIsUrl && this.editable.value) {\n                  domValue.title = Object(i18n[\"c\"\n                  /* translate */\n                  ])('openUrl');\n                } else {\n                  domValue.title = '';\n                } // show checkbox when the value is a boolean\n\n\n                if (valueType === 'boolean' && this.editable.value) {\n                  if (!this.dom.checkbox) {\n                    this.dom.checkbox = document.createElement('input');\n                    this.dom.checkbox.type = 'checkbox';\n                    this.dom.tdCheckbox = document.createElement('td');\n                    this.dom.tdCheckbox.className = 'jsoneditor-tree';\n                    this.dom.tdCheckbox.appendChild(this.dom.checkbox);\n                    this.dom.tdValue.parentNode.insertBefore(this.dom.tdCheckbox, this.dom.tdValue);\n                  }\n\n                  this.dom.checkbox.checked = this.value;\n                } else {\n                  // cleanup checkbox when displayed\n                  if (this.dom.tdCheckbox) {\n                    this.dom.tdCheckbox.parentNode.removeChild(this.dom.tdCheckbox);\n                    delete this.dom.tdCheckbox;\n                    delete this.dom.checkbox;\n                  }\n                } // create select box when this node has an enum object\n\n\n                if (this[\"enum\"] && this.editable.value) {\n                  if (!this.dom.select) {\n                    this.dom.select = document.createElement('select');\n                    this.id = this.field + '_' + new Date().getUTCMilliseconds();\n                    this.dom.select.id = this.id;\n                    this.dom.select.name = this.dom.select.id; // Create the default empty option\n\n                    this.dom.select.option = document.createElement('option');\n                    this.dom.select.option.value = '';\n                    this.dom.select.option.innerHTML = '--';\n                    this.dom.select.appendChild(this.dom.select.option); // Iterate all enum values and add them as options\n\n                    for (var i = 0; i < this[\"enum\"].length; i++) {\n                      this.dom.select.option = document.createElement('option');\n                      this.dom.select.option.value = this[\"enum\"][i];\n                      this.dom.select.option.innerHTML = this[\"enum\"][i];\n\n                      if (this.dom.select.option.value === this.value) {\n                        this.dom.select.option.selected = true;\n                      }\n\n                      this.dom.select.appendChild(this.dom.select.option);\n                    }\n\n                    this.dom.tdSelect = document.createElement('td');\n                    this.dom.tdSelect.className = 'jsoneditor-tree';\n                    this.dom.tdSelect.appendChild(this.dom.select);\n                    this.dom.tdValue.parentNode.insertBefore(this.dom.tdSelect, this.dom.tdValue);\n                  } // If the enum is inside a composite type display\n                  // both the simple input and the dropdown field\n\n\n                  if (this.schema && !Node_hasOwnProperty(this.schema, 'oneOf') && !Node_hasOwnProperty(this.schema, 'anyOf') && !Node_hasOwnProperty(this.schema, 'allOf')) {\n                    this.valueFieldHTML = this.dom.tdValue.innerHTML;\n                    this.dom.tdValue.style.visibility = 'hidden';\n                    this.dom.tdValue.innerHTML = '';\n                  } else {\n                    delete this.valueFieldHTML;\n                  }\n                } else {\n                  // cleanup select box when displayed\n                  if (this.dom.tdSelect) {\n                    this.dom.tdSelect.parentNode.removeChild(this.dom.tdSelect);\n                    delete this.dom.tdSelect;\n                    delete this.dom.select;\n                    this.dom.tdValue.innerHTML = this.valueFieldHTML;\n                    this.dom.tdValue.style.visibility = '';\n                    delete this.valueFieldHTML;\n                  }\n                } // show color picker when value is a color\n\n\n                if (this.editable.value && this.editor.options.colorPicker && typeof value === 'string' && Object(util[\"isValidColor\"])(value)) {\n                  if (!this.dom.color) {\n                    this.dom.color = document.createElement('div');\n                    this.dom.color.className = 'jsoneditor-color';\n                    this.dom.tdColor = document.createElement('td');\n                    this.dom.tdColor.className = 'jsoneditor-tree';\n                    this.dom.tdColor.appendChild(this.dom.color);\n                    this.dom.tdValue.parentNode.insertBefore(this.dom.tdColor, this.dom.tdValue); // this is a bit hacky, overriding the text color like this. find a nicer solution\n\n                    this.dom.value.style.color = '#1A1A1A';\n                  } // update the color background\n\n\n                  this.dom.color.style.backgroundColor = value;\n                } else {\n                  // cleanup color picker when displayed\n                  this._deleteDomColor();\n                } // show date tag when value is a timestamp in milliseconds\n\n\n                if (this.editor.options.timestampTag && typeof value === 'number' && value > YEAR_2000 && !isNaN(new Date(value).valueOf())) {\n                  if (!this.dom.date) {\n                    this.dom.date = document.createElement('div');\n                    this.dom.date.className = 'jsoneditor-date';\n                    this.dom.value.parentNode.appendChild(this.dom.date);\n                  }\n\n                  this.dom.date.innerHTML = new Date(value).toISOString();\n                  this.dom.date.title = new Date(value).toString();\n                } else {\n                  // cleanup date tag\n                  if (this.dom.date) {\n                    this.dom.date.parentNode.removeChild(this.dom.date);\n                    delete this.dom.date;\n                  }\n                } // strip formatting from the contents of the editable div\n\n\n                Object(util[\"stripFormatting\"])(domValue);\n\n                this._updateDomDefault();\n              }\n            }\n          }, {\n            key: \"_deleteDomColor\",\n            value: function _deleteDomColor() {\n              if (this.dom.color) {\n                this.dom.tdColor.parentNode.removeChild(this.dom.tdColor);\n                delete this.dom.tdColor;\n                delete this.dom.color;\n                this.dom.value.style.color = '';\n              }\n            }\n            /**\n             * Update dom field:\n             * - the text color of the field, depending on the text\n             * - the height of the field, depending on the width\n             * - background color in case it is empty\n             * @private\n             */\n\n          }, {\n            key: \"_updateDomField\",\n            value: function _updateDomField() {\n              var domField = this.dom.field;\n\n              if (domField) {\n                var tooltip = Object(util[\"makeFieldTooltip\"])(this.schema, this.editor.options.language);\n\n                if (tooltip) {\n                  domField.title = tooltip;\n                } // make backgound color lightgray when empty\n\n\n                var isEmpty = String(this.field) === '' && this.parent.type !== 'array';\n\n                if (isEmpty) {\n                  Object(util[\"addClassName\"])(domField, 'jsoneditor-empty');\n                } else {\n                  Object(util[\"removeClassName\"])(domField, 'jsoneditor-empty');\n                } // highlight when there is a search result\n\n\n                if (this.searchFieldActive) {\n                  Object(util[\"addClassName\"])(domField, 'jsoneditor-highlight-active');\n                } else {\n                  Object(util[\"removeClassName\"])(domField, 'jsoneditor-highlight-active');\n                }\n\n                if (this.searchField) {\n                  Object(util[\"addClassName\"])(domField, 'jsoneditor-highlight');\n                } else {\n                  Object(util[\"removeClassName\"])(domField, 'jsoneditor-highlight');\n                } // strip formatting from the contents of the editable div\n\n\n                Object(util[\"stripFormatting\"])(domField);\n              }\n            }\n            /**\n             * Retrieve field from DOM\n             * @param {boolean} [forceUnique]  If true, the field name will be changed\n             *                                 into a unique name in case it is a duplicate.\n             * @private\n             */\n\n          }, {\n            key: \"_getDomField\",\n            value: function _getDomField(forceUnique) {\n              this._clearFieldError();\n\n              if (this.dom.field && this.fieldEditable) {\n                this.fieldInnerText = Object(util[\"getInnerText\"])(this.dom.field);\n              }\n\n              if (this.fieldInnerText !== undefined) {\n                try {\n                  var field = this._unescapeHTML(this.fieldInnerText);\n\n                  var existingFieldNames = this.parent.getFieldNames(this);\n                  var isDuplicate = existingFieldNames.indexOf(field) !== -1;\n\n                  if (!isDuplicate) {\n                    if (field !== this.field) {\n                      this.field = field;\n\n                      this._debouncedOnChangeField();\n                    }\n                  } else {\n                    if (forceUnique) {\n                      // fix duplicate field: change it into a unique name\n                      field = Object(util[\"findUniqueName\"])(field, existingFieldNames);\n\n                      if (field !== this.field) {\n                        this.field = field; // TODO: don't debounce but resolve right away, and cancel current debounce\n\n                        this._debouncedOnChangeField();\n                      }\n                    } else {\n                      this._setFieldError(Object(i18n[\"c\"\n                      /* translate */\n                      ])('duplicateFieldError'));\n                    }\n                  }\n                } catch (err) {\n                  // keep the previous field value\n                  this._setFieldError(Object(i18n[\"c\"\n                  /* translate */\n                  ])('cannotParseFieldError'));\n                }\n              }\n            }\n            /**\n             * Update the value of the schema default element in the DOM.\n             * @private\n             * @returns {undefined}\n             */\n\n          }, {\n            key: \"_updateDomDefault\",\n            value: function _updateDomDefault() {\n              // Short-circuit if schema is missing, has no default, or if Node has children\n              if (!this.schema || this.schema[\"default\"] === undefined || this._hasChilds()) {\n                return;\n              } // select either enum dropdown (select) or input value\n\n\n              var inputElement = this.dom.select ? this.dom.select : this.dom.value;\n\n              if (!inputElement) {\n                return;\n              }\n\n              if (this.value === this.schema[\"default\"]) {\n                inputElement.title = Object(i18n[\"c\"\n                /* translate */\n                ])('default');\n                Object(util[\"addClassName\"])(inputElement, 'jsoneditor-is-default');\n                Object(util[\"removeClassName\"])(inputElement, 'jsoneditor-is-not-default');\n              } else {\n                inputElement.removeAttribute('title');\n                Object(util[\"removeClassName\"])(inputElement, 'jsoneditor-is-default');\n                Object(util[\"addClassName\"])(inputElement, 'jsoneditor-is-not-default');\n              }\n            }\n            /**\n             * Clear the dom of the node\n             */\n\n          }, {\n            key: \"clearDom\",\n            value: function clearDom() {\n              // TODO: hide the node first?\n              // this.hide();\n              // TODO: recursively clear dom?\n              this.dom = {};\n            }\n            /**\n             * Get the HTML DOM TR element of the node.\n             * The dom will be generated when not yet created\n             * @return {Element} tr    HTML DOM TR Element\n             */\n\n          }, {\n            key: \"getDom\",\n            value: function getDom() {\n              var dom = this.dom;\n\n              if (dom.tr) {\n                return dom.tr;\n              }\n\n              this._updateEditability(); // create row\n\n\n              dom.tr = document.createElement('tr');\n              dom.tr.node = this;\n\n              if (this.editor.options.mode === 'tree') {\n                // note: we take here the global setting\n                var tdDrag = document.createElement('td');\n\n                if (this.editable.field) {\n                  // create draggable area\n                  if (this.parent) {\n                    var domDrag = document.createElement('button');\n                    domDrag.type = 'button';\n                    dom.drag = domDrag;\n                    domDrag.className = 'jsoneditor-button jsoneditor-dragarea';\n                    domDrag.title = Object(i18n[\"c\"\n                    /* translate */\n                    ])('drag');\n                    tdDrag.appendChild(domDrag);\n                  }\n                }\n\n                dom.tr.appendChild(tdDrag); // create context menu\n\n                var tdMenu = document.createElement('td');\n                var menu = document.createElement('button');\n                menu.type = 'button';\n                dom.menu = menu;\n                menu.className = 'jsoneditor-button jsoneditor-contextmenu';\n                menu.title = Object(i18n[\"c\"\n                /* translate */\n                ])('actionsMenu');\n                tdMenu.appendChild(dom.menu);\n                dom.tr.appendChild(tdMenu);\n              } // create tree and field\n\n\n              var tdField = document.createElement('td');\n              dom.tr.appendChild(tdField);\n              dom.tree = this._createDomTree();\n              tdField.appendChild(dom.tree);\n              this.updateDom({\n                updateIndexes: true\n              });\n              return dom.tr;\n            }\n            /**\n             * Test whether a Node is rendered and visible\n             * @returns {boolean}\n             */\n\n          }, {\n            key: \"isVisible\",\n            value: function isVisible() {\n              return this.dom && this.dom.tr && this.dom.tr.parentNode || false;\n            }\n            /**\n             * Test if this node is a sescendant of an other node\n             * @param {Node} node\n             * @return {boolean} isDescendant\n             * @private\n             */\n\n          }, {\n            key: \"isDescendantOf\",\n            value: function isDescendantOf(node) {\n              var n = this.parent;\n\n              while (n) {\n                if (n === node) {\n                  return true;\n                }\n\n                n = n.parent;\n              }\n\n              return false;\n            }\n            /**\n             * Create an editable field\n             * @return {Element} domField\n             * @private\n             */\n\n          }, {\n            key: \"_createDomField\",\n            value: function _createDomField() {\n              return document.createElement('div');\n            }\n            /**\n             * Set highlighting for this node and all its childs.\n             * Only applied to the currently visible (expanded childs)\n             * @param {boolean} highlight\n             */\n\n          }, {\n            key: \"setHighlight\",\n            value: function setHighlight(highlight) {\n              if (this.dom.tr) {\n                if (highlight) {\n                  Object(util[\"addClassName\"])(this.dom.tr, 'jsoneditor-highlight');\n                } else {\n                  Object(util[\"removeClassName\"])(this.dom.tr, 'jsoneditor-highlight');\n                }\n\n                if (this.append) {\n                  this.append.setHighlight(highlight);\n                }\n\n                if (this.childs) {\n                  this.childs.forEach(function (child) {\n                    child.setHighlight(highlight);\n                  });\n                }\n              }\n            }\n            /**\n             * Select or deselect a node\n             * @param {boolean} selected\n             * @param {boolean} [isFirst]\n             */\n\n          }, {\n            key: \"setSelected\",\n            value: function setSelected(selected, isFirst) {\n              this.selected = selected;\n\n              if (this.dom.tr) {\n                if (selected) {\n                  Object(util[\"addClassName\"])(this.dom.tr, 'jsoneditor-selected');\n                } else {\n                  Object(util[\"removeClassName\"])(this.dom.tr, 'jsoneditor-selected');\n                }\n\n                if (isFirst) {\n                  Object(util[\"addClassName\"])(this.dom.tr, 'jsoneditor-first');\n                } else {\n                  Object(util[\"removeClassName\"])(this.dom.tr, 'jsoneditor-first');\n                }\n\n                if (this.append) {\n                  this.append.setSelected(selected);\n                }\n\n                if (this.showMore) {\n                  this.showMore.setSelected(selected);\n                }\n\n                if (this.childs) {\n                  this.childs.forEach(function (child) {\n                    child.setSelected(selected);\n                  });\n                }\n              }\n            }\n            /**\n             * Update the value of the node. Only primitive types are allowed, no Object\n             * or Array is allowed.\n             * @param {String | Number | Boolean | null} value\n             */\n\n          }, {\n            key: \"updateValue\",\n            value: function updateValue(value) {\n              this.value = value;\n              this.previousValue = value;\n              this.valueError = undefined;\n              this.updateDom();\n            }\n            /**\n             * Update the field of the node.\n             * @param {String} field\n             */\n\n          }, {\n            key: \"updateField\",\n            value: function updateField(field) {\n              this.field = field;\n              this.previousField = field;\n              this.fieldError = undefined;\n              this.updateDom();\n            }\n            /**\n             * Update the HTML DOM, optionally recursing through the childs\n             * @param {Object} [options] Available parameters:\n             *                          {boolean} [recurse]         If true, the\n             *                          DOM of the childs will be updated recursively.\n             *                          False by default.\n             *                          {boolean} [updateIndexes]   If true, the childs\n             *                          indexes of the node will be updated too. False by\n             *                          default.\n             */\n\n          }, {\n            key: \"updateDom\",\n            value: function updateDom(options) {\n              // update level indentation\n              var domTree = this.dom.tree;\n\n              if (domTree) {\n                domTree.style.marginLeft = this.getLevel() * 24 + 'px';\n              } // apply field to DOM\n\n\n              var domField = this.dom.field;\n\n              if (domField) {\n                if (this.fieldEditable) {\n                  // parent is an object\n                  domField.contentEditable = this.editable.field;\n                  domField.spellcheck = false;\n                  domField.className = 'jsoneditor-field';\n                } else {\n                  // parent is an array this is the root node\n                  domField.contentEditable = false;\n                  domField.className = 'jsoneditor-readonly';\n                }\n\n                var fieldText;\n\n                if (this.index !== undefined) {\n                  fieldText = this.index;\n                } else if (this.field !== undefined) {\n                  fieldText = this.field;\n                } else {\n                  var schema = this.editor.options.schema ? Node._findSchema(this.editor.options.schema, this.editor.options.schemaRefs || {}, this.getPath()) : undefined;\n\n                  if (schema && schema.title) {\n                    fieldText = schema.title;\n                  } else if (this._hasChilds()) {\n                    fieldText = this.type;\n                  } else {\n                    fieldText = '';\n                  }\n                }\n\n                domField.innerHTML = this._escapeHTML(fieldText);\n\n                this._updateSchema();\n              } // apply value to DOM\n\n\n              var domValue = this.dom.value;\n\n              if (domValue) {\n                if (this.type === 'array') {\n                  this.updateNodeName();\n                  Object(util[\"addClassName\"])(this.dom.tr, 'jsoneditor-expandable');\n                } else if (this.type === 'object') {\n                  this.updateNodeName();\n                  Object(util[\"addClassName\"])(this.dom.tr, 'jsoneditor-expandable');\n                } else {\n                  domValue.innerHTML = this._escapeHTML(this.value);\n                  Object(util[\"removeClassName\"])(this.dom.tr, 'jsoneditor-expandable');\n                }\n              } // update field and value\n\n\n              this._updateDomField();\n\n              this._updateDomValue();\n\n              this._updateCssClassName(); // update childs indexes\n\n\n              if (options && options.updateIndexes === true) {\n                // updateIndexes is true or undefined\n                this._updateDomIndexes();\n              } // update childs recursively\n\n\n              if (options && options.recurse === true) {\n                if (this.childs) {\n                  this.childs.forEach(function (child) {\n                    child.updateDom(options);\n                  });\n                }\n              } // update rendering of error\n\n\n              if (this.error) {\n                this.updateError();\n              } // update row with append button\n\n\n              if (this.append) {\n                this.append.updateDom();\n              } // update \"show more\" text at the bottom of large arrays\n\n\n              if (this.showMore) {\n                this.showMore.updateDom();\n              }\n            }\n            /**\n             * Locate the JSON schema of the node and check for any enum type\n             * @private\n             */\n\n          }, {\n            key: \"_updateSchema\",\n            value: function _updateSchema() {\n              // Locating the schema of the node and checking for any enum type\n              if (this.editor && this.editor.options) {\n                // find the part of the json schema matching this nodes path\n                this.schema = this.editor.options.schema // fix childSchema with $ref, and not display the select element on the child schema because of not found enum\n                ? Node._findSchema(this.editor.options.schema, this.editor.options.schemaRefs || {}, this.getPath()) : null;\n\n                if (this.schema) {\n                  this[\"enum\"] = Node._findEnum(this.schema);\n                } else {\n                  delete this[\"enum\"];\n                }\n              }\n            }\n            /**\n             * Update the DOM of the childs of a node: update indexes and undefined field\n             * names.\n             * Only applicable when structure is an array or object\n             * @private\n             */\n\n          }, {\n            key: \"_updateDomIndexes\",\n            value: function _updateDomIndexes() {\n              var domValue = this.dom.value;\n              var childs = this.childs;\n\n              if (domValue && childs) {\n                if (this.type === 'array') {\n                  childs.forEach(function (child, index) {\n                    child.index = index;\n                    var childField = child.dom.field;\n\n                    if (childField) {\n                      childField.innerHTML = index;\n                    }\n                  });\n                } else if (this.type === 'object') {\n                  childs.forEach(function (child) {\n                    if (child.index !== undefined) {\n                      delete child.index;\n\n                      if (child.field === undefined) {\n                        child.field = '';\n                      }\n                    }\n                  });\n                }\n              }\n            }\n            /**\n             * Create an editable value\n             * @private\n             */\n\n          }, {\n            key: \"_createDomValue\",\n            value: function _createDomValue() {\n              var domValue;\n\n              if (this.type === 'array') {\n                domValue = document.createElement('div');\n                domValue.innerHTML = '[...]';\n              } else if (this.type === 'object') {\n                domValue = document.createElement('div');\n                domValue.innerHTML = '{...}';\n              } else {\n                if (!this.editable.value && Object(util[\"isUrl\"])(this.value)) {\n                  // create a link in case of read-only editor and value containing an url\n                  domValue = document.createElement('a');\n                  domValue.href = this.value;\n                  domValue.innerHTML = this._escapeHTML(this.value);\n                } else {\n                  // create an editable or read-only div\n                  domValue = document.createElement('div');\n                  domValue.contentEditable = this.editable.value;\n                  domValue.spellcheck = false;\n                  domValue.innerHTML = this._escapeHTML(this.value);\n                }\n              }\n\n              return domValue;\n            }\n            /**\n             * Create an expand/collapse button\n             * @return {Element} expand\n             * @private\n             */\n\n          }, {\n            key: \"_createDomExpandButton\",\n            value: function _createDomExpandButton() {\n              // create expand button\n              var expand = document.createElement('button');\n              expand.type = 'button';\n\n              if (this._hasChilds()) {\n                expand.className = this.expanded ? 'jsoneditor-button jsoneditor-expanded' : 'jsoneditor-button jsoneditor-collapsed';\n                expand.title = Object(i18n[\"c\"\n                /* translate */\n                ])('expandTitle');\n              } else {\n                expand.className = 'jsoneditor-button jsoneditor-invisible';\n                expand.title = '';\n              }\n\n              return expand;\n            }\n            /**\n             * Create a DOM tree element, containing the expand/collapse button\n             * @return {Element} domTree\n             * @private\n             */\n\n          }, {\n            key: \"_createDomTree\",\n            value: function _createDomTree() {\n              var dom = this.dom;\n              var domTree = document.createElement('table');\n              var tbody = document.createElement('tbody');\n              domTree.style.borderCollapse = 'collapse'; // TODO: put in css\n\n              domTree.className = 'jsoneditor-values';\n              domTree.appendChild(tbody);\n              var tr = document.createElement('tr');\n              tbody.appendChild(tr); // create expand button\n\n              var tdExpand = document.createElement('td');\n              tdExpand.className = 'jsoneditor-tree';\n              tr.appendChild(tdExpand);\n              dom.expand = this._createDomExpandButton();\n              tdExpand.appendChild(dom.expand);\n              dom.tdExpand = tdExpand; // create the field\n\n              var tdField = document.createElement('td');\n              tdField.className = 'jsoneditor-tree';\n              tr.appendChild(tdField);\n              dom.field = this._createDomField();\n              tdField.appendChild(dom.field);\n              dom.tdField = tdField; // create a separator\n\n              var tdSeparator = document.createElement('td');\n              tdSeparator.className = 'jsoneditor-tree';\n              tr.appendChild(tdSeparator);\n\n              if (this.type !== 'object' && this.type !== 'array') {\n                tdSeparator.appendChild(document.createTextNode(':'));\n                tdSeparator.className = 'jsoneditor-separator';\n              }\n\n              dom.tdSeparator = tdSeparator; // create the value\n\n              var tdValue = document.createElement('td');\n              tdValue.className = 'jsoneditor-tree';\n              tr.appendChild(tdValue);\n              dom.value = this._createDomValue();\n              tdValue.appendChild(dom.value);\n              dom.tdValue = tdValue;\n              return domTree;\n            }\n            /**\n             * Handle an event. The event is caught centrally by the editor\n             * @param {Event} event\n             */\n\n          }, {\n            key: \"onEvent\",\n            value: function onEvent(event) {\n              var type = event.type;\n              var target = event.target || event.srcElement;\n              var dom = this.dom;\n              var node = this;\n\n              var expandable = this._hasChilds();\n\n              if (typeof this.editor.options.onEvent === 'function') {\n                this._onEvent(event);\n              } // check if mouse is on menu or on dragarea.\n              // If so, highlight current row and its childs\n\n\n              if (target === dom.drag || target === dom.menu) {\n                if (type === 'mouseover') {\n                  this.editor.highlighter.highlight(this);\n                } else if (type === 'mouseout') {\n                  this.editor.highlighter.unhighlight();\n                }\n              } // context menu events\n\n\n              if (type === 'click' && target === dom.menu) {\n                var highlighter = node.editor.highlighter;\n                highlighter.highlight(node);\n                highlighter.lock();\n                Object(util[\"addClassName\"])(dom.menu, 'jsoneditor-selected');\n                this.showContextMenu(dom.menu, function () {\n                  Object(util[\"removeClassName\"])(dom.menu, 'jsoneditor-selected');\n                  highlighter.unlock();\n                  highlighter.unhighlight();\n                });\n              } // expand events\n\n\n              if (type === 'click') {\n                if (target === dom.expand || (node.editor.options.mode === 'view' || node.editor.options.mode === 'form') && target.nodeName === 'DIV') {\n                  if (expandable) {\n                    var recurse = event.ctrlKey; // with ctrl-key, expand/collapse all\n\n                    this._onExpand(recurse);\n                  }\n                }\n              }\n\n              if (type === 'click' && (event.target === node.dom.tdColor || event.target === node.dom.color)) {\n                this._showColorPicker();\n              } // swap the value of a boolean when the checkbox displayed left is clicked\n\n\n              if (type === 'change' && target === dom.checkbox) {\n                this.dom.value.innerHTML = !this.value;\n\n                this._getDomValue();\n\n                this._updateDomDefault();\n              } // update the value of the node based on the selected option\n\n\n              if (type === 'change' && target === dom.select) {\n                this.dom.value.innerHTML = dom.select.value;\n\n                this._getDomValue();\n\n                this._updateDomValue();\n              } // value events\n\n\n              var domValue = dom.value;\n\n              if (target === domValue) {\n                // noinspection FallthroughInSwitchStatementJS\n                switch (type) {\n                  case 'blur':\n                  case 'change':\n                    {\n                      this._getDomValue();\n\n                      this._clearValueError();\n\n                      this._updateDomValue();\n\n                      var escapedValue = this._escapeHTML(this.value);\n\n                      if (domValue.innerHTML !== escapedValue) {\n                        // only update if changed, else you lose the caret position when changing tabs for example\n                        domValue.innerHTML = escapedValue;\n                      }\n\n                      break;\n                    }\n\n                  case 'input':\n                    // this._debouncedGetDomValue(true); // TODO\n                    this._getDomValue();\n\n                    this._updateDomValue();\n\n                    break;\n\n                  case 'keydown':\n                  case 'mousedown':\n                    // TODO: cleanup\n                    this.editor.selection = this.editor.getDomSelection();\n                    break;\n\n                  case 'click':\n                    if (event.ctrlKey && this.editable.value) {\n                      // if read-only, we use the regular click behavior of an anchor\n                      if (Object(util[\"isUrl\"])(this.value)) {\n                        event.preventDefault();\n                        window.open(this.value, '_blank');\n                      }\n                    }\n\n                    break;\n\n                  case 'keyup':\n                    // this._debouncedGetDomValue(true); // TODO\n                    this._getDomValue();\n\n                    this._updateDomValue();\n\n                    break;\n\n                  case 'cut':\n                  case 'paste':\n                    setTimeout(function () {\n                      node._getDomValue();\n\n                      node._updateDomValue();\n                    }, 1);\n                    break;\n                }\n              } // field events\n\n\n              var domField = dom.field;\n\n              if (target === domField) {\n                switch (type) {\n                  case 'blur':\n                    {\n                      this._getDomField(true);\n\n                      this._updateDomField();\n\n                      var escapedField = this._escapeHTML(this.field);\n\n                      if (domField.innerHTML !== escapedField) {\n                        // only update if changed, else you lose the caret position when changing tabs for example\n                        domField.innerHTML = escapedField;\n                      }\n\n                      break;\n                    }\n\n                  case 'input':\n                    this._getDomField();\n\n                    this._updateSchema();\n\n                    this._updateDomField();\n\n                    this._updateDomValue();\n\n                    break;\n\n                  case 'keydown':\n                  case 'mousedown':\n                    this.editor.selection = this.editor.getDomSelection();\n                    break;\n\n                  case 'keyup':\n                    this._getDomField();\n\n                    this._updateDomField();\n\n                    break;\n\n                  case 'cut':\n                  case 'paste':\n                    setTimeout(function () {\n                      node._getDomField();\n\n                      node._updateDomField();\n                    }, 1);\n                    break;\n                }\n              } // focus\n              // when clicked in whitespace left or right from the field or value, set focus\n\n\n              var domTree = dom.tree;\n\n              if (domTree && target === domTree.parentNode && type === 'click' && !event.hasMoved) {\n                var left = event.offsetX !== undefined ? event.offsetX < (this.getLevel() + 1) * 24 : event.pageX < Object(util[\"getAbsoluteLeft\"])(dom.tdSeparator); // for FF\n\n                if (left || expandable) {\n                  // node is expandable when it is an object or array\n                  if (domField) {\n                    Object(util[\"setEndOfContentEditable\"])(domField);\n                    domField.focus();\n                  }\n                } else {\n                  if (domValue && !this[\"enum\"]) {\n                    Object(util[\"setEndOfContentEditable\"])(domValue);\n                    domValue.focus();\n                  }\n                }\n              }\n\n              if ((target === dom.tdExpand && !expandable || target === dom.tdField || target === dom.tdSeparator) && type === 'click' && !event.hasMoved) {\n                if (domField) {\n                  Object(util[\"setEndOfContentEditable\"])(domField);\n                  domField.focus();\n                }\n              }\n\n              if (type === 'keydown') {\n                this.onKeyDown(event);\n              }\n            }\n            /**\n             * Trigger external onEvent provided in options if node is a JSON field or\n             * value.\n             * Information provided depends on the element, value is only included if\n             * event occurs in a JSON value:\n             * {field: string, path: {string|number}[] [, value: string]}\n             * @param {Event} event\n             * @private\n             */\n\n          }, {\n            key: \"_onEvent\",\n            value: function _onEvent(event) {\n              var element = event.target;\n\n              if (element === this.dom.field || element === this.dom.value) {\n                var info = {\n                  field: this.getField(),\n                  path: this.getPath()\n                }; // For leaf values, include value\n\n                if (!this._hasChilds() && element === this.dom.value) {\n                  info.value = this.getValue();\n                }\n\n                this.editor.options.onEvent(info, event);\n              }\n            }\n            /**\n             * Key down event handler\n             * @param {Event} event\n             */\n\n          }, {\n            key: \"onKeyDown\",\n            value: function onKeyDown(event) {\n              var keynum = event.which || event.keyCode;\n              var target = event.target || event.srcElement;\n              var ctrlKey = event.ctrlKey;\n              var shiftKey = event.shiftKey;\n              var altKey = event.altKey;\n              var handled = false;\n              var prevNode, nextNode, nextDom, nextDom2;\n              var editable = this.editor.options.mode === 'tree';\n              var oldSelection;\n              var oldNextNode;\n              var oldParent;\n              var oldIndexRedo;\n              var newIndexRedo;\n              var oldParentPathRedo;\n              var newParentPathRedo;\n              var nodes;\n              var multiselection;\n              var selectedNodes = this.editor.multiselection.nodes.length > 0 ? this.editor.multiselection.nodes : [this];\n              var firstNode = selectedNodes[0];\n              var lastNode = selectedNodes[selectedNodes.length - 1]; // console.log(ctrlKey, keynum, event.charCode); // TODO: cleanup\n\n              if (keynum === 13) {\n                // Enter\n                if (target === this.dom.value) {\n                  if (!this.editable.value || event.ctrlKey) {\n                    if (Object(util[\"isUrl\"])(this.value)) {\n                      window.open(this.value, '_blank');\n                      handled = true;\n                    }\n                  }\n                } else if (target === this.dom.expand) {\n                  var expandable = this._hasChilds();\n\n                  if (expandable) {\n                    var recurse = event.ctrlKey; // with ctrl-key, expand/collapse all\n\n                    this._onExpand(recurse);\n\n                    target.focus();\n                    handled = true;\n                  }\n                }\n              } else if (keynum === 68) {\n                // D\n                if (ctrlKey && editable) {\n                  // Ctrl+D\n                  Node.onDuplicate(selectedNodes);\n                  handled = true;\n                }\n              } else if (keynum === 69) {\n                // E\n                if (ctrlKey) {\n                  // Ctrl+E and Ctrl+Shift+E\n                  this._onExpand(shiftKey); // recurse = shiftKey\n\n\n                  target.focus(); // TODO: should restore focus in case of recursing expand (which takes DOM offline)\n\n                  handled = true;\n                }\n              } else if (keynum === 77 && editable) {\n                // M\n                if (ctrlKey) {\n                  // Ctrl+M\n                  this.showContextMenu(target);\n                  handled = true;\n                }\n              } else if (keynum === 46 && editable) {\n                // Del\n                if (ctrlKey) {\n                  // Ctrl+Del\n                  Node.onRemove(selectedNodes);\n                  handled = true;\n                }\n              } else if (keynum === 45 && editable) {\n                // Ins\n                if (ctrlKey && !shiftKey) {\n                  // Ctrl+Ins\n                  this._onInsertBefore();\n\n                  handled = true;\n                } else if (ctrlKey && shiftKey) {\n                  // Ctrl+Shift+Ins\n                  this._onInsertAfter();\n\n                  handled = true;\n                }\n              } else if (keynum === 35) {\n                // End\n                if (altKey) {\n                  // Alt+End\n                  // find the last node\n                  var endNode = this._lastNode();\n\n                  if (endNode) {\n                    endNode.focus(Node.focusElement || this._getElementName(target));\n                  }\n\n                  handled = true;\n                }\n              } else if (keynum === 36) {\n                // Home\n                if (altKey) {\n                  // Alt+Home\n                  // find the first node\n                  var homeNode = this._firstNode();\n\n                  if (homeNode) {\n                    homeNode.focus(Node.focusElement || this._getElementName(target));\n                  }\n\n                  handled = true;\n                }\n              } else if (keynum === 37) {\n                // Arrow Left\n                if (altKey && !shiftKey) {\n                  // Alt + Arrow Left\n                  // move to left element\n                  var prevElement = this._previousElement(target);\n\n                  if (prevElement) {\n                    this.focus(this._getElementName(prevElement));\n                  }\n\n                  handled = true;\n                } else if (altKey && shiftKey && editable) {\n                  // Alt + Shift + Arrow left\n                  if (lastNode.expanded) {\n                    var appendDom = lastNode.getAppendDom();\n                    nextDom = appendDom ? appendDom.nextSibling : undefined;\n                  } else {\n                    var dom = lastNode.getDom();\n                    nextDom = dom.nextSibling;\n                  }\n\n                  if (nextDom) {\n                    nextNode = Node.getNodeFromTarget(nextDom);\n                    nextDom2 = nextDom.nextSibling;\n                    var nextNode2 = Node.getNodeFromTarget(nextDom2);\n\n                    if (nextNode && nextNode instanceof Node_AppendNode && !(lastNode.parent.childs.length === 1) && nextNode2 && nextNode2.parent) {\n                      oldSelection = this.editor.getDomSelection();\n                      oldParent = firstNode.parent;\n                      oldNextNode = oldParent.childs[lastNode.getIndex() + 1] || oldParent.append;\n                      oldIndexRedo = firstNode.getIndex();\n                      newIndexRedo = nextNode2.getIndex();\n                      oldParentPathRedo = oldParent.getInternalPath();\n                      newParentPathRedo = nextNode2.parent.getInternalPath();\n                      selectedNodes.forEach(function (node) {\n                        nextNode2.parent.moveBefore(node, nextNode2);\n                      });\n                      this.focus(Node.focusElement || this._getElementName(target));\n\n                      this.editor._onAction('moveNodes', {\n                        count: selectedNodes.length,\n                        fieldNames: selectedNodes.map(getField),\n                        oldParentPath: oldParent.getInternalPath(),\n                        newParentPath: firstNode.parent.getInternalPath(),\n                        oldIndex: oldNextNode.getIndex(),\n                        newIndex: firstNode.getIndex(),\n                        oldIndexRedo: oldIndexRedo,\n                        newIndexRedo: newIndexRedo,\n                        oldParentPathRedo: oldParentPathRedo,\n                        newParentPathRedo: newParentPathRedo,\n                        oldSelection: oldSelection,\n                        newSelection: this.editor.getDomSelection()\n                      });\n                    }\n                  }\n                }\n              } else if (keynum === 38) {\n                // Arrow Up\n                if (altKey && !shiftKey) {\n                  // Alt + Arrow Up\n                  // find the previous node\n                  prevNode = this._previousNode();\n\n                  if (prevNode) {\n                    this.editor.deselect(true);\n                    prevNode.focus(Node.focusElement || this._getElementName(target));\n                  }\n\n                  handled = true;\n                } else if (!altKey && ctrlKey && shiftKey && editable) {\n                  // Ctrl + Shift + Arrow Up\n                  // select multiple nodes\n                  prevNode = this._previousNode();\n\n                  if (prevNode) {\n                    multiselection = this.editor.multiselection;\n                    multiselection.start = multiselection.start || this;\n                    multiselection.end = prevNode;\n                    nodes = this.editor._findTopLevelNodes(multiselection.start, multiselection.end);\n                    this.editor.select(nodes);\n                    prevNode.focus('field'); // select field as we know this always exists\n                  }\n\n                  handled = true;\n                } else if (altKey && shiftKey && editable) {\n                  // Alt + Shift + Arrow Up\n                  // find the previous node\n                  prevNode = firstNode._previousNode();\n\n                  if (prevNode && prevNode.parent) {\n                    oldSelection = this.editor.getDomSelection();\n                    oldParent = firstNode.parent;\n                    oldNextNode = oldParent.childs[lastNode.getIndex() + 1] || oldParent.append;\n                    oldIndexRedo = firstNode.getIndex();\n                    newIndexRedo = prevNode.getIndex();\n                    oldParentPathRedo = oldParent.getInternalPath();\n                    newParentPathRedo = prevNode.parent.getInternalPath();\n                    selectedNodes.forEach(function (node) {\n                      prevNode.parent.moveBefore(node, prevNode);\n                    });\n                    this.focus(Node.focusElement || this._getElementName(target));\n\n                    this.editor._onAction('moveNodes', {\n                      count: selectedNodes.length,\n                      fieldNames: selectedNodes.map(getField),\n                      oldParentPath: oldParent.getInternalPath(),\n                      newParentPath: firstNode.parent.getInternalPath(),\n                      oldIndex: oldNextNode.getIndex(),\n                      newIndex: firstNode.getIndex(),\n                      oldIndexRedo: oldIndexRedo,\n                      newIndexRedo: newIndexRedo,\n                      oldParentPathRedo: oldParentPathRedo,\n                      newParentPathRedo: newParentPathRedo,\n                      oldSelection: oldSelection,\n                      newSelection: this.editor.getDomSelection()\n                    });\n                  }\n\n                  handled = true;\n                }\n              } else if (keynum === 39) {\n                // Arrow Right\n                if (altKey && !shiftKey) {\n                  // Alt + Arrow Right\n                  // move to right element\n                  var nextElement = this._nextElement(target);\n\n                  if (nextElement) {\n                    this.focus(this._getElementName(nextElement));\n                  }\n\n                  handled = true;\n                } else if (altKey && shiftKey && editable) {\n                  // Alt + Shift + Arrow Right\n                  dom = firstNode.getDom();\n                  var prevDom = dom.previousSibling;\n\n                  if (prevDom) {\n                    prevNode = Node.getNodeFromTarget(prevDom);\n\n                    if (prevNode && prevNode.parent && !prevNode.isVisible()) {\n                      oldSelection = this.editor.getDomSelection();\n                      oldParent = firstNode.parent;\n                      oldNextNode = oldParent.childs[lastNode.getIndex() + 1] || oldParent.append;\n                      oldIndexRedo = firstNode.getIndex();\n                      newIndexRedo = prevNode.getIndex();\n                      oldParentPathRedo = oldParent.getInternalPath();\n                      newParentPathRedo = prevNode.parent.getInternalPath();\n                      selectedNodes.forEach(function (node) {\n                        prevNode.parent.moveBefore(node, prevNode);\n                      });\n                      this.focus(Node.focusElement || this._getElementName(target));\n\n                      this.editor._onAction('moveNodes', {\n                        count: selectedNodes.length,\n                        fieldNames: selectedNodes.map(getField),\n                        oldParentPath: oldParent.getInternalPath(),\n                        newParentPath: firstNode.parent.getInternalPath(),\n                        oldIndex: oldNextNode.getIndex(),\n                        newIndex: firstNode.getIndex(),\n                        oldIndexRedo: oldIndexRedo,\n                        newIndexRedo: newIndexRedo,\n                        oldParentPathRedo: oldParentPathRedo,\n                        newParentPathRedo: newParentPathRedo,\n                        oldSelection: oldSelection,\n                        newSelection: this.editor.getDomSelection()\n                      });\n                    }\n                  }\n                }\n              } else if (keynum === 40) {\n                // Arrow Down\n                if (altKey && !shiftKey) {\n                  // Alt + Arrow Down\n                  // find the next node\n                  nextNode = this._nextNode();\n\n                  if (nextNode) {\n                    this.editor.deselect(true);\n                    nextNode.focus(Node.focusElement || this._getElementName(target));\n                  }\n\n                  handled = true;\n                } else if (!altKey && ctrlKey && shiftKey && editable) {\n                  // Ctrl + Shift + Arrow Down\n                  // select multiple nodes\n                  nextNode = this._nextNode();\n\n                  if (nextNode) {\n                    multiselection = this.editor.multiselection;\n                    multiselection.start = multiselection.start || this;\n                    multiselection.end = nextNode;\n                    nodes = this.editor._findTopLevelNodes(multiselection.start, multiselection.end);\n                    this.editor.select(nodes);\n                    nextNode.focus('field'); // select field as we know this always exists\n                  }\n\n                  handled = true;\n                } else if (altKey && shiftKey && editable) {\n                  // Alt + Shift + Arrow Down\n                  // find the 2nd next node and move before that one\n                  if (lastNode.expanded) {\n                    nextNode = lastNode.append ? lastNode.append._nextNode() : undefined;\n                  } else {\n                    nextNode = lastNode._nextNode();\n                  } // when the next node is not visible, we've reached the \"showMore\" buttons\n\n\n                  if (nextNode && !nextNode.isVisible()) {\n                    nextNode = nextNode.parent.showMore;\n                  }\n\n                  if (nextNode && nextNode instanceof Node_AppendNode) {\n                    nextNode = lastNode;\n                  }\n\n                  var _nextNode2 = nextNode && (nextNode._nextNode() || nextNode.parent.append);\n\n                  if (_nextNode2 && _nextNode2.parent) {\n                    oldSelection = this.editor.getDomSelection();\n                    oldParent = firstNode.parent;\n                    oldNextNode = oldParent.childs[lastNode.getIndex() + 1] || oldParent.append;\n                    oldIndexRedo = firstNode.getIndex();\n                    newIndexRedo = _nextNode2.getIndex();\n                    oldParentPathRedo = oldParent.getInternalPath();\n                    newParentPathRedo = _nextNode2.parent.getInternalPath();\n                    selectedNodes.forEach(function (node) {\n                      _nextNode2.parent.moveBefore(node, _nextNode2);\n                    });\n                    this.focus(Node.focusElement || this._getElementName(target));\n\n                    this.editor._onAction('moveNodes', {\n                      count: selectedNodes.length,\n                      fieldNames: selectedNodes.map(getField),\n                      oldParentPath: oldParent.getInternalPath(),\n                      newParentPath: firstNode.parent.getInternalPath(),\n                      oldParentPathRedo: oldParentPathRedo,\n                      newParentPathRedo: newParentPathRedo,\n                      oldIndexRedo: oldIndexRedo,\n                      newIndexRedo: newIndexRedo,\n                      oldIndex: oldNextNode.getIndex(),\n                      newIndex: firstNode.getIndex(),\n                      oldSelection: oldSelection,\n                      newSelection: this.editor.getDomSelection()\n                    });\n                  }\n\n                  handled = true;\n                }\n              }\n\n              if (handled) {\n                event.preventDefault();\n                event.stopPropagation();\n              }\n            }\n            /**\n             * Handle the expand event, when clicked on the expand button\n             * @param {boolean} recurse   If true, child nodes will be expanded too\n             * @private\n             */\n\n          }, {\n            key: \"_onExpand\",\n            value: function _onExpand(recurse) {\n              if (recurse) {\n                // Take the table offline\n                var table = this.dom.tr.parentNode; // TODO: not nice to access the main table like this\n\n                var frame = table.parentNode;\n                var scrollTop = frame.scrollTop;\n                frame.removeChild(table);\n              }\n\n              if (this.expanded) {\n                this.collapse(recurse);\n              } else {\n                this.expand(recurse);\n              }\n\n              if (recurse) {\n                // Put the table online again\n                frame.appendChild(table);\n                frame.scrollTop = scrollTop;\n              }\n            }\n            /**\n             * Open a color picker to select a new color\n             * @private\n             */\n\n          }, {\n            key: \"_showColorPicker\",\n            value: function _showColorPicker() {\n              if (typeof this.editor.options.onColorPicker === 'function' && this.dom.color) {\n                var node = this; // force deleting current color picker (if any)\n\n                node._deleteDomColor();\n\n                node.updateDom();\n                var colorAnchor = Object(createAbsoluteAnchor[\"a\"\n                /* createAbsoluteAnchor */\n                ])(this.dom.color, this.editor.frame);\n                this.editor.options.onColorPicker(colorAnchor, this.value, function onChange(value) {\n                  if (typeof value === 'string' && value !== node.value) {\n                    // force recreating the color block, to cleanup any attached color picker\n                    node._deleteDomColor();\n\n                    node.value = value;\n                    node.updateDom();\n\n                    node._debouncedOnChangeValue();\n                  }\n                });\n              }\n            }\n            /**\n             * Get all field names of an object\n             * @param {Node} [excludeNode] Optional node to be excluded from the returned field names\n             * @return {string[]}\n             */\n\n          }, {\n            key: \"getFieldNames\",\n            value: function getFieldNames(excludeNode) {\n              if (this.type === 'object') {\n                return this.childs.filter(function (child) {\n                  return child !== excludeNode;\n                }).map(function (child) {\n                  return child.field;\n                });\n              }\n\n              return [];\n            }\n            /**\n             * Handle insert before event\n             * @param {String} [field]\n             * @param {*} [value]\n             * @param {String} [type]   Can be 'auto', 'array', 'object', or 'string'\n             * @private\n             */\n\n          }, {\n            key: \"_onInsertBefore\",\n            value: function _onInsertBefore(field, value, type) {\n              var oldSelection = this.editor.getDomSelection();\n              var newNode = new Node(this.editor, {\n                field: field !== undefined ? field : '',\n                value: value !== undefined ? value : '',\n                type: type\n              });\n              newNode.expand(true);\n              var beforePath = this.getInternalPath();\n              this.parent.insertBefore(newNode, this);\n              this.editor.highlighter.unhighlight();\n              newNode.focus('field');\n              var newSelection = this.editor.getDomSelection();\n\n              this.editor._onAction('insertBeforeNodes', {\n                nodes: [newNode],\n                paths: [newNode.getInternalPath()],\n                beforePath: beforePath,\n                parentPath: this.parent.getInternalPath(),\n                oldSelection: oldSelection,\n                newSelection: newSelection\n              });\n            }\n            /**\n             * Handle insert after event\n             * @param {String} [field]\n             * @param {*} [value]\n             * @param {String} [type]   Can be 'auto', 'array', 'object', or 'string'\n             * @private\n             */\n\n          }, {\n            key: \"_onInsertAfter\",\n            value: function _onInsertAfter(field, value, type) {\n              var oldSelection = this.editor.getDomSelection();\n              var newNode = new Node(this.editor, {\n                field: field !== undefined ? field : '',\n                value: value !== undefined ? value : '',\n                type: type\n              });\n              newNode.expand(true);\n              this.parent.insertAfter(newNode, this);\n              this.editor.highlighter.unhighlight();\n              newNode.focus('field');\n              var newSelection = this.editor.getDomSelection();\n\n              this.editor._onAction('insertAfterNodes', {\n                nodes: [newNode],\n                paths: [newNode.getInternalPath()],\n                afterPath: this.getInternalPath(),\n                parentPath: this.parent.getInternalPath(),\n                oldSelection: oldSelection,\n                newSelection: newSelection\n              });\n            }\n            /**\n             * Handle append event\n             * @param {String} [field]\n             * @param {*} [value]\n             * @param {String} [type]   Can be 'auto', 'array', 'object', or 'string'\n             * @private\n             */\n\n          }, {\n            key: \"_onAppend\",\n            value: function _onAppend(field, value, type) {\n              var oldSelection = this.editor.getDomSelection();\n              var newNode = new Node(this.editor, {\n                field: field !== undefined ? field : '',\n                value: value !== undefined ? value : '',\n                type: type\n              });\n              newNode.expand(true);\n              this.parent.appendChild(newNode);\n              this.editor.highlighter.unhighlight();\n              newNode.focus('field');\n              var newSelection = this.editor.getDomSelection();\n\n              this.editor._onAction('appendNodes', {\n                nodes: [newNode],\n                paths: [newNode.getInternalPath()],\n                parentPath: this.parent.getInternalPath(),\n                oldSelection: oldSelection,\n                newSelection: newSelection\n              });\n            }\n            /**\n             * Change the type of the node's value\n             * @param {String} newType\n             * @private\n             */\n\n          }, {\n            key: \"_onChangeType\",\n            value: function _onChangeType(newType) {\n              var oldType = this.type;\n\n              if (newType !== oldType) {\n                var oldSelection = this.editor.getDomSelection();\n                this.changeType(newType);\n                var newSelection = this.editor.getDomSelection();\n\n                this.editor._onAction('changeType', {\n                  path: this.getInternalPath(),\n                  oldType: oldType,\n                  newType: newType,\n                  oldSelection: oldSelection,\n                  newSelection: newSelection\n                });\n              }\n            }\n            /**\n             * Sort the child's of the node. Only applicable when the node has type 'object'\n             * or 'array'.\n             * @param {String[] | string} path  Path of the child value to be compared\n             * @param {String} direction        Sorting direction. Available values: \"asc\", \"desc\"\n             * @private\n             */\n\n          }, {\n            key: \"sort\",\n            value: function sort(path, direction) {\n              if (typeof path === 'string') {\n                path = Object(util[\"parsePath\"])(path);\n              }\n\n              if (!this._hasChilds()) {\n                return;\n              }\n\n              this.hideChilds(); // sorting is faster when the childs are not attached to the dom\n              // copy the childs array (the old one will be kept for an undo action\n\n              var oldChilds = this.childs;\n              this.childs = this.childs.concat(); // sort the childs array\n\n              var order = direction === 'desc' ? -1 : 1;\n\n              if (this.type === 'object') {\n                this.childs.sort(function (a, b) {\n                  return order * naturalSort_default()(a.field, b.field);\n                });\n              } else {\n                // this.type === 'array'\n                this.childs.sort(function (a, b) {\n                  var nodeA = a.getNestedChild(path);\n                  var nodeB = b.getNestedChild(path);\n\n                  if (!nodeA) {\n                    return order;\n                  }\n\n                  if (!nodeB) {\n                    return -order;\n                  }\n\n                  var valueA = nodeA.value;\n                  var valueB = nodeB.value;\n\n                  if (typeof valueA !== 'string' && typeof valueB !== 'string') {\n                    // both values are a number, boolean, or null -> use simple, fast sorting\n                    return valueA > valueB ? order : valueA < valueB ? -order : 0;\n                  }\n\n                  return order * naturalSort_default()(valueA, valueB);\n                });\n              } // update the index numbering\n\n\n              this._updateDomIndexes();\n\n              this.editor._onAction('sort', {\n                path: this.getInternalPath(),\n                oldChilds: oldChilds,\n                newChilds: this.childs\n              });\n\n              this.showChilds();\n            }\n            /**\n             * Replace the value of the node, keep it's state\n             * @param {*} newValue\n             */\n\n          }, {\n            key: \"update\",\n            value: function update(newValue) {\n              var oldValue = this.getInternalValue();\n              this.setValue(newValue);\n\n              this.editor._onAction('transform', {\n                path: this.getInternalPath(),\n                oldValue: oldValue,\n                newValue: this.getInternalValue()\n              });\n            }\n            /**\n             * Remove this node from the DOM\n             * @returns {{table: Element, nextTr?: Element}}\n             *            Returns the DOM elements that which be used to attach the node\n             *            to the DOM again, see _attachToDom.\n             * @private\n             */\n\n          }, {\n            key: \"_detachFromDom\",\n            value: function _detachFromDom() {\n              var table = this.dom.tr ? this.dom.tr.parentNode : undefined;\n              var lastTr;\n\n              if (this.expanded) {\n                lastTr = this.getAppendDom();\n              } else {\n                lastTr = this.getDom();\n              }\n\n              var nextTr = lastTr && lastTr.parentNode ? lastTr.nextSibling : undefined;\n              this.hide({\n                resetVisibleChilds: false\n              });\n              return {\n                table: table,\n                nextTr: nextTr\n              };\n            }\n            /**\n             * Attach this node to the DOM again\n             * @param {{table: Element, nextTr?: Element}} domAnchor\n             *            The DOM elements returned by _detachFromDom.\n             * @private\n             */\n\n          }, {\n            key: \"_attachToDom\",\n            value: function _attachToDom(domAnchor) {\n              if (domAnchor.table) {\n                if (domAnchor.nextTr) {\n                  domAnchor.table.insertBefore(this.getDom(), domAnchor.nextTr);\n                } else {\n                  domAnchor.table.appendChild(this.getDom());\n                }\n              }\n\n              if (this.expanded) {\n                this.showChilds();\n              }\n            }\n            /**\n             * Transform the node given a JMESPath query.\n             * @param {String} query    JMESPath query to apply\n             * @private\n             */\n\n          }, {\n            key: \"transform\",\n            value: function transform(query) {\n              if (!this._hasChilds()) {\n                return;\n              }\n\n              this.hideChilds(); // sorting is faster when the childs are not attached to the dom\n\n              try {\n                var oldInternalValue = this.getInternalValue(); // apply the JMESPath query\n\n                var oldValue = this.getValue();\n                var newValue = jmespath_default.a.search(oldValue, query);\n                this.setValue(newValue);\n                var newInternalValue = this.getInternalValue();\n\n                this.editor._onAction('transform', {\n                  path: this.getInternalPath(),\n                  oldValue: oldInternalValue,\n                  newValue: newInternalValue\n                });\n\n                this.showChilds();\n              } catch (err) {\n                this.showChilds();\n\n                this.editor._onError(err);\n              }\n            }\n            /**\n             * Make this object the root object of the ditor\n             */\n\n          }, {\n            key: \"extract\",\n            value: function extract() {\n              this.editor.node.hideChilds();\n              this.hideChilds();\n\n              try {\n                var oldInternalValue = this.editor.node.getInternalValue();\n\n                this.editor._setRoot(this);\n\n                var newInternalValue = this.editor.node.getInternalValue();\n\n                this.editor._onAction('transform', {\n                  path: this.editor.node.getInternalPath(),\n                  oldValue: oldInternalValue,\n                  newValue: newInternalValue\n                });\n              } catch (err) {\n                this.editor._onError(err);\n              } finally {\n                this.updateDom({\n                  recurse: true\n                });\n                this.showChilds();\n              }\n            }\n            /**\n             * Get a nested child given a path with properties\n             * @param {String[]} path\n             * @returns {Node}\n             */\n\n          }, {\n            key: \"getNestedChild\",\n            value: function getNestedChild(path) {\n              var i = 0;\n              var child = this;\n\n              while (child && i < path.length) {\n                child = child.findChildByProperty(path[i]);\n                i++;\n              }\n\n              return child;\n            }\n            /**\n             * Find a child by property name\n             * @param {string} prop\n             * @return {Node | undefined} Returns the child node when found, or undefined otherwise\n             */\n\n          }, {\n            key: \"findChildByProperty\",\n            value: function findChildByProperty(prop) {\n              if (this.type !== 'object') {\n                return undefined;\n              }\n\n              return this.childs.find(function (child) {\n                return child.field === prop;\n              });\n            }\n            /**\n             * Create a table row with an append button.\n             * @return {HTMLElement | undefined} tr with the AppendNode contents\n             */\n\n          }, {\n            key: \"getAppendDom\",\n            value: function getAppendDom() {\n              if (!this.append) {\n                this.append = new Node_AppendNode(this.editor);\n                this.append.setParent(this);\n              }\n\n              return this.append.getDom();\n            }\n            /**\n             * Create a table row with an showMore button and text\n             * @return {HTMLElement | undefined} tr with the AppendNode contents\n             */\n\n          }, {\n            key: \"getShowMoreDom\",\n            value: function getShowMoreDom() {\n              if (!this.showMore) {\n                this.showMore = new Node_ShowMoreNode(this.editor, this);\n              }\n\n              return this.showMore.getDom();\n            }\n            /**\n             * Get the next sibling of current node\n             * @return {Node} nextSibling\n             */\n\n          }, {\n            key: \"nextSibling\",\n            value: function nextSibling() {\n              var index = this.parent.childs.indexOf(this);\n              return this.parent.childs[index + 1] || this.parent.append;\n            }\n            /**\n             * Get the previously rendered node\n             * @return {Node | null} previousNode\n             */\n\n          }, {\n            key: \"_previousNode\",\n            value: function _previousNode() {\n              var prevNode = null;\n              var dom = this.getDom();\n\n              if (dom && dom.parentNode) {\n                // find the previous field\n                var prevDom = dom;\n\n                do {\n                  prevDom = prevDom.previousSibling;\n                  prevNode = Node.getNodeFromTarget(prevDom);\n                } while (prevDom && prevNode && prevNode instanceof Node_AppendNode && !prevNode.isVisible());\n              }\n\n              return prevNode;\n            }\n            /**\n             * Get the next rendered node\n             * @return {Node | null} nextNode\n             * @private\n             */\n\n          }, {\n            key: \"_nextNode\",\n            value: function _nextNode() {\n              var nextNode = null;\n              var dom = this.getDom();\n\n              if (dom && dom.parentNode) {\n                // find the previous field\n                var nextDom = dom;\n\n                do {\n                  nextDom = nextDom.nextSibling;\n                  nextNode = Node.getNodeFromTarget(nextDom);\n                } while (nextDom && nextNode && nextNode instanceof Node_AppendNode && !nextNode.isVisible());\n              }\n\n              return nextNode;\n            }\n            /**\n             * Get the first rendered node\n             * @return {Node | null} firstNode\n             * @private\n             */\n\n          }, {\n            key: \"_firstNode\",\n            value: function _firstNode() {\n              var firstNode = null;\n              var dom = this.getDom();\n\n              if (dom && dom.parentNode) {\n                var firstDom = dom.parentNode.firstChild;\n                firstNode = Node.getNodeFromTarget(firstDom);\n              }\n\n              return firstNode;\n            }\n            /**\n             * Get the last rendered node\n             * @return {Node | null} lastNode\n             * @private\n             */\n\n          }, {\n            key: \"_lastNode\",\n            value: function _lastNode() {\n              var lastNode = null;\n              var dom = this.getDom();\n\n              if (dom && dom.parentNode) {\n                var lastDom = dom.parentNode.lastChild;\n                lastNode = Node.getNodeFromTarget(lastDom);\n\n                while (lastDom && lastNode && !lastNode.isVisible()) {\n                  lastDom = lastDom.previousSibling;\n                  lastNode = Node.getNodeFromTarget(lastDom);\n                }\n              }\n\n              return lastNode;\n            }\n            /**\n             * Get the next element which can have focus.\n             * @param {Element} elem\n             * @return {Element | null} nextElem\n             * @private\n             */\n\n          }, {\n            key: \"_previousElement\",\n            value: function _previousElement(elem) {\n              var dom = this.dom; // noinspection FallthroughInSwitchStatementJS\n\n              switch (elem) {\n                case dom.value:\n                  if (this.fieldEditable) {\n                    return dom.field;\n                  }\n\n                // intentional fall through\n\n                case dom.field:\n                  if (this._hasChilds()) {\n                    return dom.expand;\n                  }\n\n                // intentional fall through\n\n                case dom.expand:\n                  return dom.menu;\n\n                case dom.menu:\n                  if (dom.drag) {\n                    return dom.drag;\n                  }\n\n                // intentional fall through\n\n                default:\n                  return null;\n              }\n            }\n            /**\n             * Get the next element which can have focus.\n             * @param {Element} elem\n             * @return {Element | null} nextElem\n             * @private\n             */\n\n          }, {\n            key: \"_nextElement\",\n            value: function _nextElement(elem) {\n              var dom = this.dom; // noinspection FallthroughInSwitchStatementJS\n\n              switch (elem) {\n                case dom.drag:\n                  return dom.menu;\n\n                case dom.menu:\n                  if (this._hasChilds()) {\n                    return dom.expand;\n                  }\n\n                // intentional fall through\n\n                case dom.expand:\n                  if (this.fieldEditable) {\n                    return dom.field;\n                  }\n\n                // intentional fall through\n\n                case dom.field:\n                  if (!this._hasChilds()) {\n                    return dom.value;\n                  }\n\n                // intentional fall through\n\n                default:\n                  return null;\n              }\n            }\n            /**\n             * Get the dom name of given element. returns null if not found.\n             * For example when element === dom.field, \"field\" is returned.\n             * @param {Element} element\n             * @return {String | null} elementName  Available elements with name: 'drag',\n             *                                      'menu', 'expand', 'field', 'value'\n             * @private\n             */\n\n          }, {\n            key: \"_getElementName\",\n            value: function _getElementName(element) {\n              var _this2 = this;\n\n              return Object.keys(this.dom).find(function (name) {\n                return _this2.dom[name] === element;\n              });\n            }\n            /**\n             * Test if this node has childs. This is the case when the node is an object\n             * or array.\n             * @return {boolean} hasChilds\n             * @private\n             */\n\n          }, {\n            key: \"_hasChilds\",\n            value: function _hasChilds() {\n              return this.type === 'array' || this.type === 'object';\n            }\n          }, {\n            key: \"addTemplates\",\n            value: function addTemplates(menu, append) {\n              var node = this;\n              var templates = node.editor.options.templates;\n              if (templates == null) return;\n\n              if (templates.length) {\n                // create a separator\n                menu.push({\n                  type: 'separator'\n                });\n              }\n\n              var appendData = function appendData(name, data) {\n                node._onAppend(name, data);\n              };\n\n              var insertData = function insertData(name, data) {\n                node._onInsertBefore(name, data);\n              };\n\n              templates.forEach(function (template) {\n                menu.push({\n                  text: template.text,\n                  className: template.className || 'jsoneditor-type-object',\n                  title: template.title,\n                  click: append ? appendData.bind(this, template.field, template.value) : insertData.bind(this, template.field, template.value)\n                });\n              });\n            }\n            /**\n             * Show a contextmenu for this node\n             * @param {HTMLElement} anchor   Anchor element to attach the context menu to\n             *                               as sibling.\n             * @param {function} [onClose]   Callback method called when the context menu\n             *                               is being closed.\n             */\n\n          }, {\n            key: \"showContextMenu\",\n            value: function showContextMenu(anchor, onClose) {\n              var node = this;\n              var titles = Node.TYPE_TITLES;\n              var items = [];\n\n              if (this.editable.value) {\n                items.push({\n                  text: Object(i18n[\"c\"\n                  /* translate */\n                  ])('type'),\n                  title: Object(i18n[\"c\"\n                  /* translate */\n                  ])('typeTitle'),\n                  className: 'jsoneditor-type-' + this.type,\n                  submenu: [{\n                    text: Object(i18n[\"c\"\n                    /* translate */\n                    ])('auto'),\n                    className: 'jsoneditor-type-auto' + (this.type === 'auto' ? ' jsoneditor-selected' : ''),\n                    title: titles.auto,\n                    click: function click() {\n                      node._onChangeType('auto');\n                    }\n                  }, {\n                    text: Object(i18n[\"c\"\n                    /* translate */\n                    ])('array'),\n                    className: 'jsoneditor-type-array' + (this.type === 'array' ? ' jsoneditor-selected' : ''),\n                    title: titles.array,\n                    click: function click() {\n                      node._onChangeType('array');\n                    }\n                  }, {\n                    text: Object(i18n[\"c\"\n                    /* translate */\n                    ])('object'),\n                    className: 'jsoneditor-type-object' + (this.type === 'object' ? ' jsoneditor-selected' : ''),\n                    title: titles.object,\n                    click: function click() {\n                      node._onChangeType('object');\n                    }\n                  }, {\n                    text: Object(i18n[\"c\"\n                    /* translate */\n                    ])('string'),\n                    className: 'jsoneditor-type-string' + (this.type === 'string' ? ' jsoneditor-selected' : ''),\n                    title: titles.string,\n                    click: function click() {\n                      node._onChangeType('string');\n                    }\n                  }]\n                });\n              }\n\n              if (this._hasChilds()) {\n                if (this.editor.options.enableSort) {\n                  items.push({\n                    text: Object(i18n[\"c\"\n                    /* translate */\n                    ])('sort'),\n                    title: Object(i18n[\"c\"\n                    /* translate */\n                    ])('sortTitle', {\n                      type: this.type\n                    }),\n                    className: 'jsoneditor-sort-asc',\n                    click: function click() {\n                      node.showSortModal();\n                    }\n                  });\n                }\n\n                if (this.editor.options.enableTransform) {\n                  items.push({\n                    text: Object(i18n[\"c\"\n                    /* translate */\n                    ])('transform'),\n                    title: Object(i18n[\"c\"\n                    /* translate */\n                    ])('transformTitle', {\n                      type: this.type\n                    }),\n                    className: 'jsoneditor-transform',\n                    click: function click() {\n                      node.showTransformModal();\n                    }\n                  });\n                }\n\n                if (this.parent) {\n                  items.push({\n                    text: Object(i18n[\"c\"\n                    /* translate */\n                    ])('extract'),\n                    title: Object(i18n[\"c\"\n                    /* translate */\n                    ])('extractTitle', {\n                      type: this.type\n                    }),\n                    className: 'jsoneditor-extract',\n                    click: function click() {\n                      node.extract();\n                    }\n                  });\n                }\n              }\n\n              if (this.parent && this.parent._hasChilds()) {\n                if (items.length) {\n                  // create a separator\n                  items.push({\n                    type: 'separator'\n                  });\n                } // create append button (for last child node only)\n\n\n                var childs = node.parent.childs;\n\n                if (node === childs[childs.length - 1]) {\n                  var appendSubmenu = [{\n                    text: Object(i18n[\"c\"\n                    /* translate */\n                    ])('auto'),\n                    className: 'jsoneditor-type-auto',\n                    title: titles.auto,\n                    click: function click() {\n                      node._onAppend('', '', 'auto');\n                    }\n                  }, {\n                    text: Object(i18n[\"c\"\n                    /* translate */\n                    ])('array'),\n                    className: 'jsoneditor-type-array',\n                    title: titles.array,\n                    click: function click() {\n                      node._onAppend('', []);\n                    }\n                  }, {\n                    text: Object(i18n[\"c\"\n                    /* translate */\n                    ])('object'),\n                    className: 'jsoneditor-type-object',\n                    title: titles.object,\n                    click: function click() {\n                      node._onAppend('', {});\n                    }\n                  }, {\n                    text: Object(i18n[\"c\"\n                    /* translate */\n                    ])('string'),\n                    className: 'jsoneditor-type-string',\n                    title: titles.string,\n                    click: function click() {\n                      node._onAppend('', '', 'string');\n                    }\n                  }];\n                  node.addTemplates(appendSubmenu, true);\n                  items.push({\n                    text: Object(i18n[\"c\"\n                    /* translate */\n                    ])('appendText'),\n                    title: Object(i18n[\"c\"\n                    /* translate */\n                    ])('appendTitle'),\n                    submenuTitle: Object(i18n[\"c\"\n                    /* translate */\n                    ])('appendSubmenuTitle'),\n                    className: 'jsoneditor-append',\n                    click: function click() {\n                      node._onAppend('', '', 'auto');\n                    },\n                    submenu: appendSubmenu\n                  });\n                } // create insert button\n\n\n                var insertSubmenu = [{\n                  text: Object(i18n[\"c\"\n                  /* translate */\n                  ])('auto'),\n                  className: 'jsoneditor-type-auto',\n                  title: titles.auto,\n                  click: function click() {\n                    node._onInsertBefore('', '', 'auto');\n                  }\n                }, {\n                  text: Object(i18n[\"c\"\n                  /* translate */\n                  ])('array'),\n                  className: 'jsoneditor-type-array',\n                  title: titles.array,\n                  click: function click() {\n                    node._onInsertBefore('', []);\n                  }\n                }, {\n                  text: Object(i18n[\"c\"\n                  /* translate */\n                  ])('object'),\n                  className: 'jsoneditor-type-object',\n                  title: titles.object,\n                  click: function click() {\n                    node._onInsertBefore('', {});\n                  }\n                }, {\n                  text: Object(i18n[\"c\"\n                  /* translate */\n                  ])('string'),\n                  className: 'jsoneditor-type-string',\n                  title: titles.string,\n                  click: function click() {\n                    node._onInsertBefore('', '', 'string');\n                  }\n                }];\n                node.addTemplates(insertSubmenu, false);\n                items.push({\n                  text: Object(i18n[\"c\"\n                  /* translate */\n                  ])('insert'),\n                  title: Object(i18n[\"c\"\n                  /* translate */\n                  ])('insertTitle'),\n                  submenuTitle: Object(i18n[\"c\"\n                  /* translate */\n                  ])('insertSub'),\n                  className: 'jsoneditor-insert',\n                  click: function click() {\n                    node._onInsertBefore('', '', 'auto');\n                  },\n                  submenu: insertSubmenu\n                });\n\n                if (this.editable.field) {\n                  // create duplicate button\n                  items.push({\n                    text: Object(i18n[\"c\"\n                    /* translate */\n                    ])('duplicateText'),\n                    title: Object(i18n[\"c\"\n                    /* translate */\n                    ])('duplicateField'),\n                    className: 'jsoneditor-duplicate',\n                    click: function click() {\n                      Node.onDuplicate(node);\n                    }\n                  }); // create remove button\n\n                  items.push({\n                    text: Object(i18n[\"c\"\n                    /* translate */\n                    ])('removeText'),\n                    title: Object(i18n[\"c\"\n                    /* translate */\n                    ])('removeField'),\n                    className: 'jsoneditor-remove',\n                    click: function click() {\n                      Node.onRemove(node);\n                    }\n                  });\n                }\n              }\n\n              if (this.editor.options.onCreateMenu) {\n                var path = node.getPath();\n                items = this.editor.options.onCreateMenu(items, {\n                  type: 'single',\n                  path: path,\n                  paths: [path]\n                });\n              }\n\n              var menu = new ContextMenu[\"a\"\n              /* ContextMenu */\n              ](items, {\n                close: onClose\n              });\n              menu.show(anchor, this.editor.frame);\n            }\n            /**\n             * Show sorting modal\n             */\n\n          }, {\n            key: \"showSortModal\",\n            value: function showSortModal() {\n              var node = this;\n              var container = this.editor.options.modalAnchor || constants[\"a\"\n              /* DEFAULT_MODAL_ANCHOR */\n              ];\n              var json = this.getValue();\n\n              function onSort(sortedBy) {\n                var path = sortedBy.path;\n                var pathArray = Object(util[\"parsePath\"])(path);\n                node.sortedBy = sortedBy;\n                node.sort(pathArray, sortedBy.direction);\n              }\n\n              Object(js_showSortModal[\"a\"\n              /* showSortModal */\n              ])(container, json, onSort, node.sortedBy);\n            }\n            /**\n             * Show transform modal\n             */\n\n          }, {\n            key: \"showTransformModal\",\n            value: function showTransformModal() {\n              var node = this;\n              var anchor = this.editor.options.modalAnchor || constants[\"a\"\n              /* DEFAULT_MODAL_ANCHOR */\n              ];\n              var json = node.getValue();\n              Object(js_showTransformModal[\"a\"\n              /* showTransformModal */\n              ])(anchor, json, function (query) {\n                node.transform(query);\n              });\n            }\n            /**\n             * get the type of a value\n             * @param {*} value\n             * @return {String} type   Can be 'object', 'array', 'string', 'auto'\n             * @private\n             */\n\n          }, {\n            key: \"_getType\",\n            value: function _getType(value) {\n              if (value instanceof Array) {\n                return 'array';\n              }\n\n              if (value instanceof Object) {\n                return 'object';\n              }\n\n              if (typeof value === 'string' && typeof Object(util[\"parseString\"])(value) !== 'string') {\n                return 'string';\n              }\n\n              return 'auto';\n            }\n            /**\n             * escape a text, such that it can be displayed safely in an HTML element\n             * @param {String} text\n             * @return {String} escapedText\n             * @private\n             */\n\n          }, {\n            key: \"_escapeHTML\",\n            value: function _escapeHTML(text) {\n              if (typeof text !== 'string') {\n                return String(text);\n              } else {\n                var htmlEscaped = String(text).replace(/&/g, '&amp;') // must be replaced first!\n                .replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/ {2}/g, ' &nbsp;') // replace double space with an nbsp and space\n                .replace(/^ /, '&nbsp;') // space at start\n                .replace(/ $/, '&nbsp;'); // space at end\n\n                var json = JSON.stringify(htmlEscaped);\n                var html = json.substring(1, json.length - 1);\n\n                if (this.editor.options.escapeUnicode === true) {\n                  html = Object(util[\"escapeUnicodeChars\"])(html);\n                }\n\n                return html;\n              }\n            }\n            /**\n             * unescape a string.\n             * @param {String} escapedText\n             * @return {String} text\n             * @private\n             */\n\n          }, {\n            key: \"_unescapeHTML\",\n            value: function _unescapeHTML(escapedText) {\n              var json = '\"' + this._escapeJSON(escapedText) + '\"';\n              var htmlEscaped = Object(util[\"parse\"])(json);\n              return htmlEscaped.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&nbsp;|\\u00A0/g, ' ').replace(/&amp;/g, '&'); // must be replaced last\n            }\n            /**\n             * escape a text to make it a valid JSON string. The method will:\n             *   - replace unescaped double quotes with '\\\"'\n             *   - replace unescaped backslash with '\\\\'\n             *   - replace returns with '\\n'\n             * @param {String} text\n             * @return {String} escapedText\n             * @private\n             */\n\n          }, {\n            key: \"_escapeJSON\",\n            value: function _escapeJSON(text) {\n              // TODO: replace with some smart regex (only when a new solution is faster!)\n              var escaped = '';\n              var i = 0;\n\n              while (i < text.length) {\n                var c = text.charAt(i);\n\n                if (c === '\\n') {\n                  escaped += '\\\\n';\n                } else if (c === '\\\\') {\n                  escaped += c;\n                  i++;\n                  c = text.charAt(i);\n\n                  if (c === '' || '\"\\\\/bfnrtu'.indexOf(c) === -1) {\n                    escaped += '\\\\'; // no valid escape character\n                  }\n\n                  escaped += c;\n                } else if (c === '\"') {\n                  escaped += '\\\\\"';\n                } else {\n                  escaped += c;\n                }\n\n                i++;\n              }\n\n              return escaped;\n            }\n            /**\n             * update the object name according to the callback onNodeName\n             * @private\n             */\n\n          }, {\n            key: \"updateNodeName\",\n            value: function updateNodeName() {\n              var count = this.childs ? this.childs.length : 0;\n              var nodeName;\n\n              if (this.type === 'object' || this.type === 'array') {\n                if (this.editor.options.onNodeName) {\n                  try {\n                    nodeName = this.editor.options.onNodeName({\n                      path: this.getPath(),\n                      size: count,\n                      type: this.type\n                    });\n                  } catch (err) {\n                    console.error('Error in onNodeName callback: ', err);\n                  }\n                }\n\n                this.dom.value.innerHTML = this.type === 'object' ? '{' + (nodeName || count) + '}' : '[' + (nodeName || count) + ']';\n              }\n            }\n            /**\n             * update recursively the object's and its children's name.\n             * @private\n             */\n\n          }, {\n            key: \"recursivelyUpdateNodeName\",\n            value: function recursivelyUpdateNodeName() {\n              if (this.expanded) {\n                this.updateNodeName();\n\n                if (this.childs !== 'undefined') {\n                  var i;\n\n                  for (i in this.childs) {\n                    this.childs[i].recursivelyUpdateNodeName();\n                  }\n                }\n              }\n            }\n          }]);\n          return Node;\n        }(); // debounce interval for keyboard input in milliseconds\n\n\n        Node_Node.prototype.DEBOUNCE_INTERVAL = 150; // search will stop iterating as soon as the max is reached\n\n        Node_Node.prototype.MAX_SEARCH_RESULTS = 999; // default number of child nodes to display\n\n        var DEFAULT_MAX_VISIBLE_CHILDS = 100; // stores the element name currently having the focus\n\n        Node_Node.focusElement = undefined;\n        /**\n         * Select all text in an editable div after a delay of 0 ms\n         * @param {Element} editableDiv\n         */\n\n        Node_Node.select = function (editableDiv) {\n          setTimeout(function () {\n            Object(util[\"selectContentEditable\"])(editableDiv);\n          }, 0);\n        };\n        /**\n         * DragStart event, fired on mousedown on the dragarea at the left side of a Node\n         * @param {Node[] | Node} nodes\n         * @param {Event} event\n         */\n\n\n        Node_Node.onDragStart = function (nodes, event) {\n          if (!Array.isArray(nodes)) {\n            return Node_Node.onDragStart([nodes], event);\n          }\n\n          if (nodes.length === 0) {\n            return;\n          }\n\n          var firstNode = nodes[0];\n          var lastNode = nodes[nodes.length - 1];\n          var parent = firstNode.parent;\n          var draggedNode = Node_Node.getNodeFromTarget(event.target);\n          var editor = firstNode.editor; // in case of multiple selected nodes, offsetY prevents the selection from\n          // jumping when you start dragging one of the lower down nodes in the selection\n\n          var offsetY = Object(util[\"getAbsoluteTop\"])(draggedNode.dom.tr) - Object(util[\"getAbsoluteTop\"])(firstNode.dom.tr);\n\n          if (!editor.mousemove) {\n            editor.mousemove = Object(util[\"addEventListener\"])(window, 'mousemove', function (event) {\n              Node_Node.onDrag(nodes, event);\n            });\n          }\n\n          if (!editor.mouseup) {\n            editor.mouseup = Object(util[\"addEventListener\"])(window, 'mouseup', function (event) {\n              Node_Node.onDragEnd(nodes, event);\n            });\n          }\n\n          editor.highlighter.lock();\n          editor.drag = {\n            oldCursor: document.body.style.cursor,\n            oldSelection: editor.getDomSelection(),\n            oldPaths: nodes.map(getInternalPath),\n            oldParent: parent,\n            oldNextNode: parent.childs[lastNode.getIndex() + 1] || parent.append,\n            oldParentPathRedo: parent.getInternalPath(),\n            oldIndexRedo: firstNode.getIndex(),\n            mouseX: event.pageX,\n            offsetY: offsetY,\n            level: firstNode.getLevel()\n          };\n          document.body.style.cursor = 'move';\n          event.preventDefault();\n        };\n        /**\n         * Drag event, fired when moving the mouse while dragging a Node\n         * @param {Node[] | Node} nodes\n         * @param {Event} event\n         */\n\n\n        Node_Node.onDrag = function (nodes, event) {\n          if (!Array.isArray(nodes)) {\n            return Node_Node.onDrag([nodes], event);\n          }\n\n          if (nodes.length === 0) {\n            return;\n          } // TODO: this method has grown too large. Split it in a number of methods\n\n\n          var editor = nodes[0].editor;\n          var mouseY = event.pageY - editor.drag.offsetY;\n          var mouseX = event.pageX;\n          var trPrev, trNext, trFirst, trLast, trRoot;\n          var nodePrev, nodeNext;\n          var topPrev, topFirst, bottomNext, heightNext;\n          var moved = false; // TODO: add an ESC option, which resets to the original position\n          // move up/down\n\n          var firstNode = nodes[0];\n          var trThis = firstNode.dom.tr;\n          var topThis = Object(util[\"getAbsoluteTop\"])(trThis);\n          var heightThis = trThis.offsetHeight;\n\n          if (mouseY < topThis) {\n            // move up\n            trPrev = trThis;\n\n            do {\n              trPrev = trPrev.previousSibling;\n              nodePrev = Node_Node.getNodeFromTarget(trPrev);\n              topPrev = trPrev ? Object(util[\"getAbsoluteTop\"])(trPrev) : 0;\n            } while (trPrev && mouseY < topPrev);\n\n            if (nodePrev && !nodePrev.parent) {\n              nodePrev = undefined;\n            }\n\n            if (!nodePrev) {\n              // move to the first node\n              trRoot = trThis.parentNode.firstChild;\n              trPrev = trRoot ? trRoot.nextSibling : undefined;\n              nodePrev = Node_Node.getNodeFromTarget(trPrev);\n\n              if (nodePrev === firstNode) {\n                nodePrev = undefined;\n              }\n            }\n\n            if (nodePrev && nodePrev.isVisible()) {\n              // check if mouseY is really inside the found node\n              trPrev = nodePrev.dom.tr;\n              topPrev = trPrev ? Object(util[\"getAbsoluteTop\"])(trPrev) : 0;\n\n              if (mouseY > topPrev + heightThis) {\n                nodePrev = undefined;\n              }\n            }\n\n            if (nodePrev) {\n              nodes.forEach(function (node) {\n                nodePrev.parent.moveBefore(node, nodePrev);\n              });\n              moved = true;\n            }\n          } else {\n            // move down\n            var lastNode = nodes[nodes.length - 1];\n            trLast = lastNode.expanded && lastNode.append ? lastNode.append.getDom() : lastNode.dom.tr;\n            trFirst = trLast ? trLast.nextSibling : undefined;\n\n            if (trFirst) {\n              topFirst = Object(util[\"getAbsoluteTop\"])(trFirst);\n              trNext = trFirst;\n\n              do {\n                nodeNext = Node_Node.getNodeFromTarget(trNext);\n\n                if (trNext) {\n                  bottomNext = trNext.nextSibling ? Object(util[\"getAbsoluteTop\"])(trNext.nextSibling) : 0;\n                  heightNext = trNext ? bottomNext - topFirst : 0;\n\n                  if (nodeNext && nodeNext.parent.childs.length === nodes.length && nodeNext.parent.childs[nodes.length - 1] === lastNode) {\n                    // We are about to remove the last child of this parent,\n                    // which will make the parents appendNode visible.\n                    topThis += 27; // TODO: dangerous to suppose the height of the appendNode a constant of 27 px.\n                  }\n\n                  trNext = trNext.nextSibling;\n                }\n              } while (trNext && mouseY > topThis + heightNext);\n\n              if (nodeNext && nodeNext.parent) {\n                // calculate the desired level\n                var diffX = mouseX - editor.drag.mouseX;\n                var diffLevel = Math.round(diffX / 24 / 2);\n                var level = editor.drag.level + diffLevel; // desired level\n\n                var levelNext = nodeNext.getLevel(); // level to be\n                // find the best fitting level (move upwards over the append nodes)\n\n                trPrev = nodeNext.dom.tr && nodeNext.dom.tr.previousSibling;\n\n                while (levelNext < level && trPrev) {\n                  nodePrev = Node_Node.getNodeFromTarget(trPrev);\n                  var isDraggedNode = nodes.some(function (node) {\n                    return node === nodePrev || nodePrev.isDescendantOf(node);\n                  });\n                  if (isDraggedNode) ;else if (nodePrev instanceof Node_AppendNode) {\n                    var childs = nodePrev.parent.childs;\n\n                    if (childs.length !== nodes.length || childs[nodes.length - 1] !== lastNode) {\n                      // non-visible append node of a list of childs\n                      // consisting of not only this node (else the\n                      // append node will change into a visible \"empty\"\n                      // text when removing this node).\n                      nodeNext = Node_Node.getNodeFromTarget(trPrev);\n                      levelNext = nodeNext.getLevel();\n                    } else {\n                      break;\n                    }\n                  } else {\n                    break;\n                  }\n                  trPrev = trPrev.previousSibling;\n                }\n\n                if (nodeNext instanceof Node_AppendNode && !nodeNext.isVisible() && nodeNext.parent.showMore.isVisible()) {\n                  nodeNext = nodeNext._nextNode();\n                } // move the node when its position is changed\n\n\n                if (nodeNext && nodeNext.dom.tr && trLast.nextSibling !== nodeNext.dom.tr) {\n                  nodes.forEach(function (node) {\n                    nodeNext.parent.moveBefore(node, nodeNext);\n                  });\n                  moved = true;\n                }\n              }\n            }\n          }\n\n          if (moved) {\n            // update the dragging parameters when moved\n            editor.drag.mouseX = mouseX;\n            editor.drag.level = firstNode.getLevel();\n          } // auto scroll when hovering around the top of the editor\n\n\n          editor.startAutoScroll(mouseY);\n          event.preventDefault();\n        };\n        /**\n         * Drag event, fired on mouseup after having dragged a node\n         * @param {Node[] | Node} nodes\n         * @param {Event} event\n         */\n\n\n        Node_Node.onDragEnd = function (nodes, event) {\n          if (!Array.isArray(nodes)) {\n            return Node_Node.onDrag([nodes], event);\n          }\n\n          if (nodes.length === 0) {\n            return;\n          }\n\n          var firstNode = nodes[0];\n          var editor = firstNode.editor; // set focus to the context menu button of the first node\n\n          if (nodes[0]) {\n            nodes[0].dom.menu.focus();\n          }\n\n          var oldParentPath = editor.drag.oldParent.getInternalPath();\n          var newParentPath = firstNode.parent.getInternalPath();\n          var sameParent = editor.drag.oldParent === firstNode.parent;\n          var oldIndex = editor.drag.oldNextNode.getIndex();\n          var newIndex = firstNode.getIndex();\n          var oldParentPathRedo = editor.drag.oldParentPathRedo;\n          var oldIndexRedo = editor.drag.oldIndexRedo;\n          var newIndexRedo = sameParent && oldIndexRedo < newIndex ? newIndex + nodes.length : newIndex;\n\n          if (!sameParent || oldIndexRedo !== newIndex) {\n            // only register this action if the node is actually moved to another place\n            editor._onAction('moveNodes', {\n              count: nodes.length,\n              fieldNames: nodes.map(getField),\n              oldParentPath: oldParentPath,\n              newParentPath: newParentPath,\n              oldIndex: oldIndex,\n              newIndex: newIndex,\n              oldIndexRedo: oldIndexRedo,\n              newIndexRedo: newIndexRedo,\n              oldParentPathRedo: oldParentPathRedo,\n              newParentPathRedo: null,\n              // This is a hack, value will be filled in during undo\n              oldSelection: editor.drag.oldSelection,\n              newSelection: editor.getDomSelection()\n            });\n          }\n\n          document.body.style.cursor = editor.drag.oldCursor;\n          editor.highlighter.unlock();\n          nodes.forEach(function (node) {\n            node.updateDom();\n\n            if (event.target !== node.dom.drag && event.target !== node.dom.menu) {\n              editor.highlighter.unhighlight();\n            }\n          });\n          delete editor.drag;\n\n          if (editor.mousemove) {\n            Object(util[\"removeEventListener\"])(window, 'mousemove', editor.mousemove);\n            delete editor.mousemove;\n          }\n\n          if (editor.mouseup) {\n            Object(util[\"removeEventListener\"])(window, 'mouseup', editor.mouseup);\n            delete editor.mouseup;\n          } // Stop any running auto scroll\n\n\n          editor.stopAutoScroll();\n          event.preventDefault();\n        };\n        /**\n         * find an enum definition in a JSON schema, as property `enum` or inside\n         * one of the schemas composites (`oneOf`, `anyOf`, `allOf`)\n         * @param  {Object} schema\n         * @return {Array | null} Returns the enum when found, null otherwise.\n         * @private\n         */\n\n\n        Node_Node._findEnum = function (schema) {\n          if (schema[\"enum\"]) {\n            return schema[\"enum\"];\n          }\n\n          var composite = schema.oneOf || schema.anyOf || schema.allOf;\n\n          if (composite) {\n            var match = composite.filter(function (entry) {\n              return entry[\"enum\"];\n            });\n\n            if (match.length > 0) {\n              return match[0][\"enum\"];\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Return the part of a JSON schema matching given path.\n         * @param {Object} schema\n         * @param {Object} schemaRefs\n         * @param {Array.<string | number>} path\n         * @return {Object | null}\n         * @private\n         */\n\n\n        Node_Node._findSchema = function (schema, schemaRefs, path) {\n          var childSchema = schema;\n          var foundSchema = childSchema;\n          var allSchemas = schema.oneOf || schema.anyOf || schema.allOf;\n\n          if (!allSchemas) {\n            allSchemas = [schema];\n          }\n\n          for (var j = 0; j < allSchemas.length; j++) {\n            childSchema = allSchemas[j];\n\n            if ('$ref' in childSchema && typeof childSchema.$ref === 'string') {\n              childSchema = schemaRefs[childSchema.$ref];\n\n              if (childSchema) {\n                foundSchema = Node_Node._findSchema(childSchema, schemaRefs, path);\n              }\n            }\n\n            for (var i = 0; i < path.length && childSchema; i++) {\n              var nextPath = path.slice(i + 1, path.length);\n              var key = path[i];\n\n              if (typeof key === 'string' && childSchema.patternProperties && !(childSchema.properties && key in childSchema.properties)) {\n                for (var prop in childSchema.patternProperties) {\n                  if (key.match(prop)) {\n                    foundSchema = Node_Node._findSchema(childSchema.patternProperties[prop], schemaRefs, nextPath);\n                  }\n                }\n              } else if (typeof key === 'string' && childSchema.properties) {\n                if (!(key in childSchema.properties)) {\n                  foundSchema = null;\n                } else {\n                  childSchema = childSchema.properties[key];\n\n                  if (childSchema) {\n                    foundSchema = Node_Node._findSchema(childSchema, schemaRefs, nextPath);\n                  }\n                }\n              } else if (typeof key === 'number' && childSchema.items) {\n                childSchema = childSchema.items;\n\n                if (childSchema) {\n                  foundSchema = Node_Node._findSchema(childSchema, schemaRefs, nextPath);\n                }\n              }\n            }\n          } // If the found schema is the input schema, the schema does not have the given path\n\n\n          if (foundSchema === schema && path.length > 0) {\n            return null;\n          }\n\n          return foundSchema;\n        };\n        /**\n         * Remove nodes\n         * @param {Node[] | Node} nodes\n         */\n\n\n        Node_Node.onRemove = function (nodes) {\n          if (!Array.isArray(nodes)) {\n            return Node_Node.onRemove([nodes]);\n          }\n\n          if (nodes && nodes.length > 0) {\n            var firstNode = nodes[0];\n            var parent = firstNode.parent;\n            var editor = firstNode.editor;\n            var firstIndex = firstNode.getIndex();\n            editor.highlighter.unhighlight(); // adjust the focus\n\n            var oldSelection = editor.getDomSelection();\n            Node_Node.blurNodes(nodes);\n            var newSelection = editor.getDomSelection(); // store the paths before removing them (needed for history)\n\n            var paths = nodes.map(getInternalPath); // remove the nodes\n\n            nodes.forEach(function (node) {\n              node.parent._remove(node);\n            }); // store history action\n\n            editor._onAction('removeNodes', {\n              nodes: nodes,\n              paths: paths,\n              parentPath: parent.getInternalPath(),\n              index: firstIndex,\n              oldSelection: oldSelection,\n              newSelection: newSelection\n            });\n          }\n        };\n        /**\n         * Duplicate nodes\n         * duplicated nodes will be added right after the original nodes\n         * @param {Node[] | Node} nodes\n         */\n\n\n        Node_Node.onDuplicate = function (nodes) {\n          if (!Array.isArray(nodes)) {\n            return Node_Node.onDuplicate([nodes]);\n          }\n\n          if (nodes && nodes.length > 0) {\n            var lastNode = nodes[nodes.length - 1];\n            var parent = lastNode.parent;\n            var editor = lastNode.editor;\n            editor.deselect(editor.multiselection.nodes); // duplicate the nodes\n\n            var oldSelection = editor.getDomSelection();\n            var afterNode = lastNode;\n            var clones = nodes.map(function (node) {\n              var clone = node.clone();\n\n              if (node.parent.type === 'object') {\n                var existingFieldNames = node.parent.getFieldNames();\n                clone.field = Object(util[\"findUniqueName\"])(node.field, existingFieldNames);\n              }\n\n              parent.insertAfter(clone, afterNode);\n              afterNode = clone;\n              return clone;\n            }); // set selection to the duplicated nodes\n\n            if (nodes.length === 1) {\n              if (clones[0].parent.type === 'object') {\n                // when duplicating a single object property,\n                // set focus to the field and keep the original field name\n                clones[0].dom.field.innerHTML = nodes[0].field;\n                clones[0].focus('field');\n              } else {\n                clones[0].focus();\n              }\n            } else {\n              editor.select(clones);\n            }\n\n            var newSelection = editor.getDomSelection();\n\n            editor._onAction('duplicateNodes', {\n              paths: nodes.map(getInternalPath),\n              clonePaths: clones.map(getInternalPath),\n              afterPath: lastNode.getInternalPath(),\n              parentPath: parent.getInternalPath(),\n              oldSelection: oldSelection,\n              newSelection: newSelection\n            });\n          }\n        };\n        /**\n         * Find the node from an event target\n         * @param {HTMLElement} target\n         * @return {Node | undefined} node  or undefined when not found\n         * @static\n         */\n\n\n        Node_Node.getNodeFromTarget = function (target) {\n          while (target) {\n            if (target.node) {\n              return target.node;\n            }\n\n            target = target.parentNode;\n          }\n\n          return undefined;\n        };\n        /**\n         * Test whether target is a child of the color DOM of a node\n         * @param {HTMLElement} target\n         * @returns {boolean}\n         */\n\n\n        Node_Node.targetIsColorPicker = function (target) {\n          var node = Node_Node.getNodeFromTarget(target);\n\n          if (node) {\n            var parent = target && target.parentNode;\n\n            while (parent) {\n              if (parent === node.dom.color) {\n                return true;\n              }\n\n              parent = parent.parentNode;\n            }\n          }\n\n          return false;\n        };\n        /**\n         * Remove the focus of given nodes, and move the focus to the (a) node before,\n         * (b) the node after, or (c) the parent node.\n         * @param {Array.<Node> | Node} nodes\n         */\n\n\n        Node_Node.blurNodes = function (nodes) {\n          if (!Array.isArray(nodes)) {\n            Node_Node.blurNodes([nodes]);\n            return;\n          }\n\n          var firstNode = nodes[0];\n          var parent = firstNode.parent;\n          var firstIndex = firstNode.getIndex();\n\n          if (parent.childs[firstIndex + nodes.length]) {\n            parent.childs[firstIndex + nodes.length].focus();\n          } else if (parent.childs[firstIndex - 1]) {\n            parent.childs[firstIndex - 1].focus();\n          } else {\n            parent.focus();\n          }\n        }; // titles with explanation for the different types\n\n\n        Node_Node.TYPE_TITLES = {\n          auto: Object(i18n[\"c\"\n          /* translate */\n          ])('autoType'),\n          object: Object(i18n[\"c\"\n          /* translate */\n          ])('objectType'),\n          array: Object(i18n[\"c\"\n          /* translate */\n          ])('arrayType'),\n          string: Object(i18n[\"c\"\n          /* translate */\n          ])('stringType')\n        }; // helper function to get the internal path of a node\n\n        function getInternalPath(node) {\n          return node.getInternalPath();\n        } // helper function to get the field of a node\n\n\n        function getField(node) {\n          return node.getField();\n        }\n\n        function Node_hasOwnProperty(object, key) {\n          return Object.prototype.hasOwnProperty.call(object, key);\n        } // TODO: find a nicer solution to resolve this circular dependency between Node and AppendNode\n        //       idea: introduce properties .isAppendNode and .isNode and use that instead of instanceof AppendNode checks\n\n\n        var Node_AppendNode = appendNodeFactory(Node_Node);\n        var Node_ShowMoreNode = showMoreNodeFactory(Node_Node); // EXTERNAL MODULE: ./src/js/ModeSwitcher.js\n\n        var ModeSwitcher = __webpack_require__(6); // CONCATENATED MODULE: ./src/js/autocomplete.js\n\n\n        var defaultFilterFunction = {\n          start: function start(token, match, config) {\n            return match.indexOf(token) === 0;\n          },\n          contain: function contain(token, match, config) {\n            return match.indexOf(token) > -1;\n          }\n        };\n\n        function autocomplete(config) {\n          config = config || {};\n          config.filter = config.filter || 'start';\n          config.trigger = config.trigger || 'keydown';\n          config.confirmKeys = config.confirmKeys || [39, 35, 9]; // right, end, tab\n\n          config.caseSensitive = config.caseSensitive || false; // autocomplete case sensitive\n\n          var fontSize = '';\n          var fontFamily = '';\n          var wrapper = document.createElement('div');\n          wrapper.style.position = 'relative';\n          wrapper.style.outline = '0';\n          wrapper.style.border = '0';\n          wrapper.style.margin = '0';\n          wrapper.style.padding = '0';\n          var dropDown = document.createElement('div');\n          dropDown.className = 'autocomplete dropdown';\n          dropDown.style.position = 'absolute';\n          dropDown.style.visibility = 'hidden';\n          var spacer;\n          var leftSide; // <-- it will contain the leftSide part of the textfield (the bit that was already autocompleted)\n\n          var createDropDownController = function createDropDownController(elem, rs) {\n            var rows = [];\n            var ix = 0;\n            var oldIndex = -1; // TODO: move this styling in JS to SCSS\n\n            var onMouseOver = function onMouseOver() {\n              this.style.backgroundColor = '#ddd';\n            };\n\n            var onMouseOut = function onMouseOut() {\n              this.style.backgroundColor = '';\n            };\n\n            var onMouseDown = function onMouseDown() {\n              p.hide();\n              p.onmouseselection(this.__hint, p.rs);\n            };\n\n            var p = {\n              rs: rs,\n              hide: function hide() {\n                elem.style.visibility = 'hidden'; // rs.hideDropDown();\n              },\n              refresh: function refresh(token, array) {\n                elem.style.visibility = 'hidden';\n                ix = 0;\n                elem.innerHTML = '';\n                var vph = window.innerHeight || document.documentElement.clientHeight;\n                var rect = elem.parentNode.getBoundingClientRect();\n                var distanceToTop = rect.top - 6; // heuristic give 6px\n\n                var distanceToBottom = vph - rect.bottom - 6; // distance from the browser border.\n\n                rows = [];\n                var filterFn = typeof config.filter === 'function' ? config.filter : defaultFilterFunction[config.filter];\n                var filtered = !filterFn ? [] : array.filter(function (match) {\n                  return filterFn(config.caseSensitive ? token : token.toLowerCase(), config.caseSensitive ? match : match.toLowerCase(), config);\n                });\n                rows = filtered.map(function (row) {\n                  var divRow = document.createElement('div');\n                  divRow.className = 'item'; // divRow.style.color = config.color;\n\n                  divRow.onmouseover = onMouseOver;\n                  divRow.onmouseout = onMouseOut;\n                  divRow.onmousedown = onMouseDown;\n                  divRow.__hint = row;\n                  divRow.innerHTML = row.substring(0, token.length) + '<b>' + row.substring(token.length) + '</b>';\n                  elem.appendChild(divRow);\n                  return divRow;\n                });\n\n                if (rows.length === 0) {\n                  return; // nothing to show.\n                }\n\n                if (rows.length === 1 && (token.toLowerCase() === rows[0].__hint.toLowerCase() && !config.caseSensitive || token === rows[0].__hint && config.caseSensitive)) {\n                  return; // do not show the dropDown if it has only one element which matches what we have just displayed.\n                }\n\n                if (rows.length < 2) return;\n                p.highlight(0);\n\n                if (distanceToTop > distanceToBottom * 3) {\n                  // Heuristic (only when the distance to the to top is 4 times more than distance to the bottom\n                  elem.style.maxHeight = distanceToTop + 'px'; // we display the dropDown on the top of the input text\n\n                  elem.style.top = '';\n                  elem.style.bottom = '100%';\n                } else {\n                  elem.style.top = '100%';\n                  elem.style.bottom = '';\n                  elem.style.maxHeight = distanceToBottom + 'px';\n                }\n\n                elem.style.visibility = 'visible';\n              },\n              highlight: function highlight(index) {\n                if (oldIndex !== -1 && rows[oldIndex]) {\n                  rows[oldIndex].className = 'item';\n                }\n\n                rows[index].className = 'item hover';\n                oldIndex = index;\n              },\n              move: function move(step) {\n                // moves the selection either up or down (unless it's not possible) step is either +1 or -1.\n                if (elem.style.visibility === 'hidden') return ''; // nothing to move if there is no dropDown. (this happens if the user hits escape and then down or up)\n\n                if (ix + step === -1 || ix + step === rows.length) return rows[ix].__hint; // NO CIRCULAR SCROLLING.\n\n                ix += step;\n                p.highlight(ix);\n                return rows[ix].__hint; // txtShadow.value = uRows[uIndex].__hint ;\n              },\n              onmouseselection: function onmouseselection() {} // it will be overwritten.\n\n            };\n            return p;\n          };\n\n          function setEndOfContenteditable(contentEditableElement) {\n            var range, selection;\n\n            if (document.createRange) {\n              // Firefox, Chrome, Opera, Safari, IE 9+\n              range = document.createRange(); // Create a range (a range is a like the selection but invisible)\n\n              range.selectNodeContents(contentEditableElement); // Select the entire contents of the element with the range\n\n              range.collapse(false); // collapse the range to the end point. false means collapse to end rather than the start\n\n              selection = window.getSelection(); // get the selection object (allows you to change selection)\n\n              selection.removeAllRanges(); // remove any selections already made\n\n              selection.addRange(range); // make the range you have just created the visible selection\n            } else if (document.selection) {\n              // IE 8 and lower\n              range = document.body.createTextRange(); // Create a range (a range is a like the selection but invisible)\n\n              range.moveToElementText(contentEditableElement); // Select the entire contents of the element with the range\n\n              range.collapse(false); // collapse the range to the end point. false means collapse to end rather than the start\n\n              range.select(); // Select the range (make it the visible selection\n            }\n          }\n\n          function calculateWidthForText(text) {\n            if (spacer === undefined) {\n              // on first call only.\n              spacer = document.createElement('span');\n              spacer.style.visibility = 'hidden';\n              spacer.style.position = 'fixed';\n              spacer.style.outline = '0';\n              spacer.style.margin = '0';\n              spacer.style.padding = '0';\n              spacer.style.border = '0';\n              spacer.style.left = '0';\n              spacer.style.whiteSpace = 'pre';\n              spacer.style.fontSize = fontSize;\n              spacer.style.fontFamily = fontFamily;\n              spacer.style.fontWeight = 'normal';\n              document.body.appendChild(spacer);\n            } // Used to encode an HTML string into a plain text.\n            // taken from http://stackoverflow.com/questions/1219860/javascript-jquery-html-encoding\n\n\n            spacer.innerHTML = String(text).replace(/&/g, '&amp;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n            return spacer.getBoundingClientRect().right;\n          }\n\n          var rs = {\n            onArrowDown: function onArrowDown() {},\n            // defaults to no action.\n            onArrowUp: function onArrowUp() {},\n            // defaults to no action.\n            onEnter: function onEnter() {},\n            // defaults to no action.\n            onTab: function onTab() {},\n            // defaults to no action.\n            startFrom: 0,\n            options: [],\n            element: null,\n            elementHint: null,\n            elementStyle: null,\n            wrapper: wrapper,\n            // Only to allow  easy access to the HTML elements to the final user (possibly for minor customizations)\n            show: function show(element, startPos, options) {\n              var _this = this;\n\n              this.startFrom = startPos;\n              this.wrapper.remove();\n\n              if (this.elementHint) {\n                this.elementHint.remove();\n                this.elementHint = null;\n              }\n\n              if (fontSize === '') {\n                fontSize = window.getComputedStyle(element).getPropertyValue('font-size');\n              }\n\n              if (fontFamily === '') {\n                fontFamily = window.getComputedStyle(element).getPropertyValue('font-family');\n              }\n\n              dropDown.style.marginLeft = '0';\n              dropDown.style.marginTop = element.getBoundingClientRect().height + 'px';\n              this.options = options;\n\n              if (this.element !== element) {\n                this.element = element;\n                this.elementStyle = {\n                  zIndex: this.element.style.zIndex,\n                  position: this.element.style.position,\n                  backgroundColor: this.element.style.backgroundColor,\n                  borderColor: this.element.style.borderColor\n                };\n              }\n\n              this.element.style.zIndex = 3;\n              this.element.style.position = 'relative';\n              this.element.style.backgroundColor = 'transparent';\n              this.element.style.borderColor = 'transparent';\n              this.elementHint = element.cloneNode();\n              this.elementHint.className = 'autocomplete hint';\n              this.elementHint.style.zIndex = 2;\n              this.elementHint.style.position = 'absolute';\n\n              this.elementHint.onfocus = function () {\n                _this.element.focus();\n              };\n\n              if (this.element.addEventListener) {\n                this.element.removeEventListener('keydown', keyDownHandler);\n                this.element.addEventListener('keydown', keyDownHandler, false);\n                this.element.removeEventListener('blur', onBlurHandler);\n                this.element.addEventListener('blur', onBlurHandler, false);\n              }\n\n              wrapper.appendChild(this.elementHint);\n              wrapper.appendChild(dropDown);\n              element.parentElement.appendChild(wrapper);\n              this.repaint(element);\n            },\n            setText: function setText(text) {\n              this.element.innerText = text;\n            },\n            getText: function getText() {\n              return this.element.innerText;\n            },\n            hideDropDown: function hideDropDown() {\n              this.wrapper.remove();\n\n              if (this.elementHint) {\n                this.elementHint.remove();\n                this.elementHint = null;\n                dropDownController.hide();\n                this.element.style.zIndex = this.elementStyle.zIndex;\n                this.element.style.position = this.elementStyle.position;\n                this.element.style.backgroundColor = this.elementStyle.backgroundColor;\n                this.element.style.borderColor = this.elementStyle.borderColor;\n              }\n            },\n            repaint: function repaint(element) {\n              var text = element.innerText;\n              text = text.replace('\\n', '');\n              var optionsLength = this.options.length; // breaking text in leftSide and token.\n\n              var token = text.substring(this.startFrom);\n              leftSide = text.substring(0, this.startFrom);\n\n              for (var i = 0; i < optionsLength; i++) {\n                var opt = this.options[i];\n\n                if (!config.caseSensitive && opt.toLowerCase().indexOf(token.toLowerCase()) === 0 || config.caseSensitive && opt.indexOf(token) === 0) {\n                  // <-- how about upperCase vs. lowercase\n                  this.elementHint.innerText = leftSide + token + opt.substring(token.length);\n                  this.elementHint.realInnerText = leftSide + opt;\n                  break;\n                }\n              } // moving the dropDown and refreshing it.\n\n\n              dropDown.style.left = calculateWidthForText(leftSide) + 'px';\n              dropDownController.refresh(token, this.options);\n              this.elementHint.style.width = calculateWidthForText(this.elementHint.innerText) + 10 + 'px';\n              var wasDropDownHidden = dropDown.style.visibility === 'hidden';\n\n              if (!wasDropDownHidden) {\n                this.elementHint.style.width = calculateWidthForText(this.elementHint.innerText) + dropDown.clientWidth + 'px';\n              }\n            }\n          };\n          var dropDownController = createDropDownController(dropDown, rs);\n\n          var keyDownHandler = function (e) {\n            // console.log(\"Keydown:\" + e.keyCode);\n            e = e || window.event;\n            var keyCode = e.keyCode;\n            if (this.elementHint == null) return;\n\n            if (keyCode === 33) {\n              return;\n            } // page up (do nothing)\n\n\n            if (keyCode === 34) {\n              return;\n            } // page down (do nothing);\n\n\n            if (keyCode === 27) {\n              // escape\n              rs.hideDropDown();\n              rs.element.focus();\n              e.preventDefault();\n              e.stopPropagation();\n              return;\n            }\n\n            var text = this.element.innerText;\n            text = text.replace('\\n', '');\n\n            if (config.confirmKeys.indexOf(keyCode) >= 0) {\n              //  (autocomplete triggered)\n              if (keyCode === 9) {\n                if (this.elementHint.innerText.length === 0) {\n                  rs.onTab();\n                }\n              }\n\n              if (this.elementHint.innerText.length > 0) {\n                // if there is a hint\n                if (this.element.innerText !== this.elementHint.realInnerText) {\n                  this.element.innerText = this.elementHint.realInnerText;\n                  rs.hideDropDown();\n                  setEndOfContenteditable(this.element);\n\n                  if (keyCode === 9) {\n                    rs.element.focus();\n                    e.preventDefault();\n                    e.stopPropagation();\n                  }\n                }\n              }\n\n              return;\n            }\n\n            if (keyCode === 13) {\n              // enter  (autocomplete triggered)\n              if (this.elementHint.innerText.length === 0) {\n                // if there is a hint\n                rs.onEnter();\n              } else {\n                var wasDropDownHidden = dropDown.style.visibility === 'hidden';\n                dropDownController.hide();\n\n                if (wasDropDownHidden) {\n                  rs.hideDropDown();\n                  rs.element.focus();\n                  rs.onEnter();\n                  return;\n                }\n\n                this.element.innerText = this.elementHint.realInnerText;\n                rs.hideDropDown();\n                setEndOfContenteditable(this.element);\n                e.preventDefault();\n                e.stopPropagation();\n              }\n\n              return;\n            }\n\n            if (keyCode === 40) {\n              // down\n              var token = text.substring(this.startFrom);\n              var m = dropDownController.move(+1);\n\n              if (m === '') {\n                rs.onArrowDown();\n              }\n\n              this.elementHint.innerText = leftSide + token + m.substring(token.length);\n              this.elementHint.realInnerText = leftSide + m;\n              e.preventDefault();\n              e.stopPropagation();\n              return;\n            }\n\n            if (keyCode === 38) {\n              // up\n              var _token = text.substring(this.startFrom);\n\n              var _m = dropDownController.move(-1);\n\n              if (_m === '') {\n                rs.onArrowUp();\n              }\n\n              this.elementHint.innerText = leftSide + _token + _m.substring(_token.length);\n              this.elementHint.realInnerText = leftSide + _m;\n              e.preventDefault();\n              e.stopPropagation();\n            }\n          }.bind(rs);\n\n          var onBlurHandler = function onBlurHandler(e) {\n            rs.hideDropDown(); // console.log(\"Lost focus.\");\n          };\n\n          dropDownController.onmouseselection = function (text, rs) {\n            rs.element.innerText = rs.elementHint.innerText = leftSide + text;\n            rs.hideDropDown();\n            window.setTimeout(function () {\n              rs.element.focus();\n              setEndOfContenteditable(rs.element);\n            }, 1);\n          };\n\n          return rs;\n        } // CONCATENATED MODULE: ./src/js/treemode.js\n\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"treeModeMixins\", function () {\n          return treeModeMixins;\n        }); // create a mixin with the functions for tree mode\n\n\n        var treemode = {};\n        /**\n         * Create a tree editor\n         * @param {Element} container    Container element\n         * @param {Object} [options]   Object with options. See docs for details.\n         * @private\n         */\n\n        treemode.create = function (container, options) {\n          if (!container) {\n            throw new Error('No container element provided.');\n          }\n\n          this.container = container;\n          this.dom = {};\n          this.highlighter = new Highlighter();\n          this.selection = undefined; // will hold the last input selection\n\n          this.multiselection = {\n            nodes: []\n          };\n          this.validateSchema = null; // will be set in .setSchema(schema)\n\n          this.validationSequence = 0;\n          this.errorNodes = [];\n          this.node = null;\n          this.focusTarget = null;\n\n          this._setOptions(options);\n\n          if (options.autocomplete) {\n            this.autocomplete = autocomplete(options.autocomplete);\n          }\n\n          if (this.options.history && this.options.mode !== 'view') {\n            this.history = new NodeHistory_NodeHistory(this);\n          }\n\n          this._createFrame();\n\n          this._createTable();\n        };\n        /**\n         * Destroy the editor. Clean up DOM, event listeners, and web workers.\n         */\n\n\n        treemode.destroy = function () {\n          if (this.frame && this.container && this.frame.parentNode === this.container) {\n            this.container.removeChild(this.frame);\n            this.frame = null;\n          }\n\n          this.container = null;\n          this.dom = null;\n          this.clear();\n          this.node = null;\n          this.focusTarget = null;\n          this.selection = null;\n          this.multiselection = null;\n          this.errorNodes = null;\n          this.validateSchema = null;\n          this._debouncedValidate = null;\n\n          if (this.history) {\n            this.history.destroy();\n            this.history = null;\n          }\n\n          if (this.searchBox) {\n            this.searchBox.destroy();\n            this.searchBox = null;\n          }\n\n          if (this.modeSwitcher) {\n            this.modeSwitcher.destroy();\n            this.modeSwitcher = null;\n          }\n        };\n        /**\n         * Initialize and set default options\n         * @param {Object}  [options]    See description in constructor\n         * @private\n         */\n\n\n        treemode._setOptions = function (options) {\n          var _this = this;\n\n          this.options = {\n            search: true,\n            history: true,\n            mode: 'tree',\n            name: undefined,\n            // field name of root node\n            schema: null,\n            schemaRefs: null,\n            autocomplete: null,\n            navigationBar: true,\n            mainMenuBar: true,\n            onSelectionChange: null,\n            colorPicker: true,\n            onColorPicker: function onColorPicker(parent, color, onChange) {\n              if (vanilla_picker_default.a) {\n                // we'll render the color picker on top\n                // when there is not enough space below, and there is enough space above\n                var pickerHeight = 300; // estimated height of the color picker\n\n                var top = parent.getBoundingClientRect().top;\n                var windowHeight = window.innerHeight;\n                new vanilla_picker_default.a({\n                  parent: parent,\n                  color: color,\n                  popup: windowHeight - top < pickerHeight && top > pickerHeight ? 'top' : 'bottom',\n                  onDone: function onDone(color) {\n                    var alpha = color.rgba[3];\n                    var hex = alpha === 1 ? color.hex.substr(0, 7) // return #RRGGBB\n                    : color.hex; // return #RRGGBBAA\n\n                    onChange(hex);\n                  }\n                }).show();\n              } else {\n                console.warn('Cannot open color picker: the `vanilla-picker` library is not included in the bundle. ' + 'Either use the full bundle or implement your own color picker using `onColorPicker`.');\n              }\n            },\n            timestampTag: true,\n            onEvent: null,\n            enableSort: true,\n            enableTransform: true\n          }; // copy all options\n\n          if (options) {\n            Object.keys(options).forEach(function (prop) {\n              _this.options[prop] = options[prop];\n            });\n          } // compile a JSON schema validator if a JSON schema is provided\n\n\n          this.setSchema(this.options.schema, this.options.schemaRefs); // create a debounced validate function\n\n          this._debouncedValidate = Object(util[\"debounce\"])(this.validate.bind(this), this.DEBOUNCE_INTERVAL);\n\n          if (options.onSelectionChange) {\n            this.onSelectionChange(options.onSelectionChange);\n          }\n\n          Object(i18n[\"b\"\n          /* setLanguages */\n          ])(this.options.languages);\n          Object(i18n[\"a\"\n          /* setLanguage */\n          ])(this.options.language);\n        };\n        /**\n         * Set new JSON object in editor.\n         * Resets the state of the editor (expanded nodes, search, selection).\n         *\n         * @param {*} json\n         */\n\n\n        treemode.set = function (json) {\n          // verify if json is valid JSON, ignore when a function\n          if (json instanceof Function || json === undefined) {\n            this.clear();\n          } else {\n            this.content.removeChild(this.table); // Take the table offline\n            // replace the root node\n\n            var params = {\n              field: this.options.name,\n              value: json\n            };\n            var node = new Node_Node(this, params);\n\n            this._setRoot(node); // validate JSON schema (if configured)\n\n\n            this.validate(); // expand\n\n            var recurse = false;\n            this.node.expand(recurse);\n            this.content.appendChild(this.table); // Put the table online again\n          } // TODO: maintain history, store last state and previous document\n\n\n          if (this.history) {\n            this.history.clear();\n          } // clear search\n\n\n          if (this.searchBox) {\n            this.searchBox.clear();\n          }\n        };\n        /**\n         * Update JSON object in editor.\n         * Maintains the state of the editor (expanded nodes, search, selection).\n         *\n         * @param {*} json\n         */\n\n\n        treemode.update = function (json) {\n          // don't update if there are no changes\n          if (this.node.deepEqual(json)) {\n            return;\n          }\n\n          var selection = this.getSelection(); // apply the changed json\n\n          this.onChangeDisabled = true; // don't fire an onChange event\n\n          this.node.update(json);\n          this.onChangeDisabled = false; // validate JSON schema\n\n          this.validate(); // update search result if any\n\n          if (this.searchBox && !this.searchBox.isEmpty()) {\n            this.searchBox.forceSearch();\n          } // update selection if any\n\n\n          if (selection && selection.start && selection.end) {\n            // only keep/update the selection if both start and end node still exists,\n            // else we clear the selection\n            var startNode = this.node.findNodeByPath(selection.start.path);\n            var endNode = this.node.findNodeByPath(selection.end.path);\n\n            if (startNode && endNode) {\n              this.setSelection(selection.start, selection.end);\n            } else {\n              this.setSelection({}, {}); // clear selection\n            }\n          } else {\n            this.setSelection({}, {}); // clear selection\n          }\n        };\n        /**\n         * Get JSON object from editor\n         * @return {Object | undefined} json\n         */\n\n\n        treemode.get = function () {\n          // TODO: resolve pending debounced input changes if any, but do not resolve invalid inputs\n          if (this.node) {\n            return this.node.getValue();\n          } else {\n            return undefined;\n          }\n        };\n        /**\n         * Get the text contents of the editor\n         * @return {String} jsonText\n         */\n\n\n        treemode.getText = function () {\n          return JSON.stringify(this.get());\n        };\n        /**\n         * Set the text contents of the editor.\n         * Resets the state of the editor (expanded nodes, search, selection).\n         * @param {String} jsonText\n         */\n\n\n        treemode.setText = function (jsonText) {\n          try {\n            this.set(Object(util[\"parse\"])(jsonText)); // this can throw an error\n          } catch (err) {\n            // try to repair json, replace JavaScript notation with JSON notation\n            var repairedJsonText = Object(util[\"repair\"])(jsonText); // try to parse again\n\n            this.set(Object(util[\"parse\"])(repairedJsonText)); // this can throw an error\n          }\n        };\n        /**\n         * Update the text contents of the editor.\n         * Maintains the state of the editor (expanded nodes, search, selection).\n         * @param {String} jsonText\n         */\n\n\n        treemode.updateText = function (jsonText) {\n          try {\n            this.update(Object(util[\"parse\"])(jsonText)); // this can throw an error\n          } catch (err) {\n            // try to repair json, replace JavaScript notation with JSON notation\n            var repairJsonText = Object(util[\"repair\"])(jsonText); // try to parse again\n\n            this.update(Object(util[\"parse\"])(repairJsonText)); // this can throw an error\n          }\n        };\n        /**\n         * Set a field name for the root node.\n         * @param {String | undefined} name\n         */\n\n\n        treemode.setName = function (name) {\n          this.options.name = name;\n\n          if (this.node) {\n            this.node.updateField(this.options.name);\n          }\n        };\n        /**\n         * Get the field name for the root node.\n         * @return {String | undefined} name\n         */\n\n\n        treemode.getName = function () {\n          return this.options.name;\n        };\n        /**\n         * Set focus to the editor. Focus will be set to:\n         * - the first editable field or value, or else\n         * - to the expand button of the root node, or else\n         * - to the context menu button of the root node, or else\n         * - to the first button in the top menu\n         */\n\n\n        treemode.focus = function () {\n          var input = this.scrollableContent.querySelector('[contenteditable=true]');\n\n          if (input) {\n            input.focus();\n          } else if (this.node.dom.expand) {\n            this.node.dom.expand.focus();\n          } else if (this.node.dom.menu) {\n            this.node.dom.menu.focus();\n          } else {\n            // focus to the first button in the menu\n            input = this.frame.querySelector('button');\n\n            if (input) {\n              input.focus();\n            }\n          }\n        };\n        /**\n         * Remove the root node from the editor\n         */\n\n\n        treemode.clear = function () {\n          if (this.node) {\n            this.node.hide();\n            delete this.node;\n          }\n\n          if (this.treePath) {\n            this.treePath.reset();\n          }\n        };\n        /**\n         * Set the root node for the json editor\n         * @param {Node} node\n         * @private\n         */\n\n\n        treemode._setRoot = function (node) {\n          this.clear();\n          this.node = node;\n          node.setParent(null);\n          node.setField(this.getName(), false);\n          delete node.index; // append to the dom\n\n          this.tbody.appendChild(node.getDom());\n        };\n        /**\n         * Search text in all nodes\n         * The nodes will be expanded when the text is found one of its childs,\n         * else it will be collapsed. Searches are case insensitive.\n         * @param {String} text\n         * @return {Object[]} results  Array with nodes containing the search results\n         *                             The result objects contains fields:\n         *                             - {Node} node,\n         *                             - {String} elem  the dom element name where\n         *                                              the result is found ('field' or\n         *                                              'value')\n         */\n\n\n        treemode.search = function (text) {\n          var results;\n\n          if (this.node) {\n            this.content.removeChild(this.table); // Take the table offline\n\n            results = this.node.search(text);\n            this.content.appendChild(this.table); // Put the table online again\n          } else {\n            results = [];\n          }\n\n          return results;\n        };\n        /**\n         * Expand all nodes\n         */\n\n\n        treemode.expandAll = function () {\n          if (this.node) {\n            this.content.removeChild(this.table); // Take the table offline\n\n            this.node.expand();\n            this.content.appendChild(this.table); // Put the table online again\n          }\n        };\n        /**\n         * Collapse all nodes\n         */\n\n\n        treemode.collapseAll = function () {\n          if (this.node) {\n            this.content.removeChild(this.table); // Take the table offline\n\n            this.node.collapse();\n            this.content.appendChild(this.table); // Put the table online again\n          }\n        };\n        /**\n         * The method onChange is called whenever a field or value is changed, created,\n         * deleted, duplicated, etc.\n         * @param {String} action  Change action. Available values: \"editField\",\n         *                         \"editValue\", \"changeType\", \"appendNode\",\n         *                         \"removeNode\", \"duplicateNode\", \"moveNode\", \"expand\",\n         *                         \"collapse\".\n         * @param {Object} params  Object containing parameters describing the change.\n         *                         The parameters in params depend on the action (for\n         *                         example for \"editValue\" the Node, old value, and new\n         *                         value are provided). params contains all information\n         *                         needed to undo or redo the action.\n         * @private\n         */\n\n\n        treemode._onAction = function (action, params) {\n          // add an action to the history\n          if (this.history) {\n            this.history.add(action, params);\n          }\n\n          this._onChange();\n        };\n        /**\n         * Handle a change:\n         * - Validate JSON schema\n         * - Send a callback to the onChange listener if provided\n         * @private\n         */\n\n\n        treemode._onChange = function () {\n          if (this.onChangeDisabled) {\n            return;\n          } // selection can be changed after undo/redo\n\n\n          this.selection = this.getDomSelection(); // validate JSON schema (if configured)\n\n          this._debouncedValidate();\n\n          if (this.treePath) {\n            var selectedNode = this.node && this.selection ? this.node.findNodeByInternalPath(this.selection.path) : this.multiselection ? this.multiselection.nodes[0] : undefined;\n\n            if (selectedNode) {\n              this._updateTreePath(selectedNode.getNodePath());\n            } else {\n              this.treePath.reset();\n            }\n          } // trigger the onChange callback\n\n\n          if (this.options.onChange) {\n            try {\n              this.options.onChange();\n            } catch (err) {\n              console.error('Error in onChange callback: ', err);\n            }\n          } // trigger the onChangeJSON callback\n\n\n          if (this.options.onChangeJSON) {\n            try {\n              this.options.onChangeJSON(this.get());\n            } catch (err) {\n              console.error('Error in onChangeJSON callback: ', err);\n            }\n          } // trigger the onChangeText callback\n\n\n          if (this.options.onChangeText) {\n            try {\n              this.options.onChangeText(this.getText());\n            } catch (err) {\n              console.error('Error in onChangeText callback: ', err);\n            }\n          } // trigger the onClassName callback\n\n\n          if (this.options.onClassName) {\n            this.node.recursivelyUpdateCssClassesOnNodes();\n          } // trigger the onNodeName callback\n\n\n          if (this.options.onNodeName && this.node.childs) {\n            try {\n              this.node.recursivelyUpdateNodeName();\n            } catch (err) {\n              console.error('Error in onNodeName callback: ', err);\n            }\n          }\n        };\n        /**\n         * Validate current JSON object against the configured JSON schema\n         * Throws an exception when no JSON schema is configured\n         */\n\n\n        treemode.validate = function () {\n          var root = this.node;\n\n          if (!root) {\n            // TODO: this should be redundant but is needed on mode switch\n            return;\n          }\n\n          var json = root.getValue(); // execute JSON schema validation\n\n          var schemaErrors = [];\n\n          if (this.validateSchema) {\n            var valid = this.validateSchema(json);\n\n            if (!valid) {\n              // apply all new errors\n              schemaErrors = this.validateSchema.errors.map(function (error) {\n                return Object(util[\"improveSchemaError\"])(error);\n              }).map(function findNode(error) {\n                return {\n                  node: root.findNode(error.dataPath),\n                  error: error\n                };\n              }).filter(function hasNode(entry) {\n                return entry.node != null;\n              });\n            }\n          } // execute custom validation and after than merge and render all errors\n\n\n          try {\n            this.validationSequence++;\n            var me = this;\n            var seq = this.validationSequence;\n\n            this._validateCustom(json).then(function (customValidationErrors) {\n              // only apply when there was no other validation started whilst resolving async results\n              if (seq === me.validationSequence) {\n                var errorNodes = [].concat(schemaErrors, customValidationErrors || []);\n\n                me._renderValidationErrors(errorNodes);\n              }\n            })[\"catch\"](function (err) {\n              console.error(err);\n            });\n          } catch (err) {\n            console.error(err);\n          }\n        };\n\n        treemode._renderValidationErrors = function (errorNodes) {\n          // clear all current errors\n          if (this.errorNodes) {\n            this.errorNodes.forEach(function (node) {\n              node.setError(null);\n            });\n          } // render the new errors\n\n\n          var parentPairs = errorNodes.reduce(function (all, entry) {\n            return entry.node.findParents().filter(function (parent) {\n              return !all.some(function (pair) {\n                return pair[0] === parent;\n              });\n            }).map(function (parent) {\n              return [parent, entry.node];\n            }).concat(all);\n          }, []);\n          this.errorNodes = parentPairs.map(function (pair) {\n            return {\n              node: pair[0],\n              child: pair[1],\n              error: {\n                message: pair[0].type === 'object' ? 'Contains invalid properties' // object\n                : 'Contains invalid items' // array\n\n              }\n            };\n          }).concat(errorNodes).map(function setError(entry) {\n            entry.node.setError(entry.error, entry.child);\n            return entry.node;\n          });\n        };\n        /**\n         * Execute custom validation if configured.\n         *\n         * Returns a promise resolving with the custom errors (or nothing).\n         */\n\n\n        treemode._validateCustom = function (json) {\n          try {\n            if (this.options.onValidate) {\n              var root = this.node;\n              var customValidateResults = this.options.onValidate(json);\n              var resultPromise = Object(util[\"isPromise\"])(customValidateResults) ? customValidateResults : Promise.resolve(customValidateResults);\n              return resultPromise.then(function (customValidationPathErrors) {\n                if (Array.isArray(customValidationPathErrors)) {\n                  return customValidationPathErrors.filter(function (error) {\n                    var valid = Object(util[\"isValidValidationError\"])(error);\n\n                    if (!valid) {\n                      console.warn('Ignoring a custom validation error with invalid structure. ' + 'Expected structure: {path: [...], message: \"...\"}. ' + 'Actual error:', error);\n                    }\n\n                    return valid;\n                  }).map(function (error) {\n                    var node;\n\n                    try {\n                      node = error && error.path ? root.findNodeByPath(error.path) : null;\n                    } catch (err) {// stay silent here, we throw a generic warning if no node is found\n                    }\n\n                    if (!node) {\n                      console.warn('Ignoring validation error: node not found. Path:', error.path, 'Error:', error);\n                    }\n\n                    return {\n                      node: node,\n                      error: error\n                    };\n                  }).filter(function (entry) {\n                    return entry && entry.node && entry.error && entry.error.message;\n                  });\n                } else {\n                  return null;\n                }\n              });\n            }\n          } catch (err) {\n            return Promise.reject(err);\n          }\n\n          return Promise.resolve(null);\n        };\n        /**\n         * Refresh the rendered contents\n         */\n\n\n        treemode.refresh = function () {\n          if (this.node) {\n            this.node.updateDom({\n              recurse: true\n            });\n          }\n        };\n        /**\n         * Start autoscrolling when given mouse position is above the top of the\n         * editor contents, or below the bottom.\n         * @param {Number} mouseY  Absolute mouse position in pixels\n         */\n\n\n        treemode.startAutoScroll = function (mouseY) {\n          var me = this;\n          var content = this.scrollableContent;\n          var top = Object(util[\"getAbsoluteTop\"])(content);\n          var height = content.clientHeight;\n          var bottom = top + height;\n          var margin = 24;\n          var interval = 50; // ms\n\n          if (mouseY < top + margin && content.scrollTop > 0) {\n            this.autoScrollStep = (top + margin - mouseY) / 3;\n          } else if (mouseY > bottom - margin && height + content.scrollTop < content.scrollHeight) {\n            this.autoScrollStep = (bottom - margin - mouseY) / 3;\n          } else {\n            this.autoScrollStep = undefined;\n          }\n\n          if (this.autoScrollStep) {\n            if (!this.autoScrollTimer) {\n              this.autoScrollTimer = setInterval(function () {\n                if (me.autoScrollStep) {\n                  content.scrollTop -= me.autoScrollStep;\n                } else {\n                  me.stopAutoScroll();\n                }\n              }, interval);\n            }\n          } else {\n            this.stopAutoScroll();\n          }\n        };\n        /**\n         * Stop auto scrolling. Only applicable when scrolling\n         */\n\n\n        treemode.stopAutoScroll = function () {\n          if (this.autoScrollTimer) {\n            clearTimeout(this.autoScrollTimer);\n            delete this.autoScrollTimer;\n          }\n\n          if (this.autoScrollStep) {\n            delete this.autoScrollStep;\n          }\n        };\n        /**\n         * Set the focus to an element in the editor, set text selection, and\n         * set scroll position.\n         * @param {Object} selection  An object containing fields:\n         *                            {Element | undefined} dom     The dom element\n         *                                                          which has focus\n         *                            {Range | TextRange} range     A text selection\n         *                            {Node[]} nodes                Nodes in case of multi selection\n         *                            {Number} scrollTop            Scroll position\n         */\n\n\n        treemode.setDomSelection = function (selection) {\n          if (!selection) {\n            return;\n          }\n\n          if ('scrollTop' in selection && this.scrollableContent) {\n            // TODO: animated scroll\n            this.scrollableContent.scrollTop = selection.scrollTop;\n          }\n\n          if (selection.paths) {\n            // multi-select\n            var me = this;\n            var nodes = selection.paths.map(function (path) {\n              return me.node.findNodeByInternalPath(path);\n            });\n            this.select(nodes);\n          } else {\n            // find the actual DOM element where to apply the focus\n            var node = selection.path ? this.node.findNodeByInternalPath(selection.path) : null;\n            var container = node && selection.domName ? node.dom[selection.domName] : null;\n\n            if (selection.range && container) {\n              var range = Object.assign({}, selection.range, {\n                container: container\n              });\n              Object(util[\"setSelectionOffset\"])(range);\n            } else if (node) {\n              // just a fallback\n              node.focus();\n            }\n          }\n        };\n        /**\n         * Get the current focus\n         * @return {Object} selection An object containing fields:\n         *                            {Element | undefined} dom     The dom element\n         *                                                          which has focus\n         *                            {Range | TextRange} range     A text selection\n         *                            {Node[]} nodes                Nodes in case of multi selection\n         *                            {Number} scrollTop            Scroll position\n         */\n\n\n        treemode.getDomSelection = function () {\n          // find the node and field name of the current target,\n          // so we can store the current selection in a serializable\n          // way (internal node path and domName)\n          var node = Node_Node.getNodeFromTarget(this.focusTarget);\n          var focusTarget = this.focusTarget;\n          var domName = node ? Object.keys(node.dom).find(function (domName) {\n            return node.dom[domName] === focusTarget;\n          }) : null;\n          var range = Object(util[\"getSelectionOffset\"])();\n\n          if (range && range.container.nodeName !== 'DIV') {\n            // filter on (editable) divs)\n            range = null;\n          }\n\n          if (range && range.container !== focusTarget) {\n            range = null;\n          }\n\n          if (range) {\n            // we cannot rely on the current instance of the container,\n            // we need to store the internal node path and field and\n            // find the actual DOM field when applying the selection\n            delete range.container;\n          }\n\n          return {\n            path: node ? node.getInternalPath() : null,\n            domName: domName,\n            range: range,\n            paths: this.multiselection.length > 0 ? this.multiselection.nodes.map(function (node) {\n              return node.getInternalPath();\n            }) : null,\n            scrollTop: this.scrollableContent ? this.scrollableContent.scrollTop : 0\n          };\n        };\n        /**\n         * Adjust the scroll position such that given top position is shown at 1/4\n         * of the window height.\n         * @param {Number} top\n         * @param {function(boolean)} [animateCallback] Callback, executed when animation is\n         *                                              finished. The callback returns true\n         *                                              when animation is finished, or false\n         *                                              when not.\n         */\n\n\n        treemode.scrollTo = function (top, animateCallback) {\n          var content = this.scrollableContent;\n\n          if (content) {\n            var editor = this; // cancel any running animation\n\n            if (editor.animateTimeout) {\n              clearTimeout(editor.animateTimeout);\n              delete editor.animateTimeout;\n            }\n\n            if (editor.animateCallback) {\n              editor.animateCallback(false);\n              delete editor.animateCallback;\n            } // calculate final scroll position\n\n\n            var height = content.clientHeight;\n            var bottom = content.scrollHeight - height;\n            var finalScrollTop = Math.min(Math.max(top - height / 4, 0), bottom); // animate towards the new scroll position\n\n            var animate = function animate() {\n              var scrollTop = content.scrollTop;\n              var diff = finalScrollTop - scrollTop;\n\n              if (Math.abs(diff) > 3) {\n                content.scrollTop += diff / 3;\n                editor.animateCallback = animateCallback;\n                editor.animateTimeout = setTimeout(animate, 50);\n              } else {\n                // finished\n                if (animateCallback) {\n                  animateCallback(true);\n                }\n\n                content.scrollTop = finalScrollTop;\n                delete editor.animateTimeout;\n                delete editor.animateCallback;\n              }\n            };\n\n            animate();\n          } else {\n            if (animateCallback) {\n              animateCallback(false);\n            }\n          }\n        };\n        /**\n         * Create main frame\n         * @private\n         */\n\n\n        treemode._createFrame = function () {\n          // create the frame\n          this.frame = document.createElement('div');\n          this.frame.className = 'jsoneditor jsoneditor-mode-' + this.options.mode;\n          this.container.appendChild(this.frame);\n          this.contentOuter = document.createElement('div');\n          this.contentOuter.className = 'jsoneditor-outer'; // create one global event listener to handle all events from all nodes\n\n          var editor = this;\n\n          function onEvent(event) {\n            // when switching to mode \"code\" or \"text\" via the menu, some events\n            // are still fired whilst the _onEvent methods is already removed.\n            if (editor._onEvent) {\n              editor._onEvent(event);\n            }\n          }\n\n          this.frame.onclick = function (event) {\n            var target = event.target; // || event.srcElement;\n\n            onEvent(event); // prevent default submit action of buttons when editor is located\n            // inside a form\n\n            if (target.nodeName === 'BUTTON') {\n              event.preventDefault();\n            }\n          };\n\n          this.frame.oninput = onEvent;\n          this.frame.onchange = onEvent;\n          this.frame.onkeydown = onEvent;\n          this.frame.onkeyup = onEvent;\n          this.frame.oncut = onEvent;\n          this.frame.onpaste = onEvent;\n          this.frame.onmousedown = onEvent;\n          this.frame.onmouseup = onEvent;\n          this.frame.onmouseover = onEvent;\n          this.frame.onmouseout = onEvent; // Note: focus and blur events do not propagate, therefore they defined\n          // using an eventListener with useCapture=true\n          // see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html\n\n          Object(util[\"addEventListener\"])(this.frame, 'focus', onEvent, true);\n          Object(util[\"addEventListener\"])(this.frame, 'blur', onEvent, true);\n          this.frame.onfocusin = onEvent; // for IE\n\n          this.frame.onfocusout = onEvent; // for IE\n\n          if (this.options.mainMenuBar) {\n            Object(util[\"addClassName\"])(this.contentOuter, 'has-main-menu-bar'); // create menu\n\n            this.menu = document.createElement('div');\n            this.menu.className = 'jsoneditor-menu';\n            this.frame.appendChild(this.menu); // create expand all button\n\n            var expandAll = document.createElement('button');\n            expandAll.type = 'button';\n            expandAll.className = 'jsoneditor-expand-all';\n            expandAll.title = Object(i18n[\"c\"\n            /* translate */\n            ])('expandAll');\n\n            expandAll.onclick = function () {\n              editor.expandAll();\n            };\n\n            this.menu.appendChild(expandAll); // create collapse all button\n\n            var collapseAll = document.createElement('button');\n            collapseAll.type = 'button';\n            collapseAll.title = Object(i18n[\"c\"\n            /* translate */\n            ])('collapseAll');\n            collapseAll.className = 'jsoneditor-collapse-all';\n\n            collapseAll.onclick = function () {\n              editor.collapseAll();\n            };\n\n            this.menu.appendChild(collapseAll); // create sort button\n\n            if (this.options.enableSort) {\n              var sort = document.createElement('button');\n              sort.type = 'button';\n              sort.className = 'jsoneditor-sort';\n              sort.title = Object(i18n[\"c\"\n              /* translate */\n              ])('sortTitleShort');\n\n              sort.onclick = function () {\n                editor.node.showSortModal();\n              };\n\n              this.menu.appendChild(sort);\n            } // create transform button\n\n\n            if (this.options.enableTransform) {\n              var transform = document.createElement('button');\n              transform.type = 'button';\n              transform.title = Object(i18n[\"c\"\n              /* translate */\n              ])('transformTitleShort');\n              transform.className = 'jsoneditor-transform';\n\n              transform.onclick = function () {\n                editor.node.showTransformModal();\n              };\n\n              this.menu.appendChild(transform);\n            } // create undo/redo buttons\n\n\n            if (this.history) {\n              // create undo button\n              var undo = document.createElement('button');\n              undo.type = 'button';\n              undo.className = 'jsoneditor-undo jsoneditor-separator';\n              undo.title = Object(i18n[\"c\"\n              /* translate */\n              ])('undo');\n\n              undo.onclick = function () {\n                editor._onUndo();\n              };\n\n              this.menu.appendChild(undo);\n              this.dom.undo = undo; // create redo button\n\n              var redo = document.createElement('button');\n              redo.type = 'button';\n              redo.className = 'jsoneditor-redo';\n              redo.title = Object(i18n[\"c\"\n              /* translate */\n              ])('redo');\n\n              redo.onclick = function () {\n                editor._onRedo();\n              };\n\n              this.menu.appendChild(redo);\n              this.dom.redo = redo; // register handler for onchange of history\n\n              this.history.onChange = function () {\n                undo.disabled = !editor.history.canUndo();\n                redo.disabled = !editor.history.canRedo();\n              };\n\n              this.history.onChange();\n            } // create mode box\n\n\n            if (this.options && this.options.modes && this.options.modes.length) {\n              var me = this;\n              this.modeSwitcher = new ModeSwitcher[\"a\"\n              /* ModeSwitcher */\n              ](this.menu, this.options.modes, this.options.mode, function onSwitch(mode) {\n                // switch mode and restore focus\n                me.setMode(mode);\n                me.modeSwitcher.focus();\n              });\n            } // create search box\n\n\n            if (this.options.search) {\n              this.searchBox = new SearchBox(this, this.menu);\n            }\n          }\n\n          if (this.options.navigationBar) {\n            // create second menu row for treepath\n            this.navBar = document.createElement('div');\n            this.navBar.className = 'jsoneditor-navigation-bar nav-bar-empty';\n            this.frame.appendChild(this.navBar);\n            this.treePath = new TreePath_TreePath(this.navBar, this.frame);\n            this.treePath.onSectionSelected(this._onTreePathSectionSelected.bind(this));\n            this.treePath.onContextMenuItemSelected(this._onTreePathMenuItemSelected.bind(this));\n          }\n        };\n        /**\n         * Perform an undo action\n         * @private\n         */\n\n\n        treemode._onUndo = function () {\n          if (this.history) {\n            // undo last action\n            this.history.undo(); // fire change event\n\n            this._onChange();\n          }\n        };\n        /**\n         * Perform a redo action\n         * @private\n         */\n\n\n        treemode._onRedo = function () {\n          if (this.history) {\n            // redo last action\n            this.history.redo(); // fire change event\n\n            this._onChange();\n          }\n        };\n        /**\n         * Event handler\n         * @param event\n         * @private\n         */\n\n\n        treemode._onEvent = function (event) {\n          // don't process events when coming from the color picker\n          if (Node_Node.targetIsColorPicker(event.target)) {\n            return;\n          }\n\n          var node = Node_Node.getNodeFromTarget(event.target);\n\n          if (event.type === 'keydown') {\n            this._onKeyDown(event);\n          }\n\n          if (node && event.type === 'focus') {\n            this.focusTarget = event.target;\n\n            if (this.options.autocomplete && this.options.autocomplete.trigger === 'focus') {\n              this._showAutoComplete(event.target);\n            }\n          }\n\n          if (event.type === 'mousedown') {\n            this._startDragDistance(event);\n          }\n\n          if (event.type === 'mousemove' || event.type === 'mouseup' || event.type === 'click') {\n            this._updateDragDistance(event);\n          }\n\n          if (node && this.options && this.options.navigationBar && node && (event.type === 'keydown' || event.type === 'mousedown')) {\n            // apply on next tick, right after the new key press is applied\n            var me = this;\n            setTimeout(function () {\n              me._updateTreePath(node.getNodePath());\n            });\n          }\n\n          if (node && node.selected) {\n            if (event.type === 'click') {\n              if (event.target === node.dom.menu) {\n                this.showContextMenu(event.target); // stop propagation (else we will open the context menu of a single node)\n\n                return;\n              } // deselect a multi selection\n\n\n              if (!event.hasMoved) {\n                this.deselect();\n              }\n            }\n\n            if (event.type === 'mousedown') {\n              // drag multiple nodes\n              Node_Node.onDragStart(this.multiselection.nodes, event);\n            }\n          } else {\n            // filter mouse events in the contents part of the editor (not the main menu)\n            if (event.type === 'mousedown' && Object(util[\"hasParentNode\"])(event.target, this.content)) {\n              this.deselect();\n\n              if (node && event.target === node.dom.drag) {\n                // drag a singe node\n                Node_Node.onDragStart(node, event);\n              } else if (!node || event.target !== node.dom.field && event.target !== node.dom.value && event.target !== node.dom.select) {\n                // select multiple nodes\n                this._onMultiSelectStart(event);\n              }\n            }\n          }\n\n          if (node) {\n            node.onEvent(event);\n          }\n        };\n        /**\n         * Update TreePath components\n         * @param {Array<Node>} pathNodes list of nodes in path from root to selection\n         * @private\n         */\n\n\n        treemode._updateTreePath = function (pathNodes) {\n          if (pathNodes && pathNodes.length) {\n            Object(util[\"removeClassName\"])(this.navBar, 'nav-bar-empty');\n            var pathObjs = [];\n            pathNodes.forEach(function (node) {\n              var pathObj = {\n                name: getName(node),\n                node: node,\n                children: []\n              };\n\n              if (node.childs && node.childs.length) {\n                node.childs.forEach(function (childNode) {\n                  pathObj.children.push({\n                    name: getName(childNode),\n                    node: childNode\n                  });\n                });\n              }\n\n              pathObjs.push(pathObj);\n            });\n            this.treePath.setPath(pathObjs);\n          } else {\n            Object(util[\"addClassName\"])(this.navBar, 'nav-bar-empty');\n          }\n\n          function getName(node) {\n            return node.parent ? node.parent.type === 'array' ? node.index : node.field : node.type;\n          }\n        };\n        /**\n         * Callback for tree path section selection - focus the selected node in the tree\n         * @param {Object} pathObj path object that was represents the selected section node\n         * @private\n         */\n\n\n        treemode._onTreePathSectionSelected = function (pathObj) {\n          if (pathObj && pathObj.node) {\n            pathObj.node.expandTo();\n            pathObj.node.focus();\n          }\n        };\n        /**\n         * Callback for tree path menu item selection - rebuild the path accrding to the new selection and focus the selected node in the tree\n         * @param {Object} pathObj path object that was represents the parent section node\n         * @param {String} selection selected section child\n         * @private\n         */\n\n\n        treemode._onTreePathMenuItemSelected = function (pathObj, selection) {\n          if (pathObj && pathObj.children.length) {\n            var selectionObj = pathObj.children.find(function (obj) {\n              return obj.name === selection;\n            });\n\n            if (selectionObj && selectionObj.node) {\n              this._updateTreePath(selectionObj.node.getNodePath());\n\n              selectionObj.node.expandTo();\n              selectionObj.node.focus();\n            }\n          }\n        };\n\n        treemode._startDragDistance = function (event) {\n          this.dragDistanceEvent = {\n            initialTarget: event.target,\n            initialPageX: event.pageX,\n            initialPageY: event.pageY,\n            dragDistance: 0,\n            hasMoved: false\n          };\n        };\n\n        treemode._updateDragDistance = function (event) {\n          if (!this.dragDistanceEvent) {\n            this._startDragDistance(event);\n          }\n\n          var diffX = event.pageX - this.dragDistanceEvent.initialPageX;\n          var diffY = event.pageY - this.dragDistanceEvent.initialPageY;\n          this.dragDistanceEvent.dragDistance = Math.sqrt(diffX * diffX + diffY * diffY);\n          this.dragDistanceEvent.hasMoved = this.dragDistanceEvent.hasMoved || this.dragDistanceEvent.dragDistance > 10;\n          event.dragDistance = this.dragDistanceEvent.dragDistance;\n          event.hasMoved = this.dragDistanceEvent.hasMoved;\n          return event.dragDistance;\n        };\n        /**\n         * Start multi selection of nodes by dragging the mouse\n         * @param event\n         * @private\n         */\n\n\n        treemode._onMultiSelectStart = function (event) {\n          var node = Node_Node.getNodeFromTarget(event.target);\n\n          if (this.options.mode !== 'tree' || this.options.onEditable !== undefined) {\n            // dragging not allowed in modes 'view' and 'form'\n            // TODO: allow multiselection of items when option onEditable is specified\n            return;\n          }\n\n          this.multiselection = {\n            start: node || null,\n            end: null,\n            nodes: []\n          };\n\n          this._startDragDistance(event);\n\n          var editor = this;\n\n          if (!this.mousemove) {\n            this.mousemove = Object(util[\"addEventListener\"])(window, 'mousemove', function (event) {\n              editor._onMultiSelect(event);\n            });\n          }\n\n          if (!this.mouseup) {\n            this.mouseup = Object(util[\"addEventListener\"])(window, 'mouseup', function (event) {\n              editor._onMultiSelectEnd(event);\n            });\n          }\n\n          event.preventDefault();\n        };\n        /**\n         * Multiselect nodes by dragging\n         * @param event\n         * @private\n         */\n\n\n        treemode._onMultiSelect = function (event) {\n          event.preventDefault();\n\n          this._updateDragDistance(event);\n\n          if (!event.hasMoved) {\n            return;\n          }\n\n          var node = Node_Node.getNodeFromTarget(event.target);\n\n          if (node) {\n            if (this.multiselection.start == null) {\n              this.multiselection.start = node;\n            }\n\n            this.multiselection.end = node;\n          } // deselect previous selection\n\n\n          this.deselect(); // find the selected nodes in the range from first to last\n\n          var start = this.multiselection.start;\n          var end = this.multiselection.end || this.multiselection.start;\n\n          if (start && end) {\n            // find the top level childs, all having the same parent\n            this.multiselection.nodes = this._findTopLevelNodes(start, end);\n\n            if (this.multiselection.nodes && this.multiselection.nodes.length) {\n              var firstNode = this.multiselection.nodes[0];\n\n              if (this.multiselection.start === firstNode || this.multiselection.start.isDescendantOf(firstNode)) {\n                this.multiselection.direction = 'down';\n              } else {\n                this.multiselection.direction = 'up';\n              }\n            }\n\n            this.select(this.multiselection.nodes);\n          }\n        };\n        /**\n         * End of multiselect nodes by dragging\n         * @private\n         */\n\n\n        treemode._onMultiSelectEnd = function () {\n          // set focus to the context menu button of the first node\n          if (this.multiselection.nodes[0]) {\n            this.multiselection.nodes[0].dom.menu.focus();\n          }\n\n          this.multiselection.start = null;\n          this.multiselection.end = null; // cleanup global event listeners\n\n          if (this.mousemove) {\n            Object(util[\"removeEventListener\"])(window, 'mousemove', this.mousemove);\n            delete this.mousemove;\n          }\n\n          if (this.mouseup) {\n            Object(util[\"removeEventListener\"])(window, 'mouseup', this.mouseup);\n            delete this.mouseup;\n          }\n        };\n        /**\n         * deselect currently selected nodes\n         * @param {boolean} [clearStartAndEnd=false]  If true, the `start` and `end`\n         *                                            state is cleared too.\n         */\n\n\n        treemode.deselect = function (clearStartAndEnd) {\n          var selectionChanged = !!this.multiselection.nodes.length;\n          this.multiselection.nodes.forEach(function (node) {\n            node.setSelected(false);\n          });\n          this.multiselection.nodes = [];\n\n          if (clearStartAndEnd) {\n            this.multiselection.start = null;\n            this.multiselection.end = null;\n          }\n\n          if (selectionChanged) {\n            if (this._selectionChangedHandler) {\n              this._selectionChangedHandler();\n            }\n          }\n        };\n        /**\n         * select nodes\n         * @param {Node[] | Node} nodes\n         */\n\n\n        treemode.select = function (nodes) {\n          if (!Array.isArray(nodes)) {\n            return this.select([nodes]);\n          }\n\n          if (nodes) {\n            this.deselect();\n            this.multiselection.nodes = nodes.slice(0);\n            var first = nodes[0];\n            nodes.forEach(function (node) {\n              node.expandPathToNode();\n              node.setSelected(true, node === first);\n            });\n\n            if (this._selectionChangedHandler) {\n              var selection = this.getSelection();\n\n              this._selectionChangedHandler(selection.start, selection.end);\n            }\n          }\n        };\n        /**\n         * From two arbitrary selected nodes, find their shared parent node.\n         * From that parent node, select the two child nodes in the brances going to\n         * nodes `start` and `end`, and select all childs in between.\n         * @param {Node} start\n         * @param {Node} end\n         * @return {Array.<Node>} Returns an ordered list with child nodes\n         * @private\n         */\n\n\n        treemode._findTopLevelNodes = function (start, end) {\n          var startPath = start.getNodePath();\n          var endPath = end.getNodePath();\n          var i = 0;\n\n          while (i < startPath.length && startPath[i] === endPath[i]) {\n            i++;\n          }\n\n          var root = startPath[i - 1];\n          var startChild = startPath[i];\n          var endChild = endPath[i];\n\n          if (!startChild || !endChild) {\n            if (root.parent) {\n              // startChild is a parent of endChild or vice versa\n              startChild = root;\n              endChild = root;\n              root = root.parent;\n            } else {\n              // we have selected the root node (which doesn't have a parent)\n              startChild = root.childs[0];\n              endChild = root.childs[root.childs.length - 1];\n            }\n          }\n\n          if (root && startChild && endChild) {\n            var startIndex = root.childs.indexOf(startChild);\n            var endIndex = root.childs.indexOf(endChild);\n            var firstIndex = Math.min(startIndex, endIndex);\n            var lastIndex = Math.max(startIndex, endIndex);\n            return root.childs.slice(firstIndex, lastIndex + 1);\n          } else {\n            return [];\n          }\n        };\n        /**\n         * Show autocomplete menu\n         * @param {HTMLElement} element\n         * @private\n         */\n\n\n        treemode._showAutoComplete = function (element) {\n          var node = Node_Node.getNodeFromTarget(element);\n          var jsonElementType = '';\n          if (element.className.indexOf('jsoneditor-value') >= 0) jsonElementType = 'value';\n          if (element.className.indexOf('jsoneditor-field') >= 0) jsonElementType = 'field';\n          var self = this;\n          setTimeout(function () {\n            if (node && (self.options.autocomplete.trigger === 'focus' || element.innerText.length > 0)) {\n              var result = self.options.autocomplete.getOptions(element.innerText, node.getPath(), jsonElementType, node.editor);\n\n              if (result === null) {\n                self.autocomplete.hideDropDown();\n              } else if (typeof result.then === 'function') {\n                // probably a promise\n                result.then(function (obj) {\n                  if (obj === null) {\n                    self.autocomplete.hideDropDown();\n                  } else if (obj.options) {\n                    self.autocomplete.show(element, obj.startFrom, obj.options);\n                  } else {\n                    self.autocomplete.show(element, 0, obj);\n                  }\n                })[\"catch\"](function (err) {\n                  console.error(err);\n                });\n              } else {\n                // definitely not a promise\n                if (result.options) {\n                  self.autocomplete.show(element, result.startFrom, result.options);\n                } else {\n                  self.autocomplete.show(element, 0, result);\n                }\n              }\n            } else {\n              self.autocomplete.hideDropDown();\n            }\n          }, 50);\n        };\n        /**\n         * Event handler for keydown. Handles shortcut keys\n         * @param {Event} event\n         * @private\n         */\n\n\n        treemode._onKeyDown = function (event) {\n          var keynum = event.which || event.keyCode;\n          var altKey = event.altKey;\n          var ctrlKey = event.ctrlKey;\n          var metaKey = event.metaKey;\n          var shiftKey = event.shiftKey;\n          var handled = false;\n\n          if (keynum === 9) {\n            // Tab or Shift+Tab\n            var me = this;\n            setTimeout(function () {\n              // select all text when moving focus to an editable div\n              Object(util[\"selectContentEditable\"])(me.focusTarget);\n            }, 0);\n          }\n\n          if (this.searchBox) {\n            if (ctrlKey && keynum === 70) {\n              // Ctrl+F\n              this.searchBox.dom.search.focus();\n              this.searchBox.dom.search.select();\n              handled = true;\n            } else if (keynum === 114 || ctrlKey && keynum === 71) {\n              // F3 or Ctrl+G\n              var focus = true;\n\n              if (!shiftKey) {\n                // select next search result (F3 or Ctrl+G)\n                this.searchBox.next(focus);\n              } else {\n                // select previous search result (Shift+F3 or Ctrl+Shift+G)\n                this.searchBox.previous(focus);\n              }\n\n              handled = true;\n            }\n          }\n\n          if (this.history) {\n            if (ctrlKey && !shiftKey && keynum === 90) {\n              // Ctrl+Z\n              // undo\n              this._onUndo();\n\n              handled = true;\n            } else if (ctrlKey && shiftKey && keynum === 90) {\n              // Ctrl+Shift+Z\n              // redo\n              this._onRedo();\n\n              handled = true;\n            }\n          }\n\n          if (this.options.autocomplete && !handled) {\n            if (!ctrlKey && !altKey && !metaKey && (event.key.length === 1 || keynum === 8 || keynum === 46)) {\n              handled = false; // Activate autocomplete\n\n              this._showAutoComplete(event.target);\n            }\n          }\n\n          if (handled) {\n            event.preventDefault();\n            event.stopPropagation();\n          }\n        };\n        /**\n         * Create main table\n         * @private\n         */\n\n\n        treemode._createTable = function () {\n          if (this.options.navigationBar) {\n            Object(util[\"addClassName\"])(this.contentOuter, 'has-nav-bar');\n          }\n\n          this.scrollableContent = document.createElement('div');\n          this.scrollableContent.className = 'jsoneditor-tree';\n          this.contentOuter.appendChild(this.scrollableContent); // the jsoneditor-tree-inner div with bottom padding is here to\n          // keep space for the action menu dropdown. It's created as a\n          // separate div instead of using scrollableContent to work around\n          // and issue in the Chrome browser showing scrollable contents outside of the div\n          // see https://github.com/josdejong/jsoneditor/issues/557\n\n          this.content = document.createElement('div');\n          this.content.className = 'jsoneditor-tree-inner';\n          this.scrollableContent.appendChild(this.content);\n          this.table = document.createElement('table');\n          this.table.className = 'jsoneditor-tree';\n          this.content.appendChild(this.table); // create colgroup where the first two columns don't have a fixed\n          // width, and the edit columns do have a fixed width\n\n          var col;\n          this.colgroupContent = document.createElement('colgroup');\n\n          if (this.options.mode === 'tree') {\n            col = document.createElement('col');\n            col.width = '24px';\n            this.colgroupContent.appendChild(col);\n          }\n\n          col = document.createElement('col');\n          col.width = '24px';\n          this.colgroupContent.appendChild(col);\n          col = document.createElement('col');\n          this.colgroupContent.appendChild(col);\n          this.table.appendChild(this.colgroupContent);\n          this.tbody = document.createElement('tbody');\n          this.table.appendChild(this.tbody);\n          this.frame.appendChild(this.contentOuter);\n        };\n        /**\n         * Show a contextmenu for this node.\n         * Used for multiselection\n         * @param {HTMLElement} anchor   Anchor element to attach the context menu to.\n         * @param {function} [onClose]   Callback method called when the context menu\n         *                               is being closed.\n         */\n\n\n        treemode.showContextMenu = function (anchor, onClose) {\n          var items = [];\n          var selectedNodes = this.multiselection.nodes.slice(); // create duplicate button\n\n          items.push({\n            text: Object(i18n[\"c\"\n            /* translate */\n            ])('duplicateText'),\n            title: Object(i18n[\"c\"\n            /* translate */\n            ])('duplicateTitle'),\n            className: 'jsoneditor-duplicate',\n            click: function click() {\n              Node_Node.onDuplicate(selectedNodes);\n            }\n          }); // create remove button\n\n          items.push({\n            text: Object(i18n[\"c\"\n            /* translate */\n            ])('remove'),\n            title: Object(i18n[\"c\"\n            /* translate */\n            ])('removeTitle'),\n            className: 'jsoneditor-remove',\n            click: function click() {\n              Node_Node.onRemove(selectedNodes);\n            }\n          });\n\n          if (this.options.onCreateMenu) {\n            var paths = selectedNodes.map(function (node) {\n              return node.getPath();\n            });\n            items = this.options.onCreateMenu(items, {\n              type: 'multiple',\n              path: paths[0],\n              paths: paths\n            });\n          }\n\n          var menu = new ContextMenu[\"a\"\n          /* ContextMenu */\n          ](items, {\n            close: onClose\n          });\n          menu.show(anchor, this.frame);\n        };\n        /**\n         * Get current selected nodes\n         * @return {{start:SerializableNode, end: SerializableNode}}\n         */\n\n\n        treemode.getSelection = function () {\n          var selection = {\n            start: null,\n            end: null\n          };\n\n          if (this.multiselection.nodes && this.multiselection.nodes.length) {\n            if (this.multiselection.nodes.length) {\n              var selection1 = this.multiselection.nodes[0];\n              var selection2 = this.multiselection.nodes[this.multiselection.nodes.length - 1];\n\n              if (this.multiselection.direction === 'down') {\n                selection.start = selection1.serialize();\n                selection.end = selection2.serialize();\n              } else {\n                selection.start = selection2.serialize();\n                selection.end = selection1.serialize();\n              }\n            }\n          }\n\n          return selection;\n        };\n        /**\n         * Callback registration for selection change\n         * @param {selectionCallback} callback\n         *\n         * @callback selectionCallback\n         */\n\n\n        treemode.onSelectionChange = function (callback) {\n          if (typeof callback === 'function') {\n            this._selectionChangedHandler = Object(util[\"debounce\"])(callback, this.DEBOUNCE_INTERVAL);\n          }\n        };\n        /**\n         * Select range of nodes.\n         * For selecting single node send only the start parameter\n         * For clear the selection do not send any parameter\n         * If the nodes are not from the same level the first common parent will be selected\n         * @param {{path: Array.<String>}} start object contains the path for selection start\n         * @param {{path: Array.<String>}} end object contains the path for selection end\n         */\n\n\n        treemode.setSelection = function (start, end) {\n          // check for old usage\n          if (start && start.dom && start.range) {\n            console.warn('setSelection/getSelection usage for text selection is deprecated and should not be used, see documentation for supported selection options');\n            this.setDomSelection(start);\n          }\n\n          var nodes = this._getNodeInstancesByRange(start, end);\n\n          nodes.forEach(function (node) {\n            node.expandTo();\n          });\n          this.select(nodes);\n        };\n        /**\n         * Returns a set of Nodes according to a range of selection\n         * @param {{path: Array.<String>}} start object contains the path for range start\n         * @param {{path: Array.<String>}=} end object contains the path for range end\n         * @return {Array.<Node>} Node instances on the given range\n         * @private\n         */\n\n\n        treemode._getNodeInstancesByRange = function (start, end) {\n          var startNode, endNode;\n\n          if (start && start.path) {\n            startNode = this.node.findNodeByPath(start.path);\n\n            if (end && end.path) {\n              endNode = this.node.findNodeByPath(end.path);\n            }\n          }\n\n          var nodes = [];\n\n          if (startNode instanceof Node_Node) {\n            if (endNode instanceof Node_Node && endNode !== startNode) {\n              if (startNode.parent === endNode.parent) {\n                if (startNode.getIndex() < endNode.getIndex()) {\n                  start = startNode;\n                  end = endNode;\n                } else {\n                  start = endNode;\n                  end = startNode;\n                }\n\n                var current = start;\n                nodes.push(current);\n\n                do {\n                  current = current.nextSibling();\n                  nodes.push(current);\n                } while (current && current !== end);\n              } else {\n                nodes = this._findTopLevelNodes(startNode, endNode);\n              }\n            } else {\n              nodes.push(startNode);\n            }\n          }\n\n          return nodes;\n        };\n\n        treemode.getNodesByRange = function (start, end) {\n          var nodes = this._getNodeInstancesByRange(start, end);\n\n          var serializableNodes = [];\n          nodes.forEach(function (node) {\n            serializableNodes.push(node.serialize());\n          });\n          return serializableNodes;\n        }; // define modes\n\n\n        var treeModeMixins = [{\n          mode: 'tree',\n          mixin: treemode,\n          data: 'json'\n        }, {\n          mode: 'view',\n          mixin: treemode,\n          data: 'json'\n        }, {\n          mode: 'form',\n          mixin: treemode,\n          data: 'json'\n        }];\n        /***/\n      },\n      /* 24 */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        __webpack_require__.r(__webpack_exports__); // EXTERNAL MODULE: ./node_modules/jmespath/jmespath.js\n\n\n        var jmespath = __webpack_require__(4);\n\n        var jmespath_default =\n        /*#__PURE__*/\n        __webpack_require__.n(jmespath); // EXTERNAL MODULE: ./src/js/i18n.js\n\n\n        var i18n = __webpack_require__(1); // EXTERNAL MODULE: ./src/js/ModeSwitcher.js\n\n\n        var ModeSwitcher = __webpack_require__(6); // EXTERNAL MODULE: ./src/js/ErrorTable.js\n\n\n        var ErrorTable = __webpack_require__(13); // EXTERNAL MODULE: ./src/js/showSortModal.js\n\n\n        var showSortModal = __webpack_require__(5); // EXTERNAL MODULE: ./src/js/showTransformModal.js + 1 modules\n\n\n        var showTransformModal = __webpack_require__(7); // EXTERNAL MODULE: ./src/js/textmode.js + 1 modules\n\n\n        var textmode = __webpack_require__(15); // EXTERNAL MODULE: ./src/js/constants.js\n\n\n        var constants = __webpack_require__(2); // EXTERNAL MODULE: ./src/js/util.js\n\n\n        var util = __webpack_require__(0); // CONCATENATED MODULE: ./src/js/History.js\n\n\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        function _defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        function _createClass(Constructor, protoProps, staticProps) {\n          if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) _defineProperties(Constructor, staticProps);\n          return Constructor;\n        }\n        /**\n         * Keep track on any history, be able\n         * @param {function} onChange\n         * @param {function} calculateItemSize\n         * @param {number} limit    Maximum size of all items in history\n         * @constructor\n         */\n\n\n        var History =\n        /*#__PURE__*/\n        function () {\n          function History(onChange, calculateItemSize, limit) {\n            _classCallCheck(this, History);\n\n            this.onChange = onChange;\n\n            this.calculateItemSize = calculateItemSize || function () {\n              return 1;\n            };\n\n            this.limit = limit;\n            this.items = [];\n            this.index = -1;\n          }\n\n          _createClass(History, [{\n            key: \"add\",\n            value: function add(item) {\n              // limit number of items in history so that the total size doesn't\n              // always keep at least one item in memory\n              while (this._calculateHistorySize() > this.limit && this.items.length > 1) {\n                this.items.shift();\n                this.index--;\n              } // cleanup any redo action that are not valid anymore\n\n\n              this.items = this.items.slice(0, this.index + 1);\n              this.items.push(item);\n              this.index++;\n              this.onChange();\n            }\n          }, {\n            key: \"_calculateHistorySize\",\n            value: function _calculateHistorySize() {\n              var calculateItemSize = this.calculateItemSize;\n              var totalSize = 0;\n              this.items.forEach(function (item) {\n                totalSize += calculateItemSize(item);\n              });\n              return totalSize;\n            }\n          }, {\n            key: \"undo\",\n            value: function undo() {\n              if (!this.canUndo()) {\n                return;\n              }\n\n              this.index--;\n              this.onChange();\n              return this.items[this.index];\n            }\n          }, {\n            key: \"redo\",\n            value: function redo() {\n              if (!this.canRedo()) {\n                return;\n              }\n\n              this.index++;\n              this.onChange();\n              return this.items[this.index];\n            }\n          }, {\n            key: \"canUndo\",\n            value: function canUndo() {\n              return this.index > 0;\n            }\n          }, {\n            key: \"canRedo\",\n            value: function canRedo() {\n              return this.index < this.items.length - 1;\n            }\n          }, {\n            key: \"clear\",\n            value: function clear() {\n              this.items = [];\n              this.index = -1;\n              this.onChange();\n            }\n          }]);\n\n          return History;\n        }(); // CONCATENATED MODULE: ./src/js/previewmode.js\n\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"previewModeMixins\", function () {\n          return previewModeMixins;\n        });\n\n        var previewmode_textmode = textmode[\"textModeMixins\"][0].mixin; // create a mixin with the functions for text mode\n\n        var previewmode = {};\n        /**\n         * Create a JSON document preview, suitable for processing of large documents\n         * @param {Element} container\n         * @param {Object} [options]   Object with options. See docs for details.\n         * @private\n         */\n\n        previewmode.create = function (container) {\n          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n          if (typeof options.statusBar === 'undefined') {\n            options.statusBar = true;\n          } // setting default for previewmode\n\n\n          options.mainMenuBar = options.mainMenuBar !== false;\n          options.enableSort = options.enableSort !== false;\n          options.enableTransform = options.enableTransform !== false;\n          this.options = options; // indentation\n\n          if (options.indentation) {\n            this.indentation = Number(options.indentation);\n          } else {\n            this.indentation = 2; // number of spaces\n          } // determine mode\n\n\n          this.mode = 'preview';\n          var me = this;\n          this.container = container;\n          this.dom = {};\n          this.json = undefined;\n          this.text = ''; // TODO: JSON Schema support\n          // create a debounced validate function\n\n          this._debouncedValidate = Object(util[\"debounce\"])(this.validate.bind(this), this.DEBOUNCE_INTERVAL);\n          this.width = container.clientWidth;\n          this.height = container.clientHeight;\n          this.frame = document.createElement('div');\n          this.frame.className = 'jsoneditor jsoneditor-mode-preview';\n\n          this.frame.onclick = function (event) {\n            // prevent default submit action when the editor is located inside a form\n            event.preventDefault();\n          };\n\n          this.content = document.createElement('div');\n          this.content.className = 'jsoneditor-outer';\n          this.dom.busy = document.createElement('div');\n          this.dom.busy.className = 'jsoneditor-busy';\n          this.dom.busyContent = document.createElement('span');\n          this.dom.busyContent.innerHTML = 'busy...';\n          this.dom.busy.appendChild(this.dom.busyContent);\n          this.content.appendChild(this.dom.busy);\n          this.dom.previewContent = document.createElement('pre');\n          this.dom.previewContent.className = 'jsoneditor-preview';\n          this.dom.previewText = document.createTextNode('');\n          this.dom.previewContent.appendChild(this.dom.previewText);\n          this.content.appendChild(this.dom.previewContent);\n\n          if (this.options.mainMenuBar) {\n            Object(util[\"addClassName\"])(this.content, 'has-main-menu-bar'); // create menu\n\n            this.menu = document.createElement('div');\n            this.menu.className = 'jsoneditor-menu';\n            this.frame.appendChild(this.menu); // create format button\n\n            var buttonFormat = document.createElement('button');\n            buttonFormat.type = 'button';\n            buttonFormat.className = 'jsoneditor-format';\n            buttonFormat.title = 'Format JSON data, with proper indentation and line feeds (Ctrl+\\\\)';\n            this.menu.appendChild(buttonFormat);\n\n            buttonFormat.onclick = function handleFormat() {\n              me.executeWithBusyMessage(function () {\n                try {\n                  me.format();\n                } catch (err) {\n                  me._onError(err);\n                }\n              }, 'formatting...');\n            }; // create compact button\n\n\n            var buttonCompact = document.createElement('button');\n            buttonCompact.type = 'button';\n            buttonCompact.className = 'jsoneditor-compact';\n            buttonCompact.title = 'Compact JSON data, remove all whitespaces (Ctrl+Shift+\\\\)';\n            this.menu.appendChild(buttonCompact);\n\n            buttonCompact.onclick = function handleCompact() {\n              me.executeWithBusyMessage(function () {\n                try {\n                  me.compact();\n                } catch (err) {\n                  me._onError(err);\n                }\n              }, 'compacting...');\n            }; // create sort button\n\n\n            if (this.options.enableSort) {\n              var _sort = document.createElement('button');\n\n              _sort.type = 'button';\n              _sort.className = 'jsoneditor-sort';\n              _sort.title = Object(i18n[\"c\"\n              /* translate */\n              ])('sortTitleShort');\n\n              _sort.onclick = function () {\n                me._showSortModal();\n              };\n\n              this.menu.appendChild(_sort);\n            } // create transform button\n\n\n            if (this.options.enableTransform) {\n              var transform = document.createElement('button');\n              transform.type = 'button';\n              transform.title = Object(i18n[\"c\"\n              /* translate */\n              ])('transformTitleShort');\n              transform.className = 'jsoneditor-transform';\n\n              transform.onclick = function () {\n                me._showTransformModal();\n              };\n\n              this.dom.transform = transform;\n              this.menu.appendChild(transform);\n            } // create repair button\n\n\n            var buttonRepair = document.createElement('button');\n            buttonRepair.type = 'button';\n            buttonRepair.className = 'jsoneditor-repair';\n            buttonRepair.title = 'Repair JSON: fix quotes and escape characters, remove comments and JSONP notation, turn JavaScript objects into JSON.';\n            this.menu.appendChild(buttonRepair);\n\n            buttonRepair.onclick = function () {\n              if (me.json === undefined) {\n                // only repair if we don't have valid JSON\n                me.executeWithBusyMessage(function () {\n                  try {\n                    me.repair();\n                  } catch (err) {\n                    me._onError(err);\n                  }\n                }, 'repairing...');\n              }\n            }; // create history and undo/redo buttons\n\n\n            if (this.options.history !== false) {\n              // default option value is true\n              var onHistoryChange = function onHistoryChange() {\n                me.dom.undo.disabled = !me.history.canUndo();\n                me.dom.redo.disabled = !me.history.canRedo();\n              };\n\n              var calculateItemSize = function calculateItemSize(item) {\n                return (// times two to account for the json object\n                  item.text.length * 2\n                );\n              };\n\n              this.history = new History(onHistoryChange, calculateItemSize, constants[\"c\"\n              /* PREVIEW_HISTORY_LIMIT */\n              ]); // create undo button\n\n              var undo = document.createElement('button');\n              undo.type = 'button';\n              undo.className = 'jsoneditor-undo jsoneditor-separator';\n              undo.title = Object(i18n[\"c\"\n              /* translate */\n              ])('undo');\n\n              undo.onclick = function () {\n                var action = me.history.undo();\n\n                if (action) {\n                  me._applyHistory(action);\n                }\n              };\n\n              this.menu.appendChild(undo);\n              this.dom.undo = undo; // create redo button\n\n              var redo = document.createElement('button');\n              redo.type = 'button';\n              redo.className = 'jsoneditor-redo';\n              redo.title = Object(i18n[\"c\"\n              /* translate */\n              ])('redo');\n\n              redo.onclick = function () {\n                var action = me.history.redo();\n\n                if (action) {\n                  me._applyHistory(action);\n                }\n              };\n\n              this.menu.appendChild(redo);\n              this.dom.redo = redo; // force enabling/disabling the undo/redo button\n\n              this.history.onChange();\n            } // create mode box\n\n\n            if (this.options && this.options.modes && this.options.modes.length) {\n              this.modeSwitcher = new ModeSwitcher[\"a\"\n              /* ModeSwitcher */\n              ](this.menu, this.options.modes, this.options.mode, function onSwitch(mode) {\n                // switch mode and restore focus\n                me.setMode(mode);\n                me.modeSwitcher.focus();\n              });\n            }\n          }\n\n          this.errorTable = new ErrorTable[\"a\"\n          /* ErrorTable */\n          ]({\n            errorTableVisible: true,\n            onToggleVisibility: function onToggleVisibility() {\n              me.validate();\n            },\n            onFocusLine: null,\n            onChangeHeight: function onChangeHeight(height) {\n              // TODO: change CSS to using flex box, remove setting height using JavaScript\n              var statusBarHeight = me.dom.statusBar ? me.dom.statusBar.clientHeight : 0;\n              var totalHeight = height + statusBarHeight + 1;\n              me.content.style.marginBottom = -totalHeight + 'px';\n              me.content.style.paddingBottom = totalHeight + 'px';\n            }\n          });\n          this.frame.appendChild(this.content);\n          this.frame.appendChild(this.errorTable.getErrorTable());\n          this.container.appendChild(this.frame);\n\n          if (options.statusBar) {\n            Object(util[\"addClassName\"])(this.content, 'has-status-bar');\n            var statusBar = document.createElement('div');\n            this.dom.statusBar = statusBar;\n            statusBar.className = 'jsoneditor-statusbar';\n            this.frame.appendChild(statusBar);\n            this.dom.fileSizeInfo = document.createElement('span');\n            this.dom.fileSizeInfo.className = 'jsoneditor-size-info';\n            this.dom.fileSizeInfo.innerText = '';\n            statusBar.appendChild(this.dom.fileSizeInfo);\n            this.dom.arrayInfo = document.createElement('span');\n            this.dom.arrayInfo.className = 'jsoneditor-size-info';\n            this.dom.arrayInfo.innerText = '';\n            statusBar.appendChild(this.dom.arrayInfo);\n            statusBar.appendChild(this.errorTable.getErrorCounter());\n            statusBar.appendChild(this.errorTable.getWarningIcon());\n            statusBar.appendChild(this.errorTable.getErrorIcon());\n          }\n\n          this._renderPreview();\n\n          this.setSchema(this.options.schema, this.options.schemaRefs);\n        };\n\n        previewmode._renderPreview = function () {\n          var text = this.getText();\n          this.dom.previewText.nodeValue = Object(util[\"limitCharacters\"])(text, constants[\"b\"\n          /* MAX_PREVIEW_CHARACTERS */\n          ]);\n\n          if (this.dom.fileSizeInfo) {\n            this.dom.fileSizeInfo.innerText = 'Size: ' + Object(util[\"formatSize\"])(text.length);\n          }\n\n          if (this.dom.arrayInfo) {\n            if (Array.isArray(this.json)) {\n              this.dom.arrayInfo.innerText = 'Array: ' + this.json.length + ' items';\n            } else {\n              this.dom.arrayInfo.innerText = '';\n            }\n          }\n        };\n        /**\n         * Handle a change:\n         * - Validate JSON schema\n         * - Send a callback to the onChange listener if provided\n         * @private\n         */\n\n\n        previewmode._onChange = function () {\n          // validate JSON schema (if configured)\n          this._debouncedValidate(); // trigger the onChange callback\n\n\n          if (this.options.onChange) {\n            try {\n              this.options.onChange();\n            } catch (err) {\n              console.error('Error in onChange callback: ', err);\n            }\n          } // trigger the onChangeJSON callback\n\n\n          if (this.options.onChangeJSON) {\n            try {\n              this.options.onChangeJSON(this.get());\n            } catch (err) {\n              console.error('Error in onChangeJSON callback: ', err);\n            }\n          } // trigger the onChangeText callback\n\n\n          if (this.options.onChangeText) {\n            try {\n              this.options.onChangeText(this.getText());\n            } catch (err) {\n              console.error('Error in onChangeText callback: ', err);\n            }\n          }\n        };\n        /**\n         * Open a sort modal\n         * @private\n         */\n\n\n        previewmode._showSortModal = function () {\n          var me = this;\n\n          function onSort(json, sortedBy) {\n            if (Array.isArray(json)) {\n              var sortedArray = Object(util[\"sort\"])(json, sortedBy.path, sortedBy.direction);\n              me.sortedBy = sortedBy;\n\n              me._setAndFireOnChange(sortedArray);\n            }\n\n            if (Object(util[\"isObject\"])(json)) {\n              var sortedObject = Object(util[\"sortObjectKeys\"])(json, sortedBy.direction);\n              me.sortedBy = sortedBy;\n\n              me._setAndFireOnChange(sortedObject);\n            }\n          }\n\n          this.executeWithBusyMessage(function () {\n            var container = me.options.modalAnchor || constants[\"a\"\n            /* DEFAULT_MODAL_ANCHOR */\n            ];\n            var json = me.get();\n\n            me._renderPreview(); // update array count\n\n\n            Object(showSortModal[\"a\"\n            /* showSortModal */\n            ])(container, json, function (sortedBy) {\n              me.executeWithBusyMessage(function () {\n                onSort(json, sortedBy);\n              }, 'sorting...');\n            }, me.sortedBy);\n          }, 'parsing...');\n        };\n        /**\n         * Open a transform modal\n         * @private\n         */\n\n\n        previewmode._showTransformModal = function () {\n          var me = this;\n          this.executeWithBusyMessage(function () {\n            var anchor = me.options.modalAnchor || constants[\"a\"\n            /* DEFAULT_MODAL_ANCHOR */\n            ];\n            var json = me.get();\n\n            me._renderPreview(); // update array count\n\n\n            Object(showTransformModal[\"a\"\n            /* showTransformModal */\n            ])(anchor, json, function (query) {\n              me.executeWithBusyMessage(function () {\n                var updatedJson = jmespath_default.a.search(json, query);\n\n                me._setAndFireOnChange(updatedJson);\n              }, 'transforming...');\n            });\n          }, 'parsing...');\n        };\n        /**\n         * Destroy the editor. Clean up DOM, event listeners, and web workers.\n         */\n\n\n        previewmode.destroy = function () {\n          if (this.frame && this.container && this.frame.parentNode === this.container) {\n            this.container.removeChild(this.frame);\n          }\n\n          if (this.modeSwitcher) {\n            this.modeSwitcher.destroy();\n            this.modeSwitcher = null;\n          }\n\n          this._debouncedValidate = null;\n          this.history.clear();\n          this.history = null;\n        };\n        /**\n         * Compact the code in the text editor\n         */\n\n\n        previewmode.compact = function () {\n          var json = this.get();\n          var text = JSON.stringify(json); // we know that in this case the json is still the same, so we pass json too\n\n          this._setTextAndFireOnChange(text, json);\n        };\n        /**\n         * Format the code in the text editor\n         */\n\n\n        previewmode.format = function () {\n          var json = this.get();\n          var text = JSON.stringify(json, null, this.indentation); // we know that in this case the json is still the same, so we pass json too\n\n          this._setTextAndFireOnChange(text, json);\n        };\n        /**\n         * Repair the code in the text editor\n         */\n\n\n        previewmode.repair = function () {\n          var text = this.getText();\n          var repairedText = Object(util[\"repair\"])(text);\n\n          this._setTextAndFireOnChange(repairedText);\n        };\n        /**\n         * Set focus to the editor\n         */\n\n\n        previewmode.focus = function () {\n          // we don't really have a place to focus,\n          // let's focus on the transform button\n          this.dom.transform.focus();\n        };\n        /**\n         * Set json data in the editor\n         * @param {*} json\n         */\n\n\n        previewmode.set = function (json) {\n          if (this.history) {\n            this.history.clear();\n          }\n\n          this._set(json);\n        };\n        /**\n         * Update data. Same as calling `set` in text/code mode.\n         * @param {*} json\n         */\n\n\n        previewmode.update = function (json) {\n          this._set(json);\n        };\n        /**\n         * Set json data\n         * @param {*} json\n         */\n\n\n        previewmode._set = function (json) {\n          this.text = undefined;\n          this.json = json;\n\n          this._renderPreview();\n\n          this._pushHistory(); // validate JSON schema\n\n\n          this._debouncedValidate();\n        };\n\n        previewmode._setAndFireOnChange = function (json) {\n          this._set(json);\n\n          this._onChange();\n        };\n        /**\n         * Get json data\n         * @return {*} json\n         */\n\n\n        previewmode.get = function () {\n          if (this.json === undefined) {\n            var text = this.getText();\n            this.json = Object(util[\"parse\"])(text); // this can throw an error\n          }\n\n          return this.json;\n        };\n        /**\n         * Get the text contents of the editor\n         * @return {String} jsonText\n         */\n\n\n        previewmode.getText = function () {\n          if (this.text === undefined) {\n            this.text = JSON.stringify(this.json, null, this.indentation);\n\n            if (this.options.escapeUnicode === true) {\n              this.text = Object(util[\"escapeUnicodeChars\"])(this.text);\n            }\n          }\n\n          return this.text;\n        };\n        /**\n         * Set the text contents of the editor\n         * @param {String} jsonText\n         */\n\n\n        previewmode.setText = function (jsonText) {\n          if (this.history) {\n            this.history.clear();\n          }\n\n          this._setText(jsonText);\n        };\n        /**\n         * Update the text contents\n         * @param {string} jsonText\n         */\n\n\n        previewmode.updateText = function (jsonText) {\n          // don't update if there are no changes\n          if (this.getText() === jsonText) {\n            return;\n          }\n\n          this._setText(jsonText);\n        };\n        /**\n         * Set the text contents of the editor\n         * @param {string} jsonText\n         * @param {*} [json] Optional JSON instance of the text\n         * @private\n         */\n\n\n        previewmode._setText = function (jsonText, json) {\n          if (this.options.escapeUnicode === true) {\n            this.text = Object(util[\"escapeUnicodeChars\"])(jsonText);\n          } else {\n            this.text = jsonText;\n          }\n\n          this.json = json;\n\n          this._renderPreview();\n\n          if (this.json === undefined) {\n            var me = this;\n            this.executeWithBusyMessage(function () {\n              try {\n                // force parsing the json now, else it will be done in validate without feedback\n                me.json = me.get();\n\n                me._renderPreview();\n\n                me._pushHistory();\n              } catch (err) {// no need to throw an error, validation will show an error\n              }\n            }, 'parsing...');\n          } else {\n            this._pushHistory();\n          }\n\n          this._debouncedValidate();\n        };\n        /**\n         * Set text and fire onChange callback\n         * @param {string} jsonText\n         * @param {*} [json] Optional JSON instance of the text\n         * @private\n         */\n\n\n        previewmode._setTextAndFireOnChange = function (jsonText, json) {\n          this._setText(jsonText, json);\n\n          this._onChange();\n        };\n        /**\n         * Apply history to the current state\n         * @param {{json?: JSON, text?: string}} action\n         * @private\n         */\n\n\n        previewmode._applyHistory = function (action) {\n          this.json = action.json;\n          this.text = action.text;\n\n          this._renderPreview();\n\n          this._debouncedValidate();\n        };\n        /**\n         * Push the current state to history\n         * @private\n         */\n\n\n        previewmode._pushHistory = function () {\n          if (!this.history) {\n            return;\n          }\n\n          var action = {\n            text: this.text,\n            json: this.json\n          };\n          this.history.add(action);\n        };\n        /**\n         * Execute a heavy, blocking action.\n         * Before starting the action, show a message on screen like \"parsing...\"\n         * @param {function} fn\n         * @param {string} message\n         */\n\n\n        previewmode.executeWithBusyMessage = function (fn, message) {\n          var size = this.getText().length;\n\n          if (size > constants[\"d\"\n          /* SIZE_LARGE */\n          ]) {\n            var me = this;\n            Object(util[\"addClassName\"])(me.frame, 'busy');\n            me.dom.busyContent.innerText = message;\n            setTimeout(function () {\n              fn();\n              Object(util[\"removeClassName\"])(me.frame, 'busy');\n              me.dom.busyContent.innerText = '';\n            }, 100);\n          } else {\n            fn();\n          }\n        }; // TODO: refactor into composable functions instead of this shaky mixin-like structure\n\n\n        previewmode.validate = previewmode_textmode.validate;\n        previewmode._renderErrors = previewmode_textmode._renderErrors; // define modes\n\n        var previewModeMixins = [{\n          mode: 'preview',\n          mixin: previewmode,\n          data: 'json'\n        }];\n        /***/\n      }\n      /******/\n      ])\n    );\n  });\n});\nvar JSONEditor = unwrapExports(jsoneditorMinimalist);\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n/**\n * @typedef {{\n * tree: string,\n * view: string,\n * form: string,\n * code: string,\n * text: string,\n * allValues: Array<string>\n * }} TJsonEditorModes\n */\n\n\nvar modes = {\n  tree: 'tree',\n  view: 'view',\n  form: 'form',\n  code: 'code',\n  text: 'text'\n};\nvar values = Object.values(modes);\nmodes.allValues = values;\n/**\n * @type {object}\n * @property {object} [value]\n * @property {string} [mode='tree'] - Set the editor mode.\n * @property {string} [name=undefined] - Initial field name for the root node\n * @property {object} [schema] - Validate the JSON object against a JSON schema.\n * @property {object} [schemaRefs] - Schemas that are referenced using\n * the $ref property\n * @property {Function} [onChange] - Set a callback function\n * triggered when the contents of the JSONEditor change.\n * Called without parameters. Will only be triggered on changes made by the user.\n * Return new json.\n * @property {Function} [onError] - Set a callback function triggered when an error occurs.\n * Invoked with the error as first argument.\n * The callback is only invoked for errors triggered by a users action,\n * like switching from code mode to tree mode or clicking\n * the Format button whilst the editor doesn't contain valid JSON.\n * @property {Function} [onModeChange] - Set a callback function\n * triggered right after the mode is changed by the user.\n * @property {object} [ace] - Provide a version of the Ace editor.\n * Only applicable when mode is code\n * @property {object} [ajv] - Provide a instance of ajv,\n * the library used for JSON schema validation.\n * @property {string} [theme] - Set the Ace editor theme,\n * uses included 'ace/theme/jsoneditor' by default.\n * @property {boolean} [history=false] - Enables history,\n * adds a button Undo and Redo to the menu of the JSONEditor. Only applicable when\n * mode is 'tree' or 'form'\n * @property {boolean} [navigationBar=true] - Adds navigation bar to the menu\n * the navigation bar visualize the current position on the\n * tree structure as well as allows breadcrumbs navigation.\n * @property {boolean} [statusBar=true] - Adds status bar to the buttom of the editor\n * the status bar shows the cursor position and a count of the selected characters.\n * Only applicable when mode is 'code' or 'text'.\n * @property {boolean} [search=true] - Enables a search box in\n * the upper right corner of the JSONEditor.\n * @property {Array<string>} [allowedModes] - Create a box in the editor menu where\n * the user can switch between the specified modes.\n * @property {(string|PropTypes.elementType)} [tag='div'] - Html element, or react element to render\n * @property {object} [htmlElementProps] - html element custom props\n * @property {Function} [innerRef] - callback to get html element reference\n */\n\nvar Editor = function (_Component) {\n  inherits(Editor, _Component);\n\n  function Editor(props) {\n    classCallCheck(this, Editor);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, props));\n\n    _this.htmlElementRef = null;\n    _this.jsonEditor = null;\n    _this.handleChange = _this.handleChange.bind(_this);\n    _this.setRef = _this.setRef.bind(_this);\n    _this.collapseAll = _this.collapseAll.bind(_this);\n    _this.expandAll = _this.expandAll.bind(_this);\n    _this.focus = _this.focus.bind(_this);\n    return _this;\n  }\n  /**\n   * @type TJsonEditorModes\n   */\n\n\n  Editor.prototype.componentDidMount = function componentDidMount() {\n    var _props = this.props,\n        allowedModes = _props.allowedModes,\n        innerRef = _props.innerRef,\n        htmlElementProps = _props.htmlElementProps,\n        tag = _props.tag,\n        onChange = _props.onChange,\n        rest = objectWithoutProperties(_props, ['allowedModes', 'innerRef', 'htmlElementProps', 'tag', 'onChange']);\n    this.createEditor(_extends({}, rest, {\n      modes: allowedModes\n    }));\n  };\n\n  Editor.prototype.componentWillReceiveProps = function componentWillReceiveProps(_ref) {\n    var allowedModes = _ref.allowedModes,\n        schema = _ref.schema,\n        name = _ref.name,\n        theme = _ref.theme,\n        schemaRefs = _ref.schemaRefs,\n        innerRef = _ref.innerRef,\n        htmlElementProps = _ref.htmlElementProps,\n        tag = _ref.tag,\n        onChange = _ref.onChange,\n        rest = objectWithoutProperties(_ref, ['allowedModes', 'schema', 'name', 'theme', 'schemaRefs', 'innerRef', 'htmlElementProps', 'tag', 'onChange']);\n\n    if (this.jsonEditor) {\n      if (theme !== this.props.theme) {\n        this.createEditor(_extends({}, rest, {\n          theme: theme,\n          modes: allowedModes\n        }));\n      } else {\n        if (schema !== this.props.schema || schemaRefs !== this.props.schemaRefs) {\n          this.jsonEditor.setSchema(schema, schemaRefs);\n        }\n\n        if (name !== this.jsonEditor.getName()) {\n          this.jsonEditor.setName(name);\n        }\n      }\n    }\n  };\n\n  Editor.prototype.shouldComponentUpdate = function shouldComponentUpdate(_ref2) {\n    var htmlElementProps = _ref2.htmlElementProps;\n    return htmlElementProps !== this.props.htmlElementProps;\n  };\n\n  Editor.prototype.componentWillUnmount = function componentWillUnmount() {\n    if (this.jsonEditor) {\n      this.jsonEditor.destroy();\n      this.jsonEditor = null;\n    }\n  };\n\n  Editor.prototype.setRef = function setRef(element) {\n    this.htmlElementRef = element;\n\n    if (this.props.innerRef) {\n      this.props.innerRef(element);\n    }\n  };\n\n  Editor.prototype.createEditor = function createEditor(_ref3) {\n    var value = _ref3.value,\n        rest = objectWithoutProperties(_ref3, ['value']);\n\n    if (this.jsonEditor) {\n      this.jsonEditor.destroy();\n    }\n\n    this.jsonEditor = new JSONEditor(this.htmlElementRef, _extends({\n      onChange: this.handleChange\n    }, rest));\n    this.jsonEditor.set(value);\n  };\n\n  Editor.prototype.handleChange = function handleChange() {\n    if (this.props.onChange) {\n      try {\n        var text = this.jsonEditor.getText();\n\n        if (text === '') {\n          this.props.onChange(null);\n        }\n\n        var currentJson = this.jsonEditor.get();\n\n        if (this.props.value !== currentJson) {\n          this.props.onChange(currentJson);\n        }\n      } catch (err) {\n        this.err = err;\n      }\n    }\n  };\n\n  Editor.prototype.collapseAll = function collapseAll() {\n    if (this.jsonEditor) {\n      this.jsonEditor.collapseAll();\n    }\n  };\n\n  Editor.prototype.expandAll = function expandAll() {\n    if (this.jsonEditor) {\n      this.jsonEditor.expandAll();\n    }\n  };\n\n  Editor.prototype.focus = function focus() {\n    if (this.jsonEditor) {\n      this.jsonEditor.focus();\n    }\n  };\n\n  Editor.prototype.render = function render() {\n    var _props2 = this.props,\n        htmlElementProps = _props2.htmlElementProps,\n        tag = _props2.tag;\n    return React.createElement(tag, _extends({}, htmlElementProps, {\n      ref: this.setRef\n    }));\n  };\n\n  return Editor;\n}(Component);\n\nEditor.propTypes = {\n  //  jsoneditor props\n  value: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),\n  mode: PropTypes.oneOf(values),\n  name: PropTypes.string,\n  schema: PropTypes.object,\n  schemaRefs: PropTypes.object,\n  onChange: PropTypes.func,\n  onError: PropTypes.func,\n  onModeChange: PropTypes.func,\n  ace: PropTypes.object,\n  ajv: PropTypes.object,\n  theme: PropTypes.string,\n  history: PropTypes.bool,\n  navigationBar: PropTypes.bool,\n  statusBar: PropTypes.bool,\n  search: PropTypes.bool,\n  allowedModes: PropTypes.arrayOf(PropTypes.oneOf(values)),\n  //  custom props\n  tag: PropTypes.oneOfType([PropTypes.string, PropTypes.elementType]),\n  htmlElementProps: PropTypes.object,\n  innerRef: PropTypes.func\n};\nEditor.defaultProps = {\n  tag: 'div',\n  mode: modes.tree,\n  history: false,\n  search: true,\n  navigationBar: true,\n  statusBar: true\n};\nEditor.modes = modes;\nexport { Editor as JsonEditor };","map":null,"metadata":{},"sourceType":"module"}